{"id": "763ee444-7497-4f0d-98f5-d76fba5cf5df", "text": "Q: Laravel actingAs guest A: <p><a href=\"https://github.com/laravel/framework/pull/56517\" rel=\"nofollow noreferrer\">Laravel now has an <code>actingAsGuest</code> method</a> you can call to clear an authenticated user in tests.</p>\n<pre><code>$this-&gt;actingAsGuest();\n</code></pre>\n", "tags": ["laravel", "authentication", "testing"]}
{"id": "7c45f6ea-681a-4cf7-86dc-53d34d753bc1", "text": "Q: Determine WHY Features Are Important in Decision Tree Models A: <p>tldr; <a href=\"http://scikit-learn.org/stable/auto_examples/ensemble/plot_partial_dependence.html\" rel=\"nofollow noreferrer\">http://scikit-learn.org/stable/auto_examples/ensemble/plot_partial_dependence.html</a></p>\n\n<hr>\n\n<p>I'd like to clear up some of the wording to make sure we're on the same page.</p>\n\n<ol>\n<li><em>Predictive power</em>: what features <em>significantly</em> contribute to the prediction</li>\n<li><em>Feature dependence</em>: are the features positively or negatively\ncorrelated, i.e., does a change in the feature X cause the prediction y to increase/decrease</li>\n</ol>\n\n<p><strong>1. Predictive power</strong></p>\n\n<p>Your feature importance shows you what retains the most information, and are the most <em>significant</em> features. Power could imply what causes the biggest change - you would have to check by plugging in dummy values to see their overall impact, much like you would have to do with linear regression coefficients.</p>\n\n<p><strong>2. Correlation/Dependence</strong></p>\n\n<p>As pointed out by @Tiago1984, it depends heavily on the underlying algorithm. XGBoost/GBM are additively building a committee of stubs (decision trees with a low number of trees, usually only one split). </p>\n\n<p>In a regression problem, the trees are typically using a criterion related to the MSE. I won't go into the full details, but you can read more here: <a href=\"https://medium.com/towards-data-science/boosting-algorithm-gbm-97737c63daa3\" rel=\"nofollow noreferrer\">https://medium.com/towards-data-science/boosting-algorithm-gbm-97737c63daa3</a>. </p>\n\n<p>You'll see that at each step it calculates a vector for the \"direction\" of the weak learner, so you in principle know the direction of the influence from it (but keep in mind it may appear many times in one tree, in multiple steps of the additive model).</p>\n\n<p>But, to cut to the chase; you could just fix all your features apart from <code>f19</code> and make a prediction for a range of <code>f19</code> values and see how it is related to the response value.</p>\n\n<p>Take a look at <em>partial dependency plots</em>: <a href=\"http://scikit-learn.org/stable/auto_examples/ensemble/plot_partial_dependence.html\" rel=\"nofollow noreferrer\">http://scikit-learn.org/stable/auto_examples/ensemble/plot_partial_dependence.html</a></p>\n\n<p>There's also a chapter on it in <em>Elements of Statistical Learning</em>, Chapter 10.13.2.</p>\n", "tags": ["python", "machine-learning", "scikit-learn", "decision-tree", "xgboost"]}
{"id": "6b6ba601-af39-4176-8cc2-980f1a85b92d", "text": "Q: Adapting a SwiftUI View for top-level or enclosed A: <blockquote>\n<p>Can a View be designed for both uses?</p>\n</blockquote>\n<p>If I understand correctly, you don't have two uses, you have a single use - opening a single message with the single message view. It would be bad architecture to have two different views that do exactly the same thing.</p>\n<p>Say you have <code>EmailEntriesListView</code> for opening the archive and <code>SingleEmailEntryView</code> for opening an individual message. In your archive/list view loop, every item/message will point to the single message view:</p>\n<pre class=\"lang-swift prettyprint-override\"><code>SingleEmailEntryView(message: message)\n</code></pre>\n<p>And if you open an individual message directly, the call will be the same.</p>\n<blockquote>\n<p>This includes possibly using different methods to pass the message data to the View.</p>\n</blockquote>\n<p>Although this is a bit vague, if your question is whether a view can accept different parameter sets, then yes, a <code>View</code> can have multiple initializer declarations, which would allow you to open an individual message as before, by passing a <code>message</code> parameter, or maybe by passing a <code>filename</code> parameter:</p>\n<pre class=\"lang-swift prettyprint-override\"><code>SingleEmailEntryView(filename: messageFileName)\n</code></pre>\n", "tags": ["swiftui"]}
{"id": "c3d8e41d-b022-46f2-97ac-2863a9a68bff", "text": "Q: Performing cumulative sum in a Window with different columns ordering and null last configuration in Polars A: <p>You need to ensure that the DataFrame is sorted correctly before applying the cumulative sum.</p>\n<ol>\n<li><p>Sort the DataFrame to achieve the desired order.</p>\n</li>\n<li><p>Use the <strong><code>cum_sum()</code></strong> function with the correct <code>over</code> clause.</p>\n</li>\n</ol>\n<p>The below should allow you to get what you need.</p>\n<pre><code>import polars as pl  \nfrom datetime import date  \n  \n# DataFrame  \ntest_df = pl.DataFrame([  \n    (&quot;A&quot;, None, date(2009, 1, 24), 1),  \n    (&quot;A&quot;, date(2018, 11, 26), None, 1),  \n    (&quot;A&quot;, date(2010, 3, 24), date(2013, 1, 24), 1),  \n], schema=[&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;, &quot;col4&quot;])  \n  \n# Sort\nsorted_df = test_df.sort(  \n    by=[&quot;col1&quot;, pl.col(&quot;col2&quot;).sort(descending=True, nulls_last=True), pl.col(&quot;col3&quot;).sort(descending=True, nulls_last=False)]  \n)  \n  \n# Add the cumulative sum column  \nresult_df = sorted_df.with_columns(  \n    pl.col(&quot;col4&quot;).cum_sum().over(  \n        partition_by=[&quot;col1&quot;],  \n        order_by=[  \n            pl.col(&quot;col2&quot;).sort(descending=True, nulls_last=True),  \n            pl.col(&quot;col3&quot;).sort(descending=True, nulls_last=False)  \n        ]  \n    ).alias(&quot;col5&quot;)  \n)  \n  \nprint(result_df)  \n\n\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \n\u2502 col1 \u2506 col2       \u2506 col3       \u2506 col4 \u2506 col5 \u2502  \n\u2502 ---  \u2506 ---        \u2506 ---        \u2506 ---  \u2506 ---  \u2502  \n\u2502 str  \u2506 date       \u2506 date       \u2506 i64  \u2506 i64  \u2502  \n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561  \n\u2502 A    \u2506 null       \u2506 2009-01-24 \u2506 1    \u2506 3    \u2502  \n\u2502 A    \u2506 2010-03-24 \u2506 2013-01-24 \u2506 1    \u2506 2    \u2502  \n\u2502 A    \u2506 2018-11-26 \u2506 null       \u2506 1    \u2506 1    \u2502  \n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \n</code></pre>\n", "tags": ["python", "dataframe", "window-functions", "python-polars"]}
{"id": "07c01f70-c8f7-477a-af73-1586bc812881", "text": "Q: ggplot superscript in axis labels A: <p>I was successful with ChatGPT. No idea why that works better, because it creates the exact same expression but the problem is gone:</p>\n<pre><code>scientific_10 &lt;- function(x) {\n    as.expression(\n        lapply(x, function(i) bquote(10^.(i - 5)))\n    )\n}\n</code></pre>\n", "tags": ["ggplot2", "superscript"]}
