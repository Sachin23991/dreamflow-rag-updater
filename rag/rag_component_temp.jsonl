{"id": "375a50eb-4072-4cd8-acab-473fa5b1d2de", "text": "Q: C++ vs Java performance under repeated heave computation A: <p><code>FFT::bitReversedIndices</code> should probably be replaced with a static lookup table. The rest of the code might be faster with <a href=\"https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html\" rel=\"nofollow noreferrer\">simd intrinsics</a></p>\n", "tags": ["java", "c++", "performance"]}
{"id": "a64a7f83-b385-43cd-9891-b80051f92e6f", "text": "Q: Gnuplot provides set loadpath to add folders to GNUPLOT_LIB. Unsure about the proper syntax to be used A: <p>The curly brackets are part of the user manual syntax that indicates an optional part of a command.  They are not to be typed as part of the command itself.  So the hypothetical manual entry</p>\n<p><code>set foo A {B {C}} {D}</code></p>\n<p>signifies that the following are all legal commands:</p>\n<pre><code>set foo A\nset foo A B\nset foo A B C\nset foo A B D\nset foo A D\n</code></pre>\n<p>I. e. A is required, B is optional and if present can optionally be followed by C.  C without B is not allowed.  D is optional and independent of B or BC.</p>\n<p>The difference between single quote ' and double quote &quot; is explained in the manual on quotes or from the gnuplot command line <code>gnuplot&gt; help quotes</code>.  In short they differ by whether or not the backslash character is treated as a literal backslash or as the start of a multi-character escape sequence.  For filenames this difference is largely irrelevant on linux since backslash characters are rare.  Obviously it can make a huge difference on windows since backslashes are a normal part of a file's path name.  Probably safest to always use single quotes in a Windows environment.</p>\n<p>Short version:  The <code>set loadpath</code> command will accept any number of paths, with each path in quotes and a space between them.  On Windows, use single quotes.</p>\n<pre><code>gnuplot&gt; set loadpath 'dir1/sub2' 'dir2' 'dir3'\ngnuplot&gt; show loadpath\n        loadpath is &quot;dir1/sub2&quot; &quot;dir2&quot; &quot;dir3&quot; \n</code></pre>\n<p>NB: the example above is pasted from a linux system; I don't know whether it would echo back differently under Windows.</p>\n", "tags": ["gnuplot"]}
{"id": "abcb5ac1-6713-4daf-a8b7-da025c67b208", "text": "Q: Writing a typing game, with an animated keyboard A: <p>What actually is your desired end result / behaviour of the program? That it just has a list of all the letters in the alphabet, and then applies these styles to them when they're pressed?</p>\n<p>Most typing games show the same letters multiple times to spell out words or phrases that the user types, so I'm wondering if that is where you're wanting to head --- in which case I think the recommendations for how to get there are very different</p>\n", "tags": ["javascript", "html", "css", "keydown"]}
{"id": "70f28db8-a66c-4799-8fa4-f02d998a3673", "text": "Q: Best way to compress an image Javascript React Web App A: <p>Why not use this npm package which does all the conversion, compression and cropping from the front end before sending the blob or file to the backend.</p>\n<p><a href=\"https://www.npmjs.com/package/crop-image-pro\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/crop-image-pro</a></p>\n", "tags": ["javascript", "image", "reactjs"]}
{"id": "10e6bc67-4908-43dd-b35b-77ec1a2a19d3", "text": "Q: List&lt;IFormFile&gt; is null for large files A: <p>ASP.NET Core can handle huge <code>multipart/form-data</code> requests just fine, <a href=\"https://learn.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-10.0#small-and-large-files\" rel=\"nofollow noreferrer\">but you cannot use <code>[FromBody]</code> binding to <code>IFormFile</code> (or <code>FormFile</code>) for requests larger than 128MB</a>:</p>\n<p>You <em>can</em> adjust <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.features.formoptions.multipartbodylengthlimit?view=aspnetcore-10.0#microsoft-aspnetcore-http-features-formoptions-multipartbodylengthlimit\" rel=\"nofollow noreferrer\">the <code>FormOptions.MultipartBodyLengthLimit</code> value</a> to a larger value, but I don't recommend it here because it sounds like you're dead-set on allowing multi-gigabyte sized uploads, which aren't going to buffer well.</p>\n<p>Note that <code>FormFile</code> does buffer to-disk once the amount of data received exceeds the in-memory maximum (a paltry 64KB), but I suspect you probably don't want these centigigabyte-sized blobs filling up your system's local disks either.</p>\n<p>Instead, I recommend you follow <a href=\"https://learn.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-10.0#upload-large-files-with-streaming\" rel=\"nofollow noreferrer\">the instructions under <em><strong>Upload large files with streaming</strong></em> instead</a>:</p>\n<pre><code>private const Int64 HUNDRED_GIGABYTES = 100 * 1024 * 1024 * 1024; // 107,374,182,400 bytes\n\n[HttpPost]\n[RequestSizeLimit( HUNDRED_GIGABYTES )]\npublic async Task&lt;IActionResult&gt; PostFormData( CancellationToken cancellationToken )\n{\n    MediaTypeHeaderValue requestContentType = MediaTypeHeaderValue.Parse( this.Request.ContentType );\n    String requestMultipartBoundary = HeaderUtilities.RemoveQuotes( requestContentType.Boundary ).Value;\n\n    //\n\n    MultipartReader reader = new MultipartReader( requestMultipartBoundary, this.Request.Body );\n    \n    while( true )\n    {\n        MultipartSection? section = await reader.ReadNextSectionAsync( cancellationToken );\n        if( section is null ) break;\n\n        ContentDispositionHeaderValue? cd = section.GetContentDispositionHeader();\n        if( cd is null ) continue;\n        if( !cd.IsFileDisposition() ) continue;\n\n        //\n\n        using( Stream outputStream = /* FileStream? SAN stream? Some stream-consumer adapted into a Sink-Stream? etc? */ )\n        {\n            await section.Body.CopyToAsync( outputStream, cancellationToken );\n        }\n    }\n}\n</code></pre>\n<p>Further improvements are possible still: for example, use <code>HttpRequest.BodyReader</code> (an <code>PipeReader</code>) for lower-level access - though you'll need to parse/process <code>multipart/form-data</code> separators yourself.</p>\n", "tags": ["javascript", "c#", "file-upload", "multipart"]}
{"id": "b5b8844f-7567-4e19-982e-6e4f42cb4976", "text": "Q: How to use the win32com library to modify a Word document and save it to a new Word file A: <p>Change this line of your code</p>\n<pre><code>finder.Execute(FindText=search_text, ReplaceWith=replace_text, Replace=wd_replace_all)\n</code></pre>\n<p>to:</p>\n<pre><code>finder.Execute(search_text, False, False, False, False, False, True, 1, False, replace_text, 2)\n</code></pre>\n<p>It is actually like <code>Find.Execute</code> function of <code>VBA</code>.\nSee also <a href=\"https://learn.microsoft.com/zh-cn/office/vba/api/word.find.execute2007\" rel=\"nofollow noreferrer\">https://learn.microsoft.com/zh-cn/office/vba/api/word.find.execute2007</a></p>\n", "tags": ["python", "replace", "ms-word", "pywin32"]}
