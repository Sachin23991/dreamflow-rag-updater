{"id": "fb591fe8-8c55-4884-a4f5-742a38ebe8dc", "text": "Q: Slack Block Kit ordered and unordered lists? A: <p>Slack's Block Kit now more formally supports rich text blocks, and a <a href=\"https://docs.slack.dev/reference/block-kit/blocks/rich-text-block#rich_text_list\" rel=\"nofollow noreferrer\">rich text list</a> is part of that:</p>\n<pre class=\"lang-js prettyprint-override\"><code>{\n  &quot;blocks&quot;: [\n    {\n      &quot;type&quot;: &quot;rich_text&quot;,\n      &quot;elements&quot;: [\n        {\n          &quot;type&quot;: &quot;rich_text_list&quot;,\n          &quot;style&quot;: &quot;bullet&quot;,\n          &quot;elements&quot;: [\n            {\n              &quot;type&quot;: &quot;rich_text_section&quot;,\n              &quot;elements&quot;: [{\n                &quot;type&quot;: &quot;text&quot;,\n                &quot;text&quot;: &quot;List item 1&quot;\n              }]\n            },\n            {\n              &quot;type&quot;: &quot;rich_text_section&quot;,\n              &quot;elements&quot;: [{\n                &quot;type&quot;: &quot;text&quot;,\n                &quot;text&quot;: &quot;List item 2&quot;\n              }]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>\n", "tags": ["slack", "slack-api", "slack-block-kit"]}
{"id": "abd8a731-95a0-40fe-9593-a093ad442d2c", "text": "Q: How to refresh an OpenAPI service reference in Visual Studio A: <p>I have the same problem and the only solution I've found is to remove generated class from obj folder and then rebuild the project. But this is more workaround then solution...</p>\n", "tags": ["visual-studio", "openapi"]}
{"id": "29cdb62c-49f8-4f15-98c7-b23fba08593b", "text": "Q: React Native and expo for web A: <p>It depends.</p>\n<p>On large-scale apps, I think having something like:</p>\n<ul>\n<li>&quot;if ios, store in secure storage, if android, store in secure storage, if WEB, store in local storage of if X then store in database on web app&quot;</li>\n</ul>\n<p>Is not ideal.</p>\n<p>So for small scale apps, where data is primarily stored on a server / not on device, I'd highly recommend using expo for both, it's incredibly easy. But if you have a lot of local data, that data will need to be sqlite/ secure storage on mobile, and a remote database on web, leading to messy / complex code.</p>\n<p>If it's for internal use, most likely the storage will be on a database, so I would recommend using expo for both.</p>\n", "tags": ["react-native", "expo"]}
{"id": "c68eb99c-ccb1-400f-a4f6-4bf6ce2c084a", "text": "Q: unable to login to sqlplus in oracle A: <p>You have typo in username .</p>\n<p>It should be system</p>\n", "tags": ["database", "oracle-database", "oracle10g"]}
{"id": "a6627a39-8440-4bff-96a8-4e786d2810de", "text": "Q: How can I iterate over rows in a Pandas DataFrame? A: <p>Key takeaways:</p>\n<ol>\n<li>Use vectorization.</li>\n<li><strong>Speed profile</strong> your code! Don't assume something is faster because you <em>think</em> it is faster; speed profile it and <em>prove</em> it is faster. The results may surprise you. To get high-precision timestamps in Python, see my answer here: <a href=\"https://stackoverflow.com/a/73482099/4561887\">High-precision clock in Python</a>.</li>\n</ol>\n<h2>How to iterate over Pandas <code>DataFrame</code>s without iterating</h2>\n<p>After <em>several weeks</em> of working on this answer, here's what I've come up with:</p>\n<p>Here are <strong>13 techniques for iterating over Pandas <code>DataFrame</code>s</strong>. As you can see, the time it takes varies <em>dramatically</em>. The fastest technique is <strong>~1363x</strong> faster than the slowest technique! The key takeaway, <a href=\"https://stackoverflow.com/a/55557758/4561887\">as @cs95 says here</a>, is <strong><em>don't</em> iterate! Use vectorization (<a href=\"https://en.wikipedia.org/wiki/Array_programming\" rel=\"nofollow noreferrer\">&quot;array programming&quot;</a>) instead.</strong> All this really means is that you should use the arrays directly in mathematical formulas rather than trying to manually iterate over the arrays. The underlying objects must support this, of course, but both Numpy and Pandas <em>do</em>.</p>\n<p>There are many ways to use vectorization in Pandas, which you can see in the plot and in my example code below. When using the arrays directly, the underlying looping still takes place, but in (I think) very optimized underlying C code rather than through raw Python.</p>\n<h2>Results</h2>\n<p>13 techniques, numbered 1 to 13, were tested. The technique number and name is underneath each bar. The total calculation time is above each bar. Underneath that is the multiplier to show how much longer it took than the fastest technique to the far right:</p>\n<p><sub>From <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.svg\" rel=\"nofollow noreferrer\"><code>pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.svg</code></a> in my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo (produced by <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py\" rel=\"nofollow noreferrer\">this code</a>).</sub></p>\n<p><a href=\"https://i.sstatic.net/5biMy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/5biMy.png\" alt=\"enter image description here\" /></a></p>\n<h2>Summary</h2>\n<p><strong>List comprehension</strong> and <strong>vectorization</strong> (possibly with <strong>boolean indexing</strong>) are all you really need.</p>\n<p>Use <strong>list comprehension</strong> (good) and <strong>vectorization</strong> (best). Pure vectorization I think is <em>always</em> possible, but may take extra work in complicated calculations. Search this answer for <strong>&quot;boolean indexing&quot;</strong>, <strong>&quot;boolean array&quot;</strong>, and <strong>&quot;boolean mask&quot;</strong> (all three are the same thing) to see some of the more complicated cases where pure vectorization can thereby be used.</p>\n<h4>Here are the 13 techniques, listed in order of <em>fastest first to slowest last</em>. I recommend <em>never</em> using the last (slowest) 3 to 4 techniques.</h4>\n<ol>\n<li>Technique 8: <code>8_pure_vectorization__with_df.loc[]_boolean_array_indexing_for_if_statment_corner_case</code></li>\n<li>Technique 6: <code>6_vectorization__with_apply_for_if_statement_corner_case</code></li>\n<li>Technique 7: <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code></li>\n<li>Technique 11: <code>11_list_comprehension_w_zip_and_direct_variable_assignment_calculated_in_place</code></li>\n<li>Technique 10: <code>10_list_comprehension_w_zip_and_direct_variable_assignment_passed_to_func</code></li>\n<li>Technique 12: <code>12_list_comprehension_w_zip_and_row_tuple_passed_to_func</code></li>\n<li>Technique 5: <code>5_itertuples_in_for_loop</code></li>\n<li>Technique 13: <code>13_list_comprehension_w__to_numpy__and_direct_variable_assignment_passed_to_func</code></li>\n<li>Technique 9: <code>9_apply_function_with_lambda</code></li>\n<li>Technique 1: <code>1_raw_for_loop_using_regular_df_indexing</code></li>\n<li>Technique 2: <code>2_raw_for_loop_using_df.loc[]_indexing</code></li>\n<li>Technique 4: <code>4_iterrows_in_for_loop</code></li>\n<li>Technique 3: <code>3_raw_for_loop_using_df.iloc[]_indexing</code></li>\n</ol>\n<h4>Rules of thumb:</h4>\n<ol>\n<li>Techniques 3, 4, and 2 should <em>never</em> be used. They are super slow and have no advantages whatsoever. Keep in mind though: it's not the indexing technique, such as <code>.loc[]</code> or <code>.iloc[]</code> that makes these techniques bad, but rather, it's <em>the <code>for</code> loop they are in</em> that makes them bad! I use <code>.loc[]</code> inside the fastest (pure vectorization) approach, for instance! So, here are the 3 slowest techniques which should <em>never</em> be used:\n<ol>\n<li><code>3_raw_for_loop_using_df.iloc[]_indexing</code></li>\n<li><code>4_iterrows_in_for_loop</code></li>\n<li><code>2_raw_for_loop_using_df.loc[]_indexing</code></li>\n</ol>\n</li>\n<li>Technique <code>1_raw_for_loop_using_regular_df_indexing</code> should never be used either, but if you're going to use a raw for loop, it's faster than the others.</li>\n<li>The <strong><code>.apply()</code></strong> function (<code>9_apply_function_with_lambda</code>) is ok, but generally speaking, I'd avoid it too. Technique <code>6_vectorization__with_apply_for_if_statement_corner_case</code> did perform better than <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code>, however, which is interesting.</li>\n<li><strong>List comprehension</strong> is great! It's not the fastest, but it is easy to use and very fast!\n<ol>\n<li>The nice thing about it is that it can be used with <em>any</em> function that is intended to work on individual values, or array values. And this means you could have really complicated <code>if</code> statements and things inside the function. So, the tradeoff here is that it gives you great versatility with really readable and re-usable code by using external calculation functions, while still giving you great speed!</li>\n</ol>\n</li>\n<li><strong>Vectorization</strong> is the fastest and best, and what you should use whenever the equation is simple. You can optionally use something like <code>.apply()</code> or <strong>list comprehension</strong> on just the more-complicated portions of the equation, while still easily using vectorization for the rest.</li>\n<li><strong>Pure vectorization</strong> is the absolute fastest and best, and what you should use if you <em>are willing to put in the effort to make it work.</em>\n<ol>\n<li>For simple cases, it's what you should use.</li>\n<li>For complicated cases, <code>if</code> statements, etc., pure vectorization can be made to work too, through <strong>boolean indexing,</strong> but can add extra work and can decrease readability to do so. So, you can optionally use <strong>list comprehension</strong> (usually the best) or <strong>.apply()</strong> (generally slower, but not always) for just those edge cases instead, while still using vectorization for the rest of the calculation. Ex: see techniques <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code> and <code>6_vectorization__with_apply_for_if_statement_corner_case</code>.</li>\n</ol>\n</li>\n</ol>\n<h2>The test data</h2>\n<p>Assume we have the following Pandas DataFrame. It has 2 million rows with 4 columns (<code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>), each with random values from <code>-1000</code> to <code>1000</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>df =\n           A    B    C    D\n0       -365  842  284 -942\n1        532  416 -102  888\n2        397  321 -296 -616\n3       -215  879  557  895\n4        857  701 -157  480\n...      ...  ...  ...  ...\n1999995 -101 -233 -377 -939\n1999996 -989  380  917  145\n1999997 -879  333 -372 -970\n1999998  738  982 -743  312\n1999999 -306 -103  459  745\n</code></pre>\n<p>I produced this DataFrame like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import numpy as np\nimport pandas as pd\n\n# Create an array (numpy list of lists) of fake data\nMIN_VAL = -1000\nMAX_VAL = 1000\n# NUM_ROWS = 10_000_000\nNUM_ROWS = 2_000_000  # default for final tests\n# NUM_ROWS = 1_000_000\n# NUM_ROWS = 100_000\n# NUM_ROWS = 10_000  # default for rapid development &amp; initial tests\nNUM_COLS = 4\ndata = np.random.randint(MIN_VAL, MAX_VAL, size=(NUM_ROWS, NUM_COLS))\n\n# Now convert it to a Pandas DataFrame with columns named &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, and &quot;D&quot;\ndf_original = pd.DataFrame(data, columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;])\nprint(f&quot;df = \\n{df_original}&quot;)\n</code></pre>\n<h2>The test equation/calculation</h2>\n<p>I wanted to demonstrate that all of these techniques are possible on non-trivial functions or equations, so I intentionally made the equation they are calculating require:</p>\n<ol>\n<li><code>if</code> statements</li>\n<li>data from multiple columns in the DataFrame</li>\n<li>data from multiple rows in the DataFrame</li>\n</ol>\n<p>The equation we will be calculating for each row is this. I arbitrarily made it up, but I think it contains enough complexity that you will be able to expand on what I've done to perform any equation you want in Pandas with full vectorization:</p>\n<p><a href=\"https://i.sstatic.net/W3c12.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/W3c12.png\" alt=\"enter image description here\" /></a></p>\n<p>In Python, the above equation can be written like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code># Calculate and return a new value, `val`, by performing the following equation:\nval = (\n    2 * A_i_minus_2\n    + 3 * A_i_minus_1\n    + 4 * A\n    + 5 * A_i_plus_1\n    # Python ternary operator; don't forget parentheses around the entire\n    # ternary expression!\n    + ((6 * B) if B &gt; 0 else (60 * B))\n    + 7 * C\n    - 8 * D\n)\n</code></pre>\n<p>Alternatively, you could write it like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code># Calculate and return a new value, `val`, by performing the following equation:\n\nif B &gt; 0:\n    B_new = 6 * B\nelse:\n    B_new = 60 * B\n\nval = (\n    2 * A_i_minus_2\n    + 3 * A_i_minus_1\n    + 4 * A\n    + 5 * A_i_plus_1\n    + B_new\n    + 7 * C\n    - 8 * D\n)\n</code></pre>\n<p>Either of those can be wrapped into a function. Ex:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def calculate_val(\n        A_i_minus_2,\n        A_i_minus_1,\n        A,\n        A_i_plus_1,\n        B,\n        C,\n        D):\n    val = (\n        2 * A_i_minus_2\n        + 3 * A_i_minus_1\n        + 4 * A\n        + 5 * A_i_plus_1\n        # Python ternary operator; don't forget parentheses around the\n        # entire ternary expression!\n        + ((6 * B) if B &gt; 0 else (60 * B))\n        + 7 * C\n        - 8 * D\n    )\n    return val\n</code></pre>\n<h2>The techniques</h2>\n<p>The full code is available to download and run in my <strong><a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py\" rel=\"nofollow noreferrer\"><code>python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests.py</code></a></strong> file in my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo.</p>\n<h4>Here is the code for all 13 techniques:</h4>\n<ol>\n<li><p><strong>Technique 1:</strong> <code>1_raw_for_loop_using_regular_df_indexing</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>val = [np.NAN]*len(df)\nfor i in range(len(df)):\n    if i &lt; 2 or i &gt; len(df)-2:\n        continue\n\n    val[i] = calculate_val(\n        df[&quot;A&quot;][i-2],\n        df[&quot;A&quot;][i-1],\n        df[&quot;A&quot;][i],\n        df[&quot;A&quot;][i+1],\n        df[&quot;B&quot;][i],\n        df[&quot;C&quot;][i],\n        df[&quot;D&quot;][i],\n    )\ndf[&quot;val&quot;] = val  # put this column back into the dataframe\n</code></pre>\n</li>\n<li><p><strong>Technique 2:</strong> <code>2_raw_for_loop_using_df.loc[]_indexing</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>val = [np.NAN]*len(df)\nfor i in range(len(df)):\n    if i &lt; 2 or i &gt; len(df)-2:\n        continue\n\n    val[i] = calculate_val(\n        df.loc[i-2, &quot;A&quot;],\n        df.loc[i-1, &quot;A&quot;],\n        df.loc[i,   &quot;A&quot;],\n        df.loc[i+1, &quot;A&quot;],\n        df.loc[i,   &quot;B&quot;],\n        df.loc[i,   &quot;C&quot;],\n        df.loc[i,   &quot;D&quot;],\n    )\n\ndf[&quot;val&quot;] = val  # put this column back into the dataframe\n</code></pre>\n</li>\n<li><p><strong>Technique 3:</strong> <code>3_raw_for_loop_using_df.iloc[]_indexing</code></p>\n<pre class=\"lang-py prettyprint-override\"><code># column indices\ni_A = 0\ni_B = 1\ni_C = 2\ni_D = 3\n\nval = [np.NAN]*len(df)\nfor i in range(len(df)):\n    if i &lt; 2 or i &gt; len(df)-2:\n        continue\n\n    val[i] = calculate_val(\n        df.iloc[i-2, i_A],\n        df.iloc[i-1, i_A],\n        df.iloc[i,   i_A],\n        df.iloc[i+1, i_A],\n        df.iloc[i,   i_B],\n        df.iloc[i,   i_C],\n        df.iloc[i,   i_D],\n    )\n\ndf[&quot;val&quot;] = val  # put this column back into the dataframe\n</code></pre>\n</li>\n<li><p><strong>Technique 4:</strong> <code>4_iterrows_in_for_loop</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>val = [np.NAN]*len(df)\nfor index, row in df.iterrows():\n    if index &lt; 2 or index &gt; len(df)-2:\n        continue\n\n    val[index] = calculate_val(\n        df[&quot;A&quot;][index-2],\n        df[&quot;A&quot;][index-1],\n        row[&quot;A&quot;],\n        df[&quot;A&quot;][index+1],\n        row[&quot;B&quot;],\n        row[&quot;C&quot;],\n        row[&quot;D&quot;],\n    )\n\ndf[&quot;val&quot;] = val  # put this column back into the dataframe\n</code></pre>\n</li>\n</ol>\n<p>For all of the next examples, we must first prepare the dataframe by adding columns with previous and next values: <code>A_(i-2)</code>, <code>A_(i-1)</code>, and <code>A_(i+1)</code>. These columns in the DataFrame will be named <code>A_i_minus_2</code>, <code>A_i_minus_1</code>, and <code>A_i_plus_1</code>, respectively:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df_original[&quot;A_i_minus_2&quot;] = df_original[&quot;A&quot;].shift(2)  # val at index i-2\ndf_original[&quot;A_i_minus_1&quot;] = df_original[&quot;A&quot;].shift(1)  # val at index i-1\ndf_original[&quot;A_i_plus_1&quot;] = df_original[&quot;A&quot;].shift(-1)  # val at index i+1\n\n# Note: to ensure that no partial calculations are ever done with rows which\n# have NaN values due to the shifting, we can either drop such rows with\n# `.dropna()`, or set all values in these rows to NaN. I'll choose the latter\n# so that the stats that will be generated with the techniques below will end\n# up matching the stats which were produced by the prior techniques above. ie:\n# the number of rows will be identical to before.\n#\n# df_original = df_original.dropna()\ndf_original.iloc[:2, :] = np.NAN   # slicing operators: first two rows,\n                                   # all columns\ndf_original.iloc[-1:, :] = np.NAN  # slicing operators: last row, all columns\n</code></pre>\n<p>Running the vectorized code just above to produce those 3 new columns took a total of <strong>0.044961 seconds</strong>.</p>\n<p>Now on to the rest of the techniques:</p>\n<ol>\n<li><p><strong>Technique 5:</strong> <code>5_itertuples_in_for_loop</code></p>\n<pre class=\"lang-py prettyprint-override\"><code># pre-allocate a `val` array of the appropriate size\nval = [np.NAN]*len(df)\n# Now iterate over all rows in the dataframe, and populate `val`\nfor row in df.itertuples():\n    val[row.Index] = calculate_val(\n        row.A_i_minus_2,\n        row.A_i_minus_1,\n        row.A,\n        row.A_i_plus_1,\n        row.B,\n        row.C,\n        row.D,\n    )\n\ndf[&quot;val&quot;] = val  # put this column back into the dataframe\n</code></pre>\n</li>\n<li><p><strong>Technique 6:</strong> <code>6_vectorization__with_apply_for_if_statement_corner_case</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>def calculate_new_column_b_value(b_value):\n    # Python ternary operator\n    b_value_new = (6 * b_value) if b_value &gt; 0 else (60 * b_value)\n    return b_value_new\n\n# In this particular example, since we have an embedded `if-else` statement\n# for the `B` column, pure vectorization is less intuitive. So, first we'll\n# calculate a new `B` column using\n# **`apply()`**, then we'll use vectorization for the rest.\ndf[&quot;B_new&quot;] = df[&quot;B&quot;].apply(calculate_new_column_b_value)\n# OR (same thing, but with a lambda function instead)\n# df[&quot;B_new&quot;] = df[&quot;B&quot;].apply(lambda x: (6 * x) if x &gt; 0 else (60 * x))\n\n# Now we can use vectorization for the rest. &quot;Vectorization&quot; in this case\n# means to simply use the column series variables in equations directly,\n# without manually iterating over them. Pandas DataFrames will handle the\n# underlying iteration automatically for you. You just focus on the math.\ndf[&quot;val&quot;] = (\n    2 * df[&quot;A_i_minus_2&quot;]\n    + 3 * df[&quot;A_i_minus_1&quot;]\n    + 4 * df[&quot;A&quot;]\n    + 5 * df[&quot;A_i_plus_1&quot;]\n    + df[&quot;B_new&quot;]\n    + 7 * df[&quot;C&quot;]\n    - 8 * df[&quot;D&quot;]\n)\n</code></pre>\n</li>\n<li><p><strong>Technique 7:</strong> <code>7_vectorization__with_list_comprehension_for_if_statment_corner_case</code></p>\n<pre class=\"lang-py prettyprint-override\"><code># In this particular example, since we have an embedded `if-else` statement\n# for the `B` column, pure vectorization is less intuitive. So, first we'll\n# calculate a new `B` column using **list comprehension**, then we'll use\n# vectorization for the rest.\ndf[&quot;B_new&quot;] = [\n    calculate_new_column_b_value(b_value) for b_value in df[&quot;B&quot;]\n]\n\n# Now we can use vectorization for the rest. &quot;Vectorization&quot; in this case\n# means to simply use the column series variables in equations directly,\n# without manually iterating over them. Pandas DataFrames will handle the\n# underlying iteration automatically for you. You just focus on the math.\ndf[&quot;val&quot;] = (\n    2 * df[&quot;A_i_minus_2&quot;]\n    + 3 * df[&quot;A_i_minus_1&quot;]\n    + 4 * df[&quot;A&quot;]\n    + 5 * df[&quot;A_i_plus_1&quot;]\n    + df[&quot;B_new&quot;]\n    + 7 * df[&quot;C&quot;]\n    - 8 * df[&quot;D&quot;]\n)\n</code></pre>\n</li>\n<li><p><strong>Technique 8:</strong> <code>8_pure_vectorization__with_df.loc[]_boolean_array_indexing_for_if_statment_corner_case</code></p>\n<p>This uses <strong>boolean indexing</strong>, AKA: a <strong>boolean mask</strong>, to accomplish the equivalent of the <code>if</code> statement in the equation. In this way, pure vectorization can be used for the entire equation, thereby maximizing performance and speed.</p>\n<pre class=\"lang-py prettyprint-override\"><code># If statement to evaluate:\n#\n#     if B &gt; 0:\n#         B_new = 6 * B\n#     else:\n#         B_new = 60 * B\n#\n# In this particular example, since we have an embedded `if-else` statement\n# for the `B` column, we can use some boolean array indexing through\n# `df.loc[]` for some pure vectorization magic.\n#\n# Explanation:\n#\n# Long:\n#\n# The format is: `df.loc[rows, columns]`, except in this case, the rows are\n# specified by a &quot;boolean array&quot; (AKA: a boolean expression, list of\n# booleans, or &quot;boolean mask&quot;), specifying all rows where `B` is &gt; 0. Then,\n# only in that `B` column for those rows, set the value accordingly. After\n# we do this for where `B` is &gt; 0, we do the same thing for where `B`\n# is &lt;= 0, except with the other equation.\n#\n# Short:\n#\n# For all rows where the boolean expression applies, set the column value\n# accordingly.\n#\n# GitHub CoPilot first showed me this `.loc[]` technique.\n# See also the official documentation:\n# https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html\n#\n# ===========================\n# 1st: handle the &gt; 0 case\n# ===========================\ndf[&quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &gt; 0, &quot;B&quot;] * 6\n#\n# ===========================\n# 2nd: handle the &lt;= 0 case, merging the results into the\n# previously-created &quot;B_new&quot; column\n# ===========================\n# - NB: this does NOT work; it overwrites and replaces the whole &quot;B_new&quot;\n#   column instead:\n#\n#       df[&quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &lt;= 0, &quot;B&quot;] * 60\n#\n# This works:\ndf.loc[df[&quot;B&quot;] &lt;= 0, &quot;B_new&quot;] = df.loc[df[&quot;B&quot;] &lt;= 0, &quot;B&quot;] * 60\n\n# Now use normal vectorization for the rest.\ndf[&quot;val&quot;] = (\n    2 * df[&quot;A_i_minus_2&quot;]\n    + 3 * df[&quot;A_i_minus_1&quot;]\n    + 4 * df[&quot;A&quot;]\n    + 5 * df[&quot;A_i_plus_1&quot;]\n    + df[&quot;B_new&quot;]\n    + 7 * df[&quot;C&quot;]\n    - 8 * df[&quot;D&quot;]\n)\n</code></pre>\n</li>\n<li><p><strong>Technique 9:</strong> <code>9_apply_function_with_lambda</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df[&quot;val&quot;] = df.apply(\n    lambda row: calculate_val(\n        row[&quot;A_i_minus_2&quot;],\n        row[&quot;A_i_minus_1&quot;],\n        row[&quot;A&quot;],\n        row[&quot;A_i_plus_1&quot;],\n        row[&quot;B&quot;],\n        row[&quot;C&quot;],\n        row[&quot;D&quot;]\n    ),\n    axis='columns' # same as `axis=1`: &quot;apply function to each row&quot;,\n                   # rather than to each column\n)\n</code></pre>\n</li>\n<li><p><strong>Technique 10:</strong> <code>10_list_comprehension_w_zip_and_direct_variable_assignment_passed_to_func</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df[&quot;val&quot;] = [\n    # Note: you *could* do the calculations directly here instead of using a\n    # function call, so long as you don't have indented code blocks such as\n    # sub-routines or multi-line if statements.\n    #\n    # I'm using a function call.\n    calculate_val(\n        A_i_minus_2,\n        A_i_minus_1,\n        A,\n        A_i_plus_1,\n        B,\n        C,\n        D\n    ) for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D\n    in zip(\n        df[&quot;A_i_minus_2&quot;],\n        df[&quot;A_i_minus_1&quot;],\n        df[&quot;A&quot;],\n        df[&quot;A_i_plus_1&quot;],\n        df[&quot;B&quot;],\n        df[&quot;C&quot;],\n        df[&quot;D&quot;]\n    )\n]\n</code></pre>\n</li>\n<li><p><strong>Technique 11:</strong> <code>11_list_comprehension_w_zip_and_direct_variable_assignment_calculated_in_place</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df[&quot;val&quot;] = [\n    2 * A_i_minus_2\n    + 3 * A_i_minus_1\n    + 4 * A\n    + 5 * A_i_plus_1\n    # Python ternary operator; don't forget parentheses around the entire\n    # ternary expression!\n    + ((6 * B) if B &gt; 0 else (60 * B))\n    + 7 * C\n    - 8 * D\n    for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D\n    in zip(\n        df[&quot;A_i_minus_2&quot;],\n        df[&quot;A_i_minus_1&quot;],\n        df[&quot;A&quot;],\n        df[&quot;A_i_plus_1&quot;],\n        df[&quot;B&quot;],\n        df[&quot;C&quot;],\n        df[&quot;D&quot;]\n    )\n]\n</code></pre>\n</li>\n<li><p><strong>Technique 12:</strong> <code>12_list_comprehension_w_zip_and_row_tuple_passed_to_func</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df[&quot;val&quot;] = [\n    calculate_val(\n        row[0],\n        row[1],\n        row[2],\n        row[3],\n        row[4],\n        row[5],\n        row[6],\n    ) for row\n    in zip(\n        df[&quot;A_i_minus_2&quot;],\n        df[&quot;A_i_minus_1&quot;],\n        df[&quot;A&quot;],\n        df[&quot;A_i_plus_1&quot;],\n        df[&quot;B&quot;],\n        df[&quot;C&quot;],\n        df[&quot;D&quot;]\n    )\n]\n</code></pre>\n</li>\n<li><p><strong>Technique 13:</strong> <code>13_list_comprehension_w__to_numpy__and_direct_variable_assignment_passed_to_func</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df[&quot;val&quot;] = [\n    # Note: you *could* do the calculations directly here instead of using a\n    # function call, so long as you don't have indented code blocks such as\n    # sub-routines or multi-line if statements.\n    #\n    # I'm using a function call.\n    calculate_val(\n        A_i_minus_2,\n        A_i_minus_1,\n        A,\n        A_i_plus_1,\n        B,\n        C,\n        D\n    ) for A_i_minus_2, A_i_minus_1, A, A_i_plus_1, B, C, D\n        # Note: this `[[...]]` double-bracket indexing is used to select a\n        # subset of columns from the dataframe. The inner `[]` brackets\n        # create a list from the column names within them, and the outer\n        # `[]` brackets accept this list to index into the dataframe and\n        # select just this list of columns, in that order.\n        # - See the official documentation on it here:\n        #   https://pandas.pydata.org/docs/user_guide/indexing.html#basics\n        #   - Search for the phrase &quot;You can pass a list of columns to [] to\n        #     select columns in that order.&quot;\n        #   - I learned this from this comment here:\n        #     https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#comment136020567_55557758\n        # - One of the **list comprehension** examples in this answer here\n        #   uses `.to_numpy()` like this:\n        #   https://stackoverflow.com/a/55557758/4561887\n    in df[[\n        &quot;A_i_minus_2&quot;,\n        &quot;A_i_minus_1&quot;,\n        &quot;A&quot;,\n        &quot;A_i_plus_1&quot;,\n        &quot;B&quot;,\n        &quot;C&quot;,\n        &quot;D&quot;\n    ]].to_numpy()  # NB: `.values` works here too, but is deprecated. See:\n                   # https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.values.html\n]\n</code></pre>\n</li>\n</ol>\n<p>Here are the results again:</p>\n<p><a href=\"https://i.sstatic.net/5biMy.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/5biMy.png\" alt=\"enter image description here\" /></a></p>\n<h2>Using the pre-shifted rows in the 4 <code>for</code> loop techniques as well</h2>\n<p>I wanted to see if removing this <code>if</code> check and using the pre-shifted rows in the 4 <code>for</code> loop techniques would have much effect:</p>\n<pre class=\"lang-py prettyprint-override\"><code>if i &lt; 2 or i &gt; len(df)-2:\n    continue\n</code></pre>\n<p>...so I created this file with those modifications: <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests_mod.py\" rel=\"nofollow noreferrer\"><code>pandas_dataframe_iteration_vs_vectorization_vs_list_comprehension_speed_tests_mod.py</code></a>. Search the file for &quot;MOD:&quot; to find the 4 new, modified techniques.</p>\n<p>It had only a slight improvement. Here are the results of these 17 techniques now, with the 4 new ones having the word <code>_MOD_</code> near the beginning of their name, just after their number. This is over 500k rows this time, not 2M:</p>\n<p><a href=\"https://i.sstatic.net/HxKkJ.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/HxKkJ.png\" alt=\"enter image description here\" /></a></p>\n<h2>More on <code>.iterrtuples()</code></h2>\n<p>There are actually more nuances when using <code>.itertuples()</code>. To delve into some of those, read <a href=\"https://stackoverflow.com/a/59413206/4561887\">this answer by @Romain Capron</a>. Here is a bar chart plot I made of his results:</p>\n<p><a href=\"https://i.sstatic.net/ws9db.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/ws9db.png\" alt=\"enter image description here\" /></a></p>\n<p>My plotting code for his results is in <strong><a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/python/pandas_plot_bar_chart_better_GREAT_AUTOLABEL_DATA.py\" rel=\"nofollow noreferrer\"><code>python/pandas_plot_bar_chart_better_GREAT_AUTOLABEL_DATA.py</code></a></strong> in my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo.</p>\n<h2>Future work</h2>\n<p>Using Cython (Python compiled into C code), or just raw C functions called by Python, could be faster potentially, but I'm not going to do that for these tests. I'd only look into and speed test those options for big optimizations.</p>\n<p>I currently don't know Cython and don't feel the need to learn it. As you can see above, simply using pure vectorization properly already runs incredibly fast, processing 2 <em>million</em> rows in only 0.1 seconds, or 20 million rows per second.</p>\n<h2>References</h2>\n<ol>\n<li>A bunch of the official Pandas documentation, especially the <code>DataFrame</code> documentation here: <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/frame.html\" rel=\"nofollow noreferrer\">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html</a>.</li>\n<li><a href=\"https://stackoverflow.com/a/55557758/4561887\">This excellent answer by @cs95</a> - this is where I learned in particular how to use list comprehension to iterate over a DataFrame.</li>\n<li><a href=\"https://stackoverflow.com/a/59413206/4561887\">This answer about <code>itertuples()</code>, by @Romain Capron</a> - I studied it carefully and edited/formatted it.</li>\n</ol>\n<h2>See also</h2>\n<ol>\n<li><p>This answer is also posted on my personal website here: <a href=\"https://gabrielstaples.com/python_iterate_over_pandas_dataframe/\" rel=\"nofollow noreferrer\">https://gabrielstaples.com/python_iterate_over_pandas_dataframe/</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Array_programming\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Array_programming</a> - array programming, or &quot;vectorization&quot;:</p>\n<blockquote>\n<p>In computer science, array programming refers to solutions that allow the application of operations to an entire set of values at once. Such solutions are commonly used in scientific and engineering settings.</p>\n<p>Modern programming languages that support array programming (also known as vector or multidimensional languages) have been engineered specifically to generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays. These include APL, J, Fortran, MATLAB, Analytica, Octave, R, Cilk Plus, Julia, Perl Data Language (PDL). In these languages, an operation that operates on entire arrays can be called a vectorized operation,<a href=\"https://i.sstatic.net/5biMy.png\" rel=\"nofollow noreferrer\">1</a> regardless of whether it is executed on a vector processor, which implements vector instructions.</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://stackoverflow.com/q/54028199/4561887\">Are for-loops in pandas really bad? When should I care?</a></p>\n<ol>\n<li><a href=\"https://stackoverflow.com/a/77270403/4561887\">my answer</a></li>\n</ol>\n</li>\n<li><p><a href=\"https://stackoverflow.com/q/24870953/4561887\">Does pandas iterrows have performance issues?</a></p>\n<ol>\n<li><a href=\"https://stackoverflow.com/a/24871316/4561887\">This answer</a>\n<ol>\n<li><p><a href=\"https://stackoverflow.com/questions/24870953/does-pandas-iterrows-have-performance-issues#comment136223122_24871316\">My comment underneath it</a>:</p>\n<blockquote>\n<p>...Based on my results, I'd say, however, these are the best approaches, in this order of best first:</p>\n<ol>\n<li>vectorization,</li>\n<li>list comprehension,</li>\n<li><code>.itertuples()</code>,</li>\n<li><code>.apply()</code>,</li>\n<li>raw <code>for</code> loop,</li>\n<li><code>.iterrows().</code></li>\n</ol>\n<p>I didn't test Cython.</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n", "tags": ["python", "pandas", "dataframe", "loops"]}
{"id": "da8620ef-8905-44de-a725-5e5d8d8fb485", "text": "Q: Problem when apply Lineload in Plaxis 2D from Python A: <ul>\n<li>In PLAXIS Remote Scripting, creation commands like <code>g_i.line(...)</code> / <code>g_i.lineload(...)</code> usually return a 1-element tuple/list of created objects. You\u2019re appending that container, so <code>load</code> is not the load object (and <code>.qy_start</code> fails). Unpack (or index <code>[0]</code>) and also cast pandas/numpy numbers to plain <code>float</code>.</li>\n</ul>\n<pre><code>import pandas as pd\n\nLL_RD = []\nLoad_RD_NB = []\n\nfor i in range(12):\n    (ln,) = g_i.line(point_I[i], point_I[i + 1])     # unpack\n    (ll,) = g_i.lineload(ln)                         # unpack\n    LL_RD.append(ln)\n    Load_RD_NB.append(ll)\n\nLoads = pd.read_excel(&quot;Loads_RD.xlsx&quot;, sheet_name=&quot;RD&quot;)\nLoads[&quot;ELU 1&quot;] = Loads[&quot;ELU 1&quot;].astype(str).str.replace(&quot;,&quot;, &quot;.&quot;).astype(float)\n\n# make sure 'phase' is a real Phase object, e.g.:\n# phase = g_i.Phases[1]\n\nn = min(len(Load_RD_NB), len(Loads))\n\nfor i in range(n):\n    ll = Load_RD_NB[i]\n    v = float(Loads.loc[i, &quot;ELU 1&quot;])   # ensure plain float\n    ll.activate(phase)                 # optional but often required\n    ll.qy_start.set(phase, -v)\n    ll.qy_end.set(phase, -v)\n</code></pre>\n<ul>\n<li>If it still errors, print the types to confirm you\u2019re not storing containers:</li>\n</ul>\n<pre><code>print(type(Load_RD_NB[0]), Load_RD_NB[0])\nprint(type(phase), phase)\n</code></pre>\n", "tags": ["python"]}
