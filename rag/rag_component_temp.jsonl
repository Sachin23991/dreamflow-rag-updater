{"id": "44bcb36b-7aaf-4821-aea0-bb7084bf7b96", "text": "Q: Github Railway: &quot;Successfull deploy&quot; - But where is my API? A: <p>I Figured it out after all.<br />\nIt turns out that I just had to navigate to the project in Railway =&gt; Settings =&gt; Networking =&gt; Public Networking =&gt; Custom Domain.</p>\n<p>That generated the actual base url for the REST API together with the Port number.<br />\nFrom there I was able to move forward.</p>\n", "tags": [".net", "docker", "rest", "railway"]}
{"id": "539d4543-0006-419b-ba8c-905bc1cb93d7", "text": "Q: Fetching Microsoft Teams meetings details/metadata A: <p>Could you please try using Call Records API instead of OnlineMeeting API? From your transcript notification you get <code>callId</code> (or can derive it from the notification payload), then Query the Call Records endpoint <code>GET /communications/callRecords/{callId}</code>. Use <code>startDateTime</code> from the call record. The call record represents the actual occurrence, even for recurring meetings.</p>\n", "tags": ["outlook", "microsoft-graph-api", "microsoft-teams"]}
{"id": "b0f47645-a2ed-4c2f-886a-4635d5bd43aa", "text": "Q: I get an error in my Azure Functions project in a public class. Changing to a static class is not working A: <p>Don't see any reason to make the <code>VerifyDisplayname</code> as extension method in your <code>NewFunction</code>.</p>\n<p>Remove <code>this</code> so that the <code>VerifyDisplayname</code> is not recognized as the extension method.</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public static string VerifyDisplayname(string text)\n</code></pre>\n<p>Otherwise, create a static class <code>StringExtensions</code> and move the <code>VerifyDisplayname</code> in the <code>StringExtensions</code> class.</p>\n<pre class=\"lang-cs prettyprint-override\"><code>public static class StringExtensions\n{\n    public static string VerifyDisplayname(this string text)\n    {\n        // Implementation of `VerifyDisplayname` extension method\n    }\n}\n</code></pre>\n", "tags": ["c#", "azure-functions"]}
{"id": "77de28b9-df94-43cd-a0db-0c1a73b97182", "text": "Q: Do I need atomic transactions or is eventual consistency enough? A: <p>The main question is what you mean by &quot;eventually consistent&quot;.   For example, is it acceptable for a withdrawal from account A to be recorded, but for there to be a ten year delay (in which the funds are in some form of limbo) before the corresponding deposit to account B is recorded?   Since there is a lot that could happen in that delay period (the bank going out of business, account B being closed, the owner of account B going bankrupt, etc) such a long time of inconsistency is usually considered unacceptable.</p>\n<p>Transactional semantics are about ensuring that, if (say) the deposit to account B fails or is delayed unacceptably, the end result (apart from records of failed attempts) is as if no withdrawal from account A has occurred and no deposit to account B has occurred.   In other words, the transfer succeeds in total or it fails - there is no &quot;intermediate&quot; or &quot;inconsistent&quot; outcome.</p>\n", "tags": ["c++", "architecture", "software-design"]}
