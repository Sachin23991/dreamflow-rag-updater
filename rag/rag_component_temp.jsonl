{"id": "e5b737cf-45d5-42be-8b29-62844d8a2af9", "text": "Q: Actually, why bash array variables require curly braces? A: <blockquote>\n<p>Are there situations where <strong>$something[1]</strong> means something other than accessing an array element?</p>\n</blockquote>\n<p>Yes.  In <em>every</em> situation in which it appears in a Bash script, it means something other than an array element access.  Where parameter expansion does not apply, the <code>$something</code> part is literal. Where parameter expansion does apply, that part means an ordinary reference to variable <code>something</code>.  If <code>something</code>'s value is an array, then <code>$something</code> is equivalent to <code>${something[0]}</code>.  The significance of the following <code>[1]</code> and of the overall construct depend on the larger context in which they appear.  For instance, <code>[1]</code> is equivalent to <code>1</code> for the purposes of pathname expansion.</p>\n<blockquote>\n<p>When I see <strong>$something[1]</strong> in a bash script, I cannot think for this having any other usage than just accessing an array element.</p>\n</blockquote>\n<p>I think you're saying that array element access is your (incorrect) intuition for what that syntax would mean.  Sorry. There's nothing I can do about your instincts, but I anticipate that if you keep writing Bash scripts then you'll become more comfortable with it.</p>\n<blockquote>\n<p>why isn't the logic in the bash parser inverted to treat by default <strong>$something[1]</strong> as <strong>${something[1]}</strong> ?</p>\n</blockquote>\n<p>For one thing, because Bash aims at being more or less compatible with the POSIX shell specifications. POSIX does not specify any array support, and there are POSIX-compatible shells that do not have any.  For any of these shells, <code>$something[1]</code> <em>cannot</em> be an array element reference (and <code>${something[1]}</code> can't be one either).  For compatibility, then, <code>$something[1]</code> shouldn't be an array element reference in Bash, either.  It's not a POSIX-compatibility issue for Bash to recognize <code>${something[1]}</code> because POSIX does not define a meaning for it at all.</p>\n<p>The POSIX shell uses the curly-brace style for a couple of purposes, but the overarching theme is that the <code>{}</code> in a parameter reference serve a grouping function.  The text within is what is to be expanded, whether as an ordinary parameter reference, one of the forms of augmented or special parameter reference, or, in Bash, an array-element reference.</p>\n<blockquote>\n<p>For example, bash arithmetic expressions do not require curly braces</p>\n</blockquote>\n<p>They don't require <code>$</code>, either. Arithmetic evaluation is not parameter expansion, and it provides for accessing the values of variables without using parameter expansion.  If that makes you uncomfortable, then you can use parameter expansion inside arithmetic expressions to maintain consistency.</p>\n", "tags": ["bash"]}
{"id": "bdf7c348-ca45-4869-8693-8de2230ac7b6", "text": "Q: Syntax match issue with lookahead (regex \\@=) A: <p>The issue is not syntax highlighting the regex itself does not do what you expect.</p>\n<p>In Vim regex, <code>\\@=</code> is a zero-width lookahead: it checks that a pattern follows, but it does not advance the start of the match. So in:</p>\n<pre><code>(\\+\\s)\\@=\\w+\n</code></pre>\n<p>the match still starts at <code>+</code>, because <code>\\@=</code> only adds a condition and does not move the match position. As a result, <code>+</code> is part of the actual match and gets highlighted.</p>\n<p>To exclude the <code>+ </code>from the match, you must explicitly move the match start using <code>\\zs</code>:</p>\n<pre><code>(\\+\\s)\\zs\\w+\n</code></pre>\n<p>Here, <code>\\zs</code> tells Vim where the match should begin, so only <code>\\w+</code> is matched and highlighted.</p>\n", "tags": ["vim", "syntax", "match"]}
{"id": "85f8d452-fb39-4ce6-93e9-09b7d5ec8b12", "text": "Q: Is there any way to create/extract an array of Views using @ViewBuilder in SwiftUI A: <p>It's possible via @resultBuilder.</p>\n<h2>ResultBuilder.swift</h2>\n<pre><code>@resultBuilder struct ViewBuilderArray&lt;T&gt; {\n\n    static func buildBlock(_ components: T...) -&gt; [T] {\n        components\n    }\n\n}\n</code></pre>\n<h2>Array.swift</h2>\n<pre><code>extension Array {\n\n    subscript(safe index: Int) -&gt; Element? {\n        indices.contains(index) ? self[index] : nil\n    }\n\n}\n</code></pre>\n<h2>app.swift</h2>\n<pre><code>import SwiftUI\n\n@main struct ThisApp: App {\n\n    var body: some Scene {\n        WindowGroup {\n            ParentContainer {\n                ChildContainer(title: &quot;Child 1&quot;) { Text(&quot;Child 1 AnyView content&quot;) }\n                ChildContainer(title: &quot;Child 2&quot;) { Text(&quot;Child 2 AnyView content&quot;) }\n                ChildContainer(title: &quot;Child 3&quot;) { Text(&quot;Child 3 AnyView content&quot;) }\n            }.padding(20)\n        }\n    }\n\n}\n</code></pre>\n<h2>ParentContainer.swift</h2>\n<pre><code>import SwiftUI\n\nstruct ParentContainer: View {\n\n    private let contents: [ChildContainer]\n\n    init(@ViewBuilderArray&lt;ChildContainer&gt; content: () -&gt; [ChildContainer]) {\n        self.contents = content()\n    }\n\n    public var body: some View {\n        VStack {\n            ForEach(0 ..&lt; self.contents.count, id: \\.self) { index in\n                if let child = self.contents[safe: index] {\n                    Text(child.title).font(.headline)\n                    child\n                }\n            }\n        }\n    }\n\n}\n</code></pre>\n<h2>ChildContainer.swift</h2>\n<pre><code>import SwiftUI\n\nstruct ChildContainer: View {\n\n    var title: String\n    var view: any View\n\n    init(\n        title: String,\n        @ViewBuilder view: () -&gt; any View\n    ) {\n        self.title = title\n        self.view = view()\n    }\n\n    public var body: some View {\n        AnyView(self.view)\n    }\n\n}\n</code></pre>\n", "tags": ["ios", "arrays", "swift", "swiftui", "viewbuilder"]}
{"id": "a0787e14-9d34-4d41-b09a-775abfbf9ad5", "text": "Q: Multiple email validate error in if I used number A: <p>You can substitute <code>RegExp</code> for using <code>.checkValidity()</code> at hidden <code>&lt;input type=\"email\"&gt;</code> element to check each email separated by space at <code>textarea</code> element with <code>Array.prototype.every()</code> callback. If each email returns <code>true</code> at <code>.checkValidity()</code> following setting <code>.val()</code> to split text, call <code>alert()</code> with parameter <code>\"email validate\"</code>, else with parameter <code>\"email not validate\"</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$(\"#testEmailIDs\").blur(function() { \r\n  alert(\"email \" + (!this.value.split(/\\s+/).every(function(val) {\r\n    return $(\"input[hidden]\").val(val)[0].checkValidity()\r\n  }) ? \"not \" : \"\") + \"validate\")\r\n})</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js\"&gt;\r\n&lt;/script&gt;\r\n&lt;input type=\"email\" hidden /&gt;\r\n&lt;textarea id=\"testEmailIDs\"&gt;&lt;/textarea&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n", "tags": ["javascript", "jquery", "email"]}
{"id": "c92aadb6-42df-4a1b-a512-bba7b0fc8889", "text": "Q: Webpack-dev-server &quot;Cannot GET /&quot; A: <p>This answer was originally posted into the question by <a href=\"https://stackoverflow.com/users/15661641/phpet\">phpet</a></p>\n<hr />\n<p>If anyone will face the same issue:</p>\n<p>&quot;webpack-dev-server&quot; is since 5.0 (or so) no longer supported. You have to change it to</p>\n<p>&quot;start&quot;: &quot;webpack serve&quot;,</p>\n<p>Moreover, here my webpack-config.js file changes, which did the trick:</p>\n<pre><code>    const path = require('path');\n     \n    module.exports = {\n        mode: 'development',\n        entry: './src/app.ts',\n        output: {\n            filename: 'bundle.js',\n            path: path.resolve(__dirname, 'dist'),\n            publicPath: '/dist/',\n        },\n        devServer: {\n            static: {\n                directory: path.join(__dirname, '/')\n            }\n        },\n       .\n       .\n       .\n};\n</code></pre>\n", "tags": ["javascript", "node.js", "json", "typescript", "webpack"]}
{"id": "2c9327b2-4bb8-4396-80e7-88719889e0d8", "text": "Q: Error in from torch.utils.data import utils A: <p>Maybe the official documentation <a href=\"https://pytorch.org/data/beta/index.html\" rel=\"nofollow noreferrer\">torchdata.datapipes</a> could guide on solving these issues. Or in the worst, try to tun <code>pip list</code> to see all environments and packages altogether.</p>\n", "tags": ["python", "python-3.7"]}
