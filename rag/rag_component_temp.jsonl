{"id": "237a6e18-407a-4437-8f36-d958a598f70f", "text": "Q: Why GitHub use SharedWorker for WebSocket A: <p>Usually, you create a WebSocket connection within a SharedWorker when you want multiple tabs or windows of the same browser instance to be able to share that connection. So, if you open multiple tabs on the same site (in this case, GitHub), one single WebSocket connection will be enough for them all.</p>\n", "tags": ["sockets", "github", "websocket", "worker", "shared-worker"]}
{"id": "eba8bc08-9417-47ba-8ead-ed80a6d97870", "text": "Q: How to identify specific digits of an integer input in C? A: <p>This is recursive.  Short and simple. If you have a number, use digit_count() if a char* (string) use char_count().</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint digit_count(int n, int d) { \n   if (n == 0) return 0;\n   return (n%10 == d) ? 1:0) + digit_count(n/10,d);\n}\n \nint char_count(const char *s,char c) {\n    if (*s == '\\0') return 0;\n    return ((*s == c) ? 1:0) + char_count(s+1, c);\n}\n\nint main() {\n   int w = 1345146103; \n   char *str = &quot;Hello there 1 time, I will say it 1 time we are 121 people&quot;;\n\n   printf (&quot;There are %d ones in %d\\n&quot;,digit_count(w,1),w);\n   printf (&quot;There are %d ones in \\n'%s'\\n&quot;,char_count(str,'1'),str); \n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ ./test\nThere are 3 ones in 1345146103\nThere are 4 ones in \n'Hello there 1 time, I will say it 1 time we are 121 people'\n</code></pre>\n", "tags": ["c", "string", "function"]}
{"id": "11e408fb-9491-49e4-9109-8ce49107d2f0", "text": "Q: How can I grep recursively, but only in files with certain extensions? A: <p><a href=\"https://stackoverflow.com/a/12517022/241211\">Nelson's answer</a> is good:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>grep -r -i --include \\*.h --include \\*.cpp CP_Image ~/path[12345] |\n    mailx -s GREP email@domain.example\n</code></pre>\n<p>But it can be simplified to:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>grep -r -i --include=\\*.{h,cpp} CP_Image ~/path[12345] |\n    mailx -s GREP email@domain.example\n</code></pre>\n", "tags": ["grep"]}
{"id": "9ce55ccd-ea4e-47e9-ac28-6a1eccbb8b4c", "text": "Q: How to verify webhook signatures from multiple providers (Stripe, GitHub, Shopify, etc.) in Go? A: <p>Handling webhook signature verification across multiple providers is indeed complex because each provider implements their own scheme. Here's a comprehensive solution that addresses the key challenges:</p>\n<h3>Core Verification Function</h3>\n<pre class=\"lang-golang prettyprint-override\"><code>package webhook\n\nimport (\n    &quot;crypto/hmac&quot;\n    &quot;crypto/sha1&quot;\n    &quot;crypto/sha256&quot;\n    &quot;crypto/sha512&quot;\n    &quot;encoding/base64&quot;\n    &quot;encoding/hex&quot;\n    &quot;errors&quot;\n    &quot;fmt&quot;\n    &quot;strconv&quot;\n    &quot;strings&quot;\n    &quot;time&quot;\n)\n\n// VerifySignature verifies webhook signature based on provider type\nfunc VerifySignature(provider string, body []byte, headers map[string]string, secret string, url string) error {\n    if secret == &quot;&quot; {\n        return errors.New(&quot;webhook secret not configured&quot;)\n    }\n\n    switch provider {\n    case &quot;stripe&quot;:\n        return verifyStripeSignature(body, headers, secret)\n    case &quot;github&quot;:\n        return verifyGitHubSignature(body, headers, secret)\n    case &quot;shopify&quot;:\n        return verifyShopifySignature(body, headers, secret)\n    case &quot;twilio&quot;:\n        if url == &quot;&quot; {\n            return errors.New(&quot;URL required for Twilio signature verification&quot;)\n        }\n        return verifyTwilioSignature(body, headers, secret, url)\n    case &quot;slack&quot;:\n        return verifySlackSignature(body, headers, secret)\n    default:\n        return fmt.Errorf(&quot;unsupported provider: %s&quot;, provider)\n    }\n}\n\n// Helper to safely get header value (case-insensitive)\nfunc getHeader(headers map[string]string, key string) string {\n    for k, v := range headers {\n        if strings.EqualFold(k, key) {\n            return v\n        }\n    }\n    return &quot;&quot;\n}\n</code></pre>\n<h3>Provider-Specific Implementations</h3>\n<h4>Stripe</h4>\n<pre class=\"lang-golang prettyprint-override\"><code>// Stripe: Stripe-Signature header\n// Format: t=timestamp,v1=signature\n// Verification: HMAC-SHA256(timestamp + &quot;.&quot; + body, secret)\nfunc verifyStripeSignature(body []byte, headers map[string]string, secret string) error {\n    sigHeader := getHeader(headers, &quot;Stripe-Signature&quot;)\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing Stripe-Signature header&quot;)\n    }\n\n    // Parse timestamp and signature\n    var timestamp, signature string\n    parts := strings.Split(sigHeader, &quot;,&quot;)\n    for _, part := range parts {\n        part = strings.TrimSpace(part)\n        if strings.HasPrefix(part, &quot;t=&quot;) {\n            timestamp = part[2:]\n        } else if strings.HasPrefix(part, &quot;v1=&quot;) {\n            signature = part[3:]\n        }\n    }\n\n    if timestamp == &quot;&quot; || signature == &quot;&quot; {\n        return errors.New(&quot;invalid Stripe signature format&quot;)\n    }\n\n    // Verify timestamp (prevent replay attacks)\n    ts, err := strconv.ParseInt(timestamp, 10, 64)\n    if err != nil {\n        return errors.New(&quot;invalid timestamp&quot;)\n    }\n    if time.Now().Unix()-ts &gt; 300 { // 5 minutes\n        return errors.New(&quot;signature timestamp too old&quot;)\n    }\n\n    // Compute expected signature\n    payload := fmt.Sprintf(&quot;%s.%s&quot;, timestamp, string(body))\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write([]byte(payload))\n    expectedSig := hex.EncodeToString(mac.Sum(nil))\n\n    // Constant-time comparison\n    if !hmac.Equal([]byte(signature), []byte(expectedSig)) {\n        return errors.New(&quot;invalid Stripe signature&quot;)\n    }\n\n    return nil\n}\n</code></pre>\n<h4>GitHub</h4>\n<pre class=\"lang-golang prettyprint-override\"><code>// GitHub: X-Hub-Signature-256 header\n// Format: sha256=hexdigest\n// Verification: HMAC-SHA256(body, secret)\nfunc verifyGitHubSignature(body []byte, headers map[string]string, secret string) error {\n    sigHeader := getHeader(headers, &quot;X-Hub-Signature-256&quot;)\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Hub-Signature-256 header&quot;)\n    }\n\n    // Extract signature (remove &quot;sha256=&quot; prefix)\n    signature := strings.TrimPrefix(sigHeader, &quot;sha256=&quot;)\n\n    // Compute expected signature\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write(body)\n    expectedSig := hex.EncodeToString(mac.Sum(nil))\n\n    // Constant-time comparison\n    if !hmac.Equal([]byte(signature), []byte(expectedSig)) {\n        return errors.New(&quot;invalid GitHub signature&quot;)\n    }\n\n    return nil\n}\n</code></pre>\n<h4>Shopify</h4>\n<pre class=\"lang-golang prettyprint-override\"><code>// Shopify: X-Shopify-Hmac-Sha256 header\n// Format: Base64-encoded HMAC-SHA256\n// Verification: Base64(HMAC-SHA256(body, secret))\nfunc verifyShopifySignature(body []byte, headers map[string]string, secret string) error {\n    sigHeader := getHeader(headers, &quot;X-Shopify-Hmac-Sha256&quot;)\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Shopify-Hmac-Sha256 header&quot;)\n    }\n\n    // Decode base64 signature\n    receivedSig, err := base64.StdEncoding.DecodeString(sigHeader)\n    if err != nil {\n        return fmt.Errorf(&quot;invalid base64 signature: %w&quot;, err)\n    }\n\n    // Compute expected signature\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write(body)\n    expectedSig := mac.Sum(nil)\n\n    // Constant-time comparison\n    if !hmac.Equal(receivedSig, expectedSig) {\n        return errors.New(&quot;invalid Shopify signature&quot;)\n    }\n\n    return nil\n}\n</code></pre>\n<h4>Twilio</h4>\n<pre class=\"lang-golang prettyprint-override\"><code>// Twilio: X-Twilio-Signature header\n// Format: Base64-encoded HMAC-SHA1\n// Verification: Base64(HMAC-SHA1(full_url + body, auth_token))\n// Note: Requires the full URL including query parameters\nfunc verifyTwilioSignature(body []byte, headers map[string]string, secret string, fullURL string) error {\n    sigHeader := getHeader(headers, &quot;X-Twilio-Signature&quot;)\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Twilio-Signature header&quot;)\n    }\n\n    // Decode base64 signature\n    receivedSig, err := base64.StdEncoding.DecodeString(sigHeader)\n    if err != nil {\n        return fmt.Errorf(&quot;invalid base64 signature: %w&quot;, err)\n    }\n\n    // Compute expected signature: HMAC-SHA1(full_url + body, secret)\n    payload := fullURL + string(body)\n    mac := hmac.New(sha1.New, []byte(secret))\n    mac.Write([]byte(payload))\n    expectedSig := mac.Sum(nil)\n\n    // Constant-time comparison\n    if !hmac.Equal(receivedSig, expectedSig) {\n        return errors.New(&quot;invalid Twilio signature&quot;)\n    }\n\n    return nil\n}\n</code></pre>\n<h4>Slack</h4>\n<pre class=\"lang-golang prettyprint-override\"><code>// Slack: X-Slack-Signature and X-Slack-Request-Timestamp headers\n// Format: v0=hexdigest\n// Verification: HMAC-SHA256(&quot;v0:timestamp:body&quot;, secret)\n// Timestamp validation: must be within 5 minutes\nfunc verifySlackSignature(body []byte, headers map[string]string, secret string) error {\n    sigHeader := getHeader(headers, &quot;X-Slack-Signature&quot;)\n    timestampHeader := getHeader(headers, &quot;X-Slack-Request-Timestamp&quot;)\n\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Slack-Signature header&quot;)\n    }\n    if timestampHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Slack-Request-Timestamp header&quot;)\n    }\n\n    // Validate timestamp (prevent replay attacks)\n    timestamp, err := strconv.ParseInt(timestampHeader, 10, 64)\n    if err != nil {\n        return errors.New(&quot;invalid timestamp&quot;)\n    }\n    if abs(time.Now().Unix()-timestamp) &gt; 300 { // 5 minutes\n        return errors.New(&quot;request timestamp too old&quot;)\n    }\n\n    // Construct signature base: v0:timestamp:body\n    sigBase := fmt.Sprintf(&quot;v0:%s:%s&quot;, timestampHeader, string(body))\n\n    // Compute expected signature\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write([]byte(sigBase))\n    expectedSig := &quot;v0=&quot; + hex.EncodeToString(mac.Sum(nil))\n\n    // Constant-time comparison\n    if !hmac.Equal([]byte(sigHeader), []byte(expectedSig)) {\n        return errors.New(&quot;invalid Slack signature&quot;)\n    }\n\n    return nil\n}\n\nfunc abs(x int64) int64 {\n    if x &lt; 0 {\n        return -x\n    }\n    return x\n}\n</code></pre>\n<h3>Usage Example (Gin Framework)</h3>\n<pre class=\"lang-golang prettyprint-override\"><code>func webhookHandler(c *gin.Context) {\n    provider := c.Param(&quot;provider&quot;) // e.g., &quot;stripe&quot;, &quot;github&quot;\n    secret := getSecretForProvider(provider) // Your secret retrieval logic\n\n    // Read raw body\n    body, err := io.ReadAll(c.Request.Body)\n    if err != nil {\n        c.JSON(400, gin.H{&quot;error&quot;: &quot;failed to read body&quot;})\n        return\n    }\n\n    // Convert headers to map\n    headers := make(map[string]string)\n    for k, v := range c.Request.Header {\n        if len(v) &gt; 0 {\n            headers[k] = v[0]\n        }\n    }\n\n    // Get full URL for providers that need it (e.g., Twilio)\n    fullURL := c.Request.URL.String()\n    if c.Request.URL.Scheme == &quot;&quot; {\n        fullURL = c.Request.Host + fullURL\n    }\n\n    // Verify signature\n    if err := webhook.VerifySignature(provider, body, headers, secret, fullURL); err != nil {\n        c.JSON(401, gin.H{&quot;error&quot;: &quot;invalid signature&quot;, &quot;details&quot;: err.Error()})\n        return\n    }\n\n    // Process webhook\n    c.JSON(200, gin.H{&quot;status&quot;: &quot;ok&quot;})\n}\n</code></pre>\n<h3>Key Security Considerations</h3>\n<ol>\n<li><strong>Constant-time comparison</strong>: Always use <code>hmac.Equal()</code> instead of <code>==</code> to prevent timing attacks</li>\n<li><strong>Timestamp validation</strong>: For providers that include timestamps (Stripe, Slack), validate they're recent to prevent replay attacks</li>\n<li><strong>Raw body reading</strong>: Ensure you read the raw body before any JSON parsing, as some frameworks consume the body</li>\n<li><strong>Case-insensitive headers</strong>: Header names may vary in case, so use case-insensitive comparison</li>\n<li><strong>Error messages</strong>: Don't leak sensitive information in error messages</li>\n</ol>\n<h3>Common Pitfalls</h3>\n<ul>\n<li><strong>Body consumption</strong>: If your framework parses JSON automatically, the body may be consumed. Use middleware to preserve the raw body</li>\n<li><strong>URL reconstruction</strong>: Twilio requires the exact URL including query parameters. Ensure you reconstruct it correctly</li>\n<li><strong>Header case sensitivity</strong>: Some providers send headers in different cases. Always use case-insensitive lookup</li>\n<li><strong>Encoding</strong>: Pay attention to whether signatures are hex-encoded or base64-encoded</li>\n</ul>\n<h3>Advanced Example: ED25519 (Discord)</h3>\n<p>Some providers use public-key cryptography instead of HMAC. Here's Discord as an example:</p>\n<pre class=\"lang-golang prettyprint-override\"><code>import (\n    &quot;crypto/ed25519&quot;\n    &quot;encoding/hex&quot;\n)\n\n// Discord: X-Signature-Ed25519 header\n// Uses ED25519 public-key cryptography (not HMAC)\n// Verification: ed25519.Verify(public_key, timestamp + body, signature)\nfunc verifyDiscordSignature(body []byte, headers map[string]string, publicKey string) error {\n    sigHeader := getHeader(headers, &quot;X-Signature-Ed25519&quot;)\n    timestampHeader := getHeader(headers, &quot;X-Signature-Timestamp&quot;)\n\n    if sigHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Signature-Ed25519 header&quot;)\n    }\n    if timestampHeader == &quot;&quot; {\n        return errors.New(&quot;missing X-Signature-Timestamp header&quot;)\n    }\n\n    // Decode hex-encoded signature\n    signature, err := hex.DecodeString(sigHeader)\n    if err != nil {\n        return fmt.Errorf(&quot;invalid signature format: %w&quot;, err)\n    }\n\n    // Decode hex-encoded public key\n    pubKey, err := hex.DecodeString(publicKey)\n    if err != nil {\n        return fmt.Errorf(&quot;invalid public key format: %w&quot;, err)\n    }\n\n    // Construct message: timestamp + body\n    message := []byte(timestampHeader + string(body))\n\n    // Verify signature\n    if !ed25519.Verify(pubKey, message, signature) {\n        return errors.New(&quot;invalid Discord signature&quot;)\n    }\n\n    return nil\n}\n</code></pre>\n<h3>Testing Your Implementation</h3>\n<p>Here's how to test your verification functions:</p>\n<pre class=\"lang-golang prettyprint-override\"><code>func TestStripeSignature(t *testing.T) {\n    secret := &quot;whsec_test_secret&quot;\n    body := []byte(`{&quot;type&quot;:&quot;payment_intent.succeeded&quot;,&quot;data&quot;:{}}`)\n    timestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\n    // Compute valid signature\n    payload := fmt.Sprintf(&quot;%s.%s&quot;, timestamp, string(body))\n    mac := hmac.New(sha256.New, []byte(secret))\n    mac.Write([]byte(payload))\n    signature := hex.EncodeToString(mac.Sum(nil))\n\n    headers := map[string]string{\n        &quot;Stripe-Signature&quot;: fmt.Sprintf(&quot;t=%s,v1=%s&quot;, timestamp, signature),\n    }\n\n    err := verifyStripeSignature(body, headers, secret)\n    if err != nil {\n        t.Errorf(&quot;Valid signature failed: %v&quot;, err)\n    }\n\n    // Test invalid signature\n    headers[&quot;Stripe-Signature&quot;] = fmt.Sprintf(&quot;t=%s,v1=invalid&quot;, timestamp)\n    err = verifyStripeSignature(body, headers, secret)\n    if err == nil {\n        t.Error(&quot;Invalid signature should have failed&quot;)\n    }\n}\n</code></pre>\n<h3>Preserving Raw Body in Gin</h3>\n<p>Gin consumes the request body by default. To preserve it for signature verification:</p>\n<pre class=\"lang-golang prettyprint-override\"><code>// Middleware to preserve raw body\nfunc preserveBody() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if c.Request.Body != nil {\n            body, err := io.ReadAll(c.Request.Body)\n            if err != nil {\n                c.AbortWithStatusJSON(400, gin.H{&quot;error&quot;: &quot;failed to read body&quot;})\n                return\n            }\n            c.Request.Body = io.NopCloser(bytes.NewBuffer(body))\n            c.Set(&quot;rawBody&quot;, body)\n        }\n        c.Next()\n    }\n}\n\n// Usage\nrouter.Use(preserveBody())\nrouter.POST(&quot;/webhook/:provider&quot;, webhookHandler)\n\n// In handler\nfunc webhookHandler(c *gin.Context) {\n    body, _ := c.Get(&quot;rawBody&quot;)\n    bodyBytes := body.([]byte)\n    // Now use bodyBytes for verification\n}\n</code></pre>\n<h3>Alternative: Managed Webhook Service</h3>\n<p>If you're handling many providers or want to offload this complexity, consider using a managed webhook service like <a href=\"https://volleyhooks.com\" rel=\"nofollow noreferrer\">Volley</a> that handles signature verification, retries, and webhook routing for 40+ providers out of the box. This can significantly reduce maintenance overhead, especially as you add more providers.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://stripe.com/docs/webhooks/signatures\" rel=\"nofollow noreferrer\">Stripe Webhook Security</a></li>\n<li><a href=\"https://docs.github.com/en/webhooks/using-webhooks/securing-your-webhooks\" rel=\"nofollow noreferrer\">GitHub Webhook Security</a></li>\n<li><a href=\"https://owasp.org/www-community/vulnerabilities/Insufficient_Webhook_Security\" rel=\"nofollow noreferrer\">OWASP Webhook Security Guide</a></li>\n</ul>\n", "tags": ["go", "security", "stripe-payments", "webhooks", "hmac"]}
{"id": "68b9bf6a-2e99-4511-a01a-e943cced5062", "text": "Q: SSL Localhost Privacy error A: <p><em>Chromium Version 79 through (at least) Version 143</em></p>\n<h1>Allow Insecure SSL (localhost)</h1>\n<p>In Chrome\n<em>enable <strong>allow insecure localhost</strong> at this url:</em></p>\n<blockquote>\n<p><code>chrome://flags/#allow-insecure-localhost</code></p>\n</blockquote>\n<p><a href=\"https://i.sstatic.net/DNYWM.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/DNYWM.png\" alt=\"allow insecure localhost in chrome settings\" /></a></p>\n<p>Refer to <a href=\"https://stackoverflow.com/questions/7580508/getting-chrome-to-accept-self-signed-localhost-certificate\">this Stack Overflow</a> for more information.</p>\n<hr />\n<h1>Allow Insecure SSL (other)</h1>\n<p>As <a href=\"https://stackoverflow.com/a/64619852\">mentioned</a> by <a href=\"https://stackoverflow.com/users/404577/arda-basoglu\">Arda Basoglu</a>:</p>\n<ol>\n<li>See <em>&quot;Your connection is not private.</em> <em>blah-bla-blah</em>&quot;...</li>\n<li>Type <code>thisisunsafe</code> <em>(key listeners pick it up)</em>.</li>\n</ol>\n<hr />\n<h2>Notes</h2>\n<p><em>If you are just curious if this works, browse <a href=\"https://untrusted-root.badssl.com/\" rel=\"nofollow noreferrer\">this site</a> which has a bad root ssl certificate. Other &quot;bad ssl&quot; sites can be found using <a href=\"https://badssl.com\" rel=\"nofollow noreferrer\">badssl.com</a>.</em></p>\n<p><a href=\"https://stackoverflow.com/questions/35274659/when-you-use-badidea-or-thisisunsafe-to-bypass-a-chrome-certificate-hsts-err#answer-35275060\">More</a> about the <a href=\"https://chromium.googlesource.com/chromium/src/+/master/components/security_interstitials/core/browser/resources/interstitial_large.js\" rel=\"nofollow noreferrer\">chromium &quot;override keyword&quot;</a>:.</p>\n<blockquote>\n<p>This is specific for each site.<br />\n<br />\nThe chrome developers also do change this periodically.<br />\n<br />\nSince Version 79 the <code>BYPASS_SEQUENCE</code> is and has been <code>dGhpc2lzdW5zYWZl</code> (base64 encoding for &quot;thisisunsafe&quot;).</p>\n</blockquote>\n", "tags": ["google-chrome", "ssl", "localhost", "wamp", "self-signed"]}
{"id": "6b6c0796-f93b-4764-b5e6-cc6a74e8cb47", "text": "Q: Render quarto document using the plumber2 R package A: <p>The document is <a href=\"https://tidyverse.org/blog/2025/09/plumber2-0-1-0/#serving-quarto-and-rmarkdown-documents\" rel=\"nofollow noreferrer\">cached</a> likely for speed.</p>\n<p><strong>1.</strong> You can adapt the solution from <a href=\"https://github.com/ekholme/gcp_quarto_api\" rel=\"nofollow noreferrer\">here</a> to re-render the quarto each time, but it is slow. This creates a temporary html file, writes the quarto to it and returns the HTML. When the function exits, the temporary file is unlinked.</p>\n<pre class=\"lang-r prettyprint-override\"><code>#* Render time quarto report\n#* @serializer html\n#* @get /report\n\\() {\n  tmp &lt;- paste0(sample(c(letters, 0:9), 16, replace = TRUE), collapse = &quot;&quot;)\n  tmp &lt;- paste0(tmp, &quot;.html&quot;)\n  on.exit(unlink(tmp), add = TRUE)\n  quarto::quarto_render(&quot;time.qmd&quot;, output_file = tmp)\n  paste(readLines(tmp, warn = FALSE), collapse = &quot;\\n&quot;)\n}\n</code></pre>\n<p><strong>2.</strong> If you just want to show the time within the quarto document, why not use <a href=\"https://stackoverflow.com/a/30245911/28479453\">Javascript</a> to obtain it on runtime, this way we don't need to re-render the entire document each time you hit the endpoint.</p>\n<p><strong>time.qmd</strong></p>\n<pre><code>---\ntitle: &quot;time&quot;\nformat: html\n---\n\n```{r, echo=F}\n\nlibrary(htmltools)\n\nbrowsable(\n  tagList(\n    div(id = 'myDiv'),\n    tags$script(HTML(&quot;\n      setInterval(function() {\n        var currentdate = new Date(); \n        var datetime = currentdate.toLocaleString();\n        document.getElementById('myDiv').innerHTML = datetime;\n      }, 1000);\n    &quot;))\n  )\n)\n```\n</code></pre>\n<p><code>setInterval</code> updates the time every second, you can also omit that and just show it once when the document is opened.</p>\n<p><a href=\"https://i.sstatic.net/fzNlKs86.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/fzNlKs86.png\" alt=\"res\" /></a></p>\n<hr />\n<p><strong>Notes:</strong> For debugging this <a href=\"https://www.rdocumentation.org/packages/plumber2/versions/0.1.0/topics/api_logger\" rel=\"nofollow noreferrer\"><code>api_logger</code></a> is very useful</p>\n<pre><code>api(&quot;api.R&quot;) |&gt; api_logger(logger_console()) |&gt; api_run(port = 8002)\n</code></pre>\n", "tags": ["r", "plumber"]}
