{"id": "c7872de0-4298-42d3-9467-5e97adeea001", "text": "Q: ggplot2 facet: show all other groups in grey behind each panel A: <p>I've found a solution thanks to @markus here: <a href=\"https://stackoverflow.com/questions/56517146/add-other-series-to-panel-facet-plot-using-ggplot2\">Add other series to panel/facet plot using ggplot2</a></p>\n<p>Here the plot from the example I gave:</p>\n<pre class=\"lang-r prettyprint-override\"><code>ggplot( data = df_example,aes(x = a, y = b)) +  \n  geom_point(aes(group=c),#point to have gray dots in every panel\n             size=4, stroke = 1,\n             colour=&quot;gray30&quot;,fill='gray80',pch=21  ) +\n  geom_point(data = transform(df_example, c2 = c),#points for the faceting\n             aes( group=c, fill=c ),\n             size=4, stroke = 1,\n             colour=&quot;black&quot;,pch=21  )+\n  scale_fill_manual(values=c('pink','darkorchid1'))+facet_wrap(~ c2) \n</code></pre>\n<p>And here attached the plot I got from my own data:<a href=\"https://i.sstatic.net/AJABxVz8.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/AJABxVz8.jpg\" alt=\"enter image description here\" /></a></p>\n", "tags": ["r", "dataframe", "ggplot2", "scatter-plot", "facet-wrap"]}
{"id": "1f1be41d-300d-4112-a569-941294a7fab3", "text": "Q: Read all contacts&#39; phone numbers in android A: <pre><code>// ------------------------- Contact.kt -------------------------\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = &quot;contacts&quot;)\ndata class Contact(\n    @PrimaryKey(autoGenerate = true) val id: Long = 0,\n    var name: String,\n    var phone: String,\n    var email: String?\n)\n\n// ------------------------- ContactDao.kt -------------------------\nimport androidx.lifecycle.LiveData\nimport androidx.room.*\n\n@Dao\ninterface ContactDao {\n    @Query(&quot;SELECT * FROM contacts ORDER BY name ASC&quot;)\n    fun getAll(): LiveData&lt;List&lt;Contact&gt;&gt;\n\n    @Query(&quot;SELECT * FROM contacts WHERE id = :id LIMIT 1&quot;)\n    suspend fun getById(id: Long): Contact?\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(contact: Contact): Long\n\n    @Update\n    suspend fun update(contact: Contact)\n\n    @Delete\n    suspend fun delete(contact: Contact)\n\n    @Query(&quot;DELETE FROM contacts&quot;)\n    suspend fun deleteAll()\n}\n\n// ------------------------- ContactDatabase.kt -------------------------\nimport android.content.Context\nimport androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\n\n@Database(entities = [Contact::class], version = 1, exportSchema = false)\nabstract class ContactDatabase : RoomDatabase() {\n    abstract fun contactDao(): ContactDao\n\n    companion object {\n        @Volatile private var INSTANCE: ContactDatabase? = null\n\n        fun getInstance(context: Context): ContactDatabase =\n            INSTANCE ?: synchronized(this) {\n                Room.databaseBuilder(\n                    context.applicationContext,\n                    ContactDatabase::class.java,\n                    &quot;contacts_db&quot;\n                ).build().also { INSTANCE = it }\n            }\n    }\n}\n\n// ------------------------- ContactRepository.kt -------------------------\nimport androidx.lifecycle.LiveData\n\nclass ContactRepository(private val dao: ContactDao) {\n\n    val allContacts: LiveData&lt;List&lt;Contact&gt;&gt; = dao.getAll()\n\n    suspend fun insert(contact: Contact) = dao.insert(contact)\n    suspend fun update(contact: Contact) = dao.update(contact)\n    suspend fun delete(contact: Contact) = dao.delete(contact)\n    suspend fun deleteAll() = dao.deleteAll()\n    suspend fun getById(id: Long) = dao.getById(id)\n}\n\n// ------------------------- ContactViewModel.kt -------------------------\nimport android.app.Application\nimport androidx.lifecycle.*\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\nclass ContactViewModel(application: Application) : AndroidViewModel(application) {\n\n    private val repo: ContactRepository\n    val contacts: LiveData&lt;List&lt;Contact&gt;&gt;\n\n    init {\n        val dao = ContactDatabase.getInstance(application).contactDao()\n        repo = ContactRepository(dao)\n        contacts = repo.allContacts\n    }\n\n    fun insert(contact: Contact) = viewModelScope.launch(Dispatchers.IO) {\n        repo.insert(contact)\n    }\n\n    fun update(contact: Contact) = viewModelScope.launch(Dispatchers.IO) {\n        repo.update(contact)\n    }\n\n    fun delete(contact: Contact) = viewModelScope.launch(Dispatchers.IO) {\n        repo.delete(contact)\n    }\n\n    fun deleteAll() = viewModelScope.launch(Dispatchers.IO) {\n        repo.deleteAll()\n    }\n}\n\n// ------------------------- ContactsAdapter.kt -------------------------\nimport android.view.*\nimport android.widget.TextView\nimport androidx.recyclerview.widget.RecyclerView\n\nclass ContactsAdapter(\n    private var items: List&lt;Contact&gt;,\n    private val onClick: (Contact) -&gt; Unit\n) : RecyclerView.Adapter&lt;ContactsAdapter.Holder&gt;() {\n\n    inner class Holder(v: View) : RecyclerView.ViewHolder(v) {\n        val name: TextView = v.findViewById(R.id.tvName)\n        val phone: TextView = v.findViewById(R.id.tvPhone)\n        val email: TextView = v.findViewById(R.id.tvEmail)\n    }\n\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): Holder =\n        Holder(LayoutInflater.from(parent.context).inflate(R.layout.item_contact, parent, false))\n\n    override fun onBindViewHolder(h: Holder, pos: Int) {\n        val c = items[pos]\n        h.name.text = c.name\n        h.phone.text = c.phone\n        h.email.text = c.email ?: &quot;&quot;\n        h.itemView.setOnClickListener { onClick(c) }\n    }\n\n    override fun getItemCount() = items.size\n\n    fun updateList(list: List&lt;Contact&gt;) {\n        items = list\n        notifyDataSetChanged()\n    }\n}\n\n// ------------------------- MainActivity.kt -------------------------\nimport android.os.Bundle\nimport android.widget.*\nimport androidx.activity.ComponentActivity\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\n\nclass MainActivity : ComponentActivity() {\n\n    private lateinit var vm: ContactViewModel\n    private lateinit var adapter: ContactsAdapter\n    private var selected: Contact? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val etName = findViewById&lt;EditText&gt;(R.id.etName)\n        val etPhone = findViewById&lt;EditText&gt;(R.id.etPhone)\n        val etEmail = findViewById&lt;EditText&gt;(R.id.etEmail)\n\n        val btnAdd = findViewById&lt;Button&gt;(R.id.btnAdd)\n        val btnUpdate = findViewById&lt;Button&gt;(R.id.btnUpdate)\n        val btnDelete = findViewById&lt;Button&gt;(R.id.btnDelete)\n\n        vm = ViewModelProvider(this)[ContactViewModel::class.java]\n\n        adapter = ContactsAdapter(emptyList()) { c -&gt;\n            selected = c\n            etName.setText(c.name)\n            etPhone.setText(c.phone)\n            etEmail.setText(c.email ?: &quot;&quot;)\n        }\n\n        findViewById&lt;RecyclerView&gt;(R.id.rvContacts).apply {\n            layoutManager = LinearLayoutManager(this@MainActivity)\n            adapter = this@MainActivity.adapter\n        }\n\n        vm.contacts.observe(this) { adapter.updateList(it) }\n\n        btnAdd.setOnClickListener {\n            vm.insert(\n                Contact(\n                    name = etName.text.toString(),\n                    phone = etPhone.text.toString(),\n                    email = etEmail.text.toString()\n                )\n            )\n        }\n\n        btnUpdate.setOnClickListener {\n            selected?.let {\n                it.name = etName.text.toString()\n                it.phone = etPhone.text.toString()\n                it.email = etEmail.text.toString()\n                vm.update(it)\n            }\n        }\n\n        btnDelete.setOnClickListener {\n            selected?.let { vm.delete(it) }\n        }\n    }\n}\n</code></pre>\n", "tags": ["android", "contacts", "android-contacts", "phone-number"]}
{"id": "35ec22ff-1313-4d2e-9e62-4b616b773f54", "text": "Q: Managing async Tasks when shutdown occurs in .NET apps A: <p>You would need to wait for any write operation to complete before shutting down. One way to do this would be for any users of <code>MessageSaver</code> to implement <code>IAsyncDisposable</code> where they await any save operations that are currently being processed.</p>\n<p>Another option would be to save a list of all currently processed save tasks so they can be awaited before shutting down. One fairly straightforward way to do this is to use a blockingQueue:</p>\n<pre><code>public class MessageSaver : IAsyncDisposable\n{\n    private record SaveTask(TaskCompletionSource Tcs, string FilePath, string Content);\n    private BlockingCollection&lt;SaveTask&gt; queue = new();\n    private readonly Task processTask;\n\n    public MessageSaver() =&gt; processTask = Task.Run(ProcessQueue);\n\n    public Task SaveMessageAsync(string filePath, string content)\n    {\n        var tcs = new TaskCompletionSource();\n        queue.Add(new SaveTask(tcs, filePath, content));\n        return tcs.Task;\n    }\n    private async Task ProcessQueue()\n    {\n        foreach (var (tcs, filePath, content) in queue.GetConsumingEnumerable())\n        {\n            try\n            {\n                await using FileStream stream = File.OpenWrite(filePath);\n                await using StreamWriter sw = new StreamWriter(stream);\n                await sw.WriteLineAsync(content);\n                tcs.SetResult();\n            }\n            catch (Exception e)\n            {\n                tcs.SetException(e);\n            }\n        }\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        queue.CompleteAdding();\n        await processTask;\n    }\n}\n</code></pre>\n<p>Once you have called <code>DisposeAsync</code>, <code>SaveMessageAsync</code> will throw if you try to add any more things to save, but any queued items will be processed before <code>DisposeAsync </code>completes. You can optionally use a cancellation token to complete writing of the current item, but skip any in the queue. You might also want to add some kind of timeout or cancellation mechanism in case the saving of an item is unacceptably slow. Do note that this will serialize all the writing, this may be a good thing if you are using a spinning disk, but may slightly affect throughput for an SSD.</p>\n<p>An alternative to <code>BlockingCollection</code> is <a href=\"https://learn.microsoft.com/en-us/dotnet/core/extensions/channels\" rel=\"nofollow noreferrer\">Channel</a>. That will allow you you use an <code>async foreach</code> and avoid blocking a thread. The API is slightly different, but the general approach is the same.</p>\n", "tags": ["c#", "asynchronous", "task", "application-shutdown"]}
{"id": "f46f8ed6-8c14-43d3-a045-608ae9e51f01", "text": "Q: The purpose of an if statement condition, it is java21-ConcurrentHashMap-transfer method code:2463Line A: <p>I understand that you expect answers for Condition 2 and Condition 3.</p>\n<p>You could say this is used for defensive programming, as this &quot;if&quot; statement seems to be to prevent out-of-bounds access during the table transfer. It is acting like a guard.</p>\n<p>This if statement runs inside the for-loop of line <a href=\"https://github.com/openjdk/jdk/blob/8eaeb6990b85ac8717f4fc4ce883f674017b91f3/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2502\" rel=\"nofollow noreferrer\">2471</a>, so it can be evaluated multiple times.</p>\n<p><strong>Condition 2:</strong></p>\n<pre><code>i &gt;= n\n</code></pre>\n<p>Ensures that <code>i</code> is less than the length of the current table, <code>n</code>.</p>\n<p>It can be true, see for instance in line <a href=\"https://github.com/openjdk/jdk/blob/8eaeb6990b85ac8717f4fc4ce883f674017b91f3/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2502C21-L2502C26\" rel=\"nofollow noreferrer\">2502</a></p>\n<pre><code>                    i = n; // recheck before commit\n</code></pre>\n<p><strong>Condition 3:</strong></p>\n<pre><code>i + n &gt;= nextn\n</code></pre>\n<p>Ensures that <code>i + n</code> does not exceed the length of the next (resized) table, <code>nextn</code>.</p>\n<p>Again for instance if  nextn==n the assignment in line <a href=\"https://github.com/openjdk/jdk/blob/8eaeb6990b85ac8717f4fc4ce883f674017b91f3/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2502C21-L2502C26\" rel=\"nofollow noreferrer\">2502</a></p>\n<pre><code>                    i = n; // recheck before commit\n</code></pre>\n<p>Will make it true. In normal operation <code>nextn == nextTab.length == 2*n</code>, so <code>i + n &gt;= nextn</code> is equivalent to <code>i &gt;= n</code>. The separate check is defensive as it prevents attempts to set <code>nextTab[i + n]</code> when <code>nextTab.length</code> length is not <code>2*n</code> (or if <code>nextTab</code> changed).</p>\n<p>For the above answers I used this <a href=\"https://github.com/openjdk/jdk/blob/8eaeb6990b85ac8717f4fc4ce883f674017b91f3/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2490\" rel=\"nofollow noreferrer\">occurrence </a>of the code mentioned by the comment of user <a href=\"https://stackoverflow.com/users/6395627/slaw\">slaw </a>above.<br />\nThat is found in line <a href=\"https://github.com/openjdk/jdk/blob/8eaeb6990b85ac8717f4fc4ce883f674017b91f3/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2490\" rel=\"nofollow noreferrer\">2490 </a>of <code>ConcurrentHashMap</code> that is on the .</p>\n<p>In practice, with standard doubling of the table, both checks become true at the same time (when <code>i==n</code> ), which triggers the finishing/commit path. The <code>i + n</code> check is an extra safety guard against an out-of-range write to nextTab.</p>\n<p>Update: The above holds true for <a href=\"https://github.com/openjdk/jdk21/tree/master\" rel=\"nofollow noreferrer\">JDK21 </a>branch of <a href=\"https://github.com/openjdk\" rel=\"nofollow noreferrer\">OpenJDK </a>where the line number is <a href=\"https://github.com/openjdk/jdk21/blob/890adb6410dab4606a4f26a942aed02fb2f55387/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2463\" rel=\"nofollow noreferrer\">2463</a> as specified in the question. The code of the method is identical. The discussion above, was based on the current state of the main branch of <a href=\"https://github.com/openjdk\" rel=\"nofollow noreferrer\">OpenJDK</a>. While the question does not specify a JDK, the <code>ConcurrentHashMap</code> implementation is JDK specific. OpenJDK seems to be the one implied, as the lines of the numbers, the code and comment match the OpenJDK JDK21.</p>\n", "tags": ["java", "java.util.concurrent", "concurrenthashmap", "java-21"]}
{"id": "4acb4727-357d-4203-8eb5-c26d3d786968", "text": "Q: Perl: Why is the position of `[:space:]` within a character class seemingly important? A: <p><code>${ A }[ B ]</code> is parsed as an element of an array referenced by A at index B, whatever A and B are.</p>\n", "tags": ["perl", "syntax"]}
