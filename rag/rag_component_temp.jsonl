{"id": "8cd2436d-51b7-4373-8875-b418aaab612a", "text": "Q: As the output file grows, the write speed drops. How can I speed up writing the file? A: <p>@Barmar</p>\n<p>Here is the code with <code>np.memmap</code> implementation, I'll be grateful for your corrections:</p>\n<pre><code>dimX = ceil(xRange/xyStep)\ndimY = ceil(yRange/xyStep)\n\nsamplesZ = 1000000 # number of samples in z\n\ndata_mm = np.memmap(\n    &quot;saveData_data.bin&quot;,\n    dtype=np.float32,\n    mode=&quot;w+&quot;,\n    shape=(dimX, dimY, samplesZ)\n)\n\nsaveData = {\n    &quot;xyStep&quot;: xyStep,\n    &quot;xRange&quot;: xRange,\n    &quot;yRange&quot;: yRange,\n    &quot;zRange&quot;: zRange,\n    &quot;zBase&quot;: zBase,\n    &quot;shape&quot;: (dimX, dimY, samplesZ)\n}\n\nmeasurements = 1\npos = microscope.position\nprint(&quot;Current position: &quot; + json.dumps(pos))\n\nstarting_pos = microscope.position\n#figure(figsize=(20,5))\n\nix = 0\niy = 0\n\ntotalElapsed = 0\nstepsTaken = 1\nmaxSteps = (xRange/xyStep) * (yRange/xyStep)\nup = True\n\nix = 0\nfor x in range(-micronToStep(xRange/2), micronToStep(xRange/2) - micronToStep(xyStep), micronToStep(xyStep)):\n    iy = 0\n    for y in range(-micronToStep(yRange/2), micronToStep(yRange/2) - micronToStep(xyStep), micronToStep(xyStep)):\n        start = timer()\n        values = []\n        if (up):\n            pos = {}\n            pos['x'] = x + 5500 # declination\n            pos['y'] = y + 5000 # declination\n            pos['z'] = zBase - micronToStep(zRange/2)\n            pos['z2'] = zBase + micronToStep(zRange/2)\n            print(&quot;Scanning up to position:&quot;, pos)\n\n            values = microscope.measureZ(microscope, pos)\n            values = np.asarray(values)\n            thisTime =  timer() - start\n            totalElapsed += thisTime\n            up = False\n        else:\n            pos = {}\n            pos['x'] = x + 5500 # declination\n            pos['y'] = y + 5000 # declination\n            pos['z'] = zBase + micronToStep(zRange/2)\n            pos['z2'] = zBase - micronToStep(zRange/2)\n            print(&quot;Scanning to position:&quot;, pos)\n\n            values = microscope.measureZ(microscope, pos)\n            values = np.asarray(values)\n            values = np.flip(values)\n            thisTime =  timer() - start\n            totalElapsed += thisTime\n            up = True\n\n\n        #xs = np.linspace(zBase - micronToStep(zRange/2), zBase + micronToStep(zRange/2), values.shape[0])\n        #coef = np.polyfit(xs, values, 1)\n        #poly1d_fn = np.poly1d(coef)\n        #plt.plot(xs, values, '-ok')\n        #plt.axhline(y=np.median(values), color='r', linestyle='-')\n        #plt.xlim(0, values.shape[0])\n        #annot_max(xs,values)\n        #plt.show()\n\n\n\n        print(pos)\n        data_mm[ix, iy, :values.shape[0]] = values\n\n        iy += 1\n        timeLeft = (maxSteps - stepsTaken) * (totalElapsed / stepsTaken) / 60 / 60\n        print(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Estimated time left: [&quot; + str(timeLeft) + &quot;hr], Per Scan: [&quot; + str(totalElapsed / stepsTaken) + &quot;s][&quot; + str(thisTime) + &quot;], Total Elapsed: [&quot; + str(totalElapsed) + &quot;s], Scans taken: [&quot; + str(stepsTaken) + &quot;] out of: [&quot; + str(maxSteps) + &quot;]&quot;)\n        stepsTaken += 1\n\n    ix += 1\n\n\n\ndata_mm.flush()\n\nwith open(&quot;saveData.meta&quot;, &quot;w&quot;) as f:\n    json.dump(saveData, f)\n</code></pre>\n", "tags": ["python", "pickle", "numpy-memmap"]}
{"id": "a958bbcb-c6cf-4841-b22f-f982db3efbe7", "text": "Q: How to create a C-callable function in assembly A: <p>On 32-bit Linux (cdecl), function arguments are passed on the stack and the return value is placed in <code>EAX</code>. After setting up a stack frame, the layout is:</p>\n<pre><code>[ebp+8]  first argument (a)\n[ebp+12] second argument (b)\n</code></pre>\n<p>C does not enforce types at runtime; it simply interprets the bits returned in <code>EAX</code> as the declared return type.</p>\n<p>C declaration:</p>\n<pre><code>extern int my_function(int a, int b);\n</code></pre>\n<p>Assembly implementation (NASM, Intel syntax):</p>\n<pre><code>global my_function\n\nmy_function:\n    push ebp\n    mov  ebp, esp\n\n    mov  eax, [ebp+8]\n    mov  edx, [ebp+12]\n    lea  eax, [eax + edx*2]\n\n    pop  ebp\n    ret\n</code></pre>\n", "tags": ["c", "linux", "assembly", "x86", "intel-syntax"]}
{"id": "7ba6d3e6-5122-4ad9-97ca-ef1a3ae8a73d", "text": "Q: How to access bash variable in python script via hql file(bash-hql-python) A: <p>Approach with <code>os.environ</code> is <strong>correct</strong>, but one key condition must be true:</p>\n<p>\ud83d\udc49 <strong>The Python process must inherit the environment where the variable is exported.</strong></p>\n<p>Right now, the chain<br />\n<strong>bash \u2192 hive \u2192 python</strong> is where things usually break.</p>\n<p>Below are <strong>working and reliable options</strong>, from best to fallback.</p>\n<p>Option 1 (Best): Pass variable explicitly via <code>hiveconf</code></p>\n<p>export var=&quot;/abc/xyz/file.txt&quot;</p>\n<p>hive --hiveconf my_var=&quot;$var&quot; -f script.hql</p>\n<p><strong>Then</strong></p>\n<p>Hive (<code>script.hql</code>)</p>\n<p>SET hive.exec.mode.local.auto=true;</p>\n<p>!python my_script.py;</p>\n", "tags": ["python", "bash", "shell", "hive"]}
{"id": "7aeb12b0-62b9-4333-93c2-695541759929", "text": "Q: Scss, nth-child &amp; :not() selector A: <p><strong>As I already commented:</strong> If you make your <code>.row</code> into <code>&lt;section&gt;</code> and keep the siblings (they are on the same level (next to each other) not nested inside of <code>.row</code>) as <code>&lt;div&gt;</code>, you can maintain the odd/even sequence on the <code>.row</code> by using:</p>\n<blockquote>\n<p>section:nth-of-type(odd)</p>\n</blockquote>\n<p>Using <code>:nth-of-type()</code> selector allows you to more control by using different tags which when used strategically, will allow you to specifically target tags.</p>\n<h2>Demo</h2>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>section:nth-of-type(odd) {\n  background: rgba(0, 0, 0, .4)\n}\n\nsection:nth-of-type(even) {\n  background: rgba(200, 0, 0, .4)\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div class=\"rows-container\"&gt;\n  &lt;section class=\"row\"&gt;ROW1&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;section class=\"row\"&gt;ROW2&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;div&gt;DIV All divs are not children of any .row&lt;/div&gt;\n  &lt;div&gt;DIV All divs are siblings of the .row&lt;/div&gt;\n  &lt;section class=\"row\"&gt;ROW3&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;section class=\"row\"&gt;ROW4&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;section class=\"row\"&gt;ROW5&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;section class=\"row\"&gt;ROW6&lt;/section&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n  &lt;div&gt;DIV&lt;/div&gt;\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n", "tags": ["css", "sass"]}
{"id": "3724a382-b213-4e0d-acd5-1c4f80666af3", "text": "Q: Collatz conjecture with C (range 1-100,000,000) maximum loops A: <p>Here is a smallish version.  I just used gcc -O3 and saw no difference in that or other parms for gcc.  We know from Wikipedia:</p>\n<ul>\n<li><p><strong>less than 10 is 9, which has 19 steps</strong></p>\n</li>\n<li><p><strong>less than 100 is 97, which has 118 steps</strong></p>\n</li>\n<li><p><strong>less than 1,000 is 871, which has 178 steps</strong></p>\n</li>\n<li><p><strong>less than 10,000 is 6,171, which has 261 steps</strong></p>\n</li>\n<li><p><strong>less than 100,000 is 77,031, which has 350 steps</strong></p>\n</li>\n<li><p><strong>less than 1 million is 837,799, which has 524 steps</strong></p>\n</li>\n<li><p><strong>less than 10 million is 8,400,511, which has 685 steps</strong></p>\n</li>\n<li><p><strong>less than 100 million is 63,728,127, which has 949 steps</strong></p>\n</li>\n<li><p><strong>less than 1 billion is 670,617,279, which has 986 steps</strong></p>\n</li>\n<li><p><strong>less than 10 billion is 9,780,657,631, which has 1132 steps (Max 10^n for uint64_t)</strong></p>\n</li>\n<li><p><strong>less than 100 billion is 75,128,138,247, which has 1228 steps</strong></p>\n</li>\n<li><p><strong>less than 1 Trillion is 989,345,275,647, which has 1,348 steps</strong></p>\n</li>\n</ul>\n<p>uint64_t will overflow when you try to get to 100 billion because 41,690,685,951 gets to an overflow. I have played with the formula and failed anywhere from there down to to 12,327,829,503.  The overflow point depends on the formulas used for odds and evens.  But, no matter the formula,  uint64_t couldn't get me to 100 Billion.  I switched to __128 and the overflow problem is that I will die of old age first. TOO_BIG becomes: 113,427,455,640,312,821,154,458,202,477,256,070,483  But 128 bit numbers run slower, my old i7 has few 128 bit native instructions and they don't get used here.  So uint64_t it is...</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;limits.h&gt;\n#define CACHE_SIZE 1000000000\n#define TOO_BIG  ULONG_MAX/3-1 //  any x &gt;= 6,148,914,691,236,517,203\n\nint *cache = NULL; \n\nuint64_t collatz_steps(uint64_t n) {\n   uint64_t original_n = n;\n   int c = 0; // Start counting from the initial number\n   while (n != 1) { \n      if (n &gt; TOO_BIG &amp;&amp; n&amp;1) {  // odds will be made as 3*n+1 \n         printf(&quot;calc for %lu too large %lu* 3 + 1 &gt; %lu\\n&quot;,original_n,n,ULONG_MAX);\n         exit(EXIT_FAILURE); // Return a non-zero value for error\n      }\n      if (n &lt; CACHE_SIZE &amp;&amp; cache[n]!=0) return c + cache[n];  \n      if (n&amp;1) {\n         n = (n&lt;&lt;1)-(n&gt;&gt;1);  // (3*n+1)/2\n         c++;\n      } else \n         n &gt;&gt;=1;\n      c++;  \n   }\n   if (original_n &lt; CACHE_SIZE) cache[original_n] = c;\n   return c;\n}\n \nint main(int argc, char** argv) {\n   uint64_t limit = (argc &gt; 1) ? strtoul(argv[1], NULL, 10) : 1000000; // default to a million\n   uint64_t tmp,max_n,max_c = 0;\n   cache = calloc(CACHE_SIZE,sizeof(int)); \n   //for (uint64_t i=limit-(1-limit%2);i&gt;2;i-=2) { \n   for (uint64_t i = 1;i&lt;=limit;i++) { \n       tmp = collatz_steps(i);\n       if (tmp&gt;=max_c) {\n          max_c = tmp;\n          max_n = i;\n       }\n   }\n   printf(&quot;From 1 to %lu the max steps is %lu for %lu\\n&quot;,limit,max_c,max_n);\n   return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ gcc -O3 collatzx.c -o collatzx \n$ time  ./collatzx 1000000\nFrom 1 to 1000000 the max steps is 524 for 837799\n\nreal    0m0.090s\nuser    0m0.066s\nsys     0m0.024s\n\n$ time  ./collatzx 10000000\nFrom 1 to 10000000 the max steps is 685 for 8400511\n\nreal    0m1.040s\nuser    0m0.827s\nsys     0m0.212s\n\n$ time  ./collatzx 100000000\nFrom 1 to 100000000 the max steps is 949 for 63728127\n\nreal    0m9.815s\nuser    0m8.607s\nsys     0m1.207s\n</code></pre>\n<p>Here, for fun, is my 128 bit version.  you can switch it back to uint64_t or int by changing the define for coll_t.  It is slower but can go for a long long way...</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n#define CACHE_SIZE 500000000\n#define coll_t unsigned __int128\n//#define coll_t uint64_t\n\nint *cache = NULL; \nvoid printCollt(coll_t n) { // print coll_t \n   if (n &lt; 1000) {\n      printf(&quot;%d&quot;, (int)n);\n      return;\n   }\n   printCollt(n / 1000); // recurse\n   printf(&quot;,&quot;);  \n   printf(&quot;%03d&quot;, (int)(n % 1000)); // print hundreds of current n\n}\n\ncoll_t collatz_steps(coll_t original_n) {\n   coll_t n = original_n;\n   int c = 0; // Start counting from the initial number\n   while (n != 1) { \n      if (n &lt; CACHE_SIZE &amp;&amp; cache[n]!=0) return c + cache[n];  \n      if (n&amp;1) {\n         n = (n&lt;&lt;1)-(n&gt;&gt;1);  // (3*n+1)/2\n         c++; // add for extra even calc\n      } else \n         n &gt;&gt;=1;\n      c++;  // add for even or odd calc\n   }\n   if (original_n &lt; CACHE_SIZE) cache[original_n] = c;\n   return c;\n}\n \nint main(int argc, char** argv) {\n   coll_t limit = (argc &gt; 1) ? strtoul(argv[1], NULL, 10) : 1000000; // default to a million\n   coll_t tmp,max_n,max_c = 0;\n   cache = calloc(CACHE_SIZE+1,sizeof(int));  \n   printf(&quot;Searching for max Collatz steps from 1 to &quot;),printCollt(limit),printf(&quot;\\n&quot;); \n   for (coll_t i = 1;i&lt;=limit;i+=2) { \n      tmp = collatz_steps(i);\n      if (tmp&gt;=max_c) {\n         max_c = tmp;\n         max_n = i;\n      }\n   }\n   printf(&quot;From 1 to &quot;),printCollt(limit),printf(&quot; the max steps is &quot;);\n   printCollt(max_c),printf(&quot; for &quot;),printCollt(max_n),printf(&quot;\\n&quot;);\n   return 0;\n} \n</code></pre>\n", "tags": ["c", "processing-efficiency", "collatz"]}
{"id": "fac96a50-0941-4e30-9751-c9aa6dd21a2b", "text": "Q: PHP mb_detect_encoding no longer reliably detects UTF-8 A: <p>Indeed, and it got apparently even worse in php 8.3:</p>\n<p>$ php8.2 -r &quot;var_dump( mb_detect_encoding(str_repeat('x',32763) .  '\u00e9\u044d'));&quot;</p>\n<p>string(5) &quot;UTF-8&quot;</p>\n<p>$ php8.3 -r &quot;var_dump( mb_detect_encoding(str_repeat('x',32763) .  '\u00e9\u044d'));&quot;</p>\n<p>string(5) &quot;ASCII&quot;</p>\n<p>with the identical mbstrings section in phpinfo.</p>\n", "tags": ["php", "utf-8", "mbstring"]}
{"id": "340dbe5d-af30-4dbf-84f7-5f8d0a37e1a3", "text": "Q: How to compile Java to WASM (WebAssembly)? A: <p>J2CL, a Google backed Java to Javascript transpiler, lets you know also compile Java to WebAssembly.</p>\n<p><a href=\"https://github.com/google/j2cl/blob/master/docs/getting-started-j2wasm.md\" rel=\"nofollow noreferrer\">https://github.com/google/j2cl/blob/master/docs/getting-started-j2wasm.md</a></p>\n", "tags": ["java", "webassembly"]}
