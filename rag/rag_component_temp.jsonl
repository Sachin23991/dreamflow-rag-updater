{"id": "94f5c137-fdc8-41a1-ac56-a3c5566f8496", "text": "Q: &quot;Event loop closed&quot; with asyncio/asyncpg A: <p>Since you did not provide stack trace it's not clear to me where that error is being generated. But you want to create a single event loop on which the creation and closing of the connection are done:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import asyncio  \nimport asyncpg  \n  \nasync def adapted_async():  \n    conn = await asyncpg.connect(database='async_test')) \n    await conn.close()\n          \nif __name__ == &quot;__main__&quot;:  \n    asyncio.run(adapted_async())\n</code></pre>\n", "tags": ["python", "python-asyncio", "asyncpg"]}
{"id": "90092137-4443-4720-89b0-758e67e8aafc", "text": "Q: Table layout adjusting insides of components A: <p>My comment on <strong>COULD</strong> was about re-using existing classes without the need for re-writes or other forms of code duplication.</p>\n", "tags": ["java", "swing", "user-interface", "components", "tablelayout"]}
{"id": "2ba649dd-2f15-4c8d-b6dc-5e5d0fc41de1", "text": "Q: Implementing voip in a MAUI application? A: <p>If you're just looking for service providers that give you .NET MAUI options these two are the first ones i see when I google for it</p>\n<p><a href=\"https://www.siprix-voip.com/blog/siprix-voip-sdk-now-works-with-net-maui/\" rel=\"nofollow noreferrer\">https://www.siprix-voip.com/blog/siprix-voip-sdk-now-works-with-net-maui/</a>\n<a href=\"https://www.portsip.com/portsip-voip-sdk/\" rel=\"nofollow noreferrer\">https://www.portsip.com/portsip-voip-sdk/</a></p>\n", "tags": ["c#", "maui", "sip", "voip", ".net-9.0"]}
{"id": "4486e684-14a9-4f08-9154-67db6e216f59", "text": "Q: Cutting rows beginning with letter and past them after last cell of row beginning with number A: <p>You can change the formula to accommodate a higher maximum number of rows:</p>\n<p>For six rows:</p>\n<pre><code>=IF(ISNUMBER(B1),TOROW(INDIRECT(&quot;A1:G&quot; &amp; MIN(MATCH(B1+1,B2:B7,0),6)),1),&quot;&quot;)\n</code></pre>\n<p>For seven:</p>\n<pre><code>=IF(ISNUMBER(B1),TOROW(INDIRECT(&quot;A1:G&quot; &amp; MIN(MATCH(B1+1,B2:B8,0),7)),1),&quot;&quot;)\n</code></pre>\n<p>And so on.</p>\n", "tags": ["excel", "vba"]}
{"id": "e36101ec-81bf-4771-8851-5a6a05c3522e", "text": "Q: awk to get certain next lines when a pattern is matched A: <p>Your code</p>\n<pre><code>&lt;output of a command&gt; | awk '{if ($2 == &quot;untagged&quot;) saved=$1; next;} {if ($1 == &quot;-&quot;); $1=saved; print $1, $2}'\n</code></pre>\n<p>uses <code>if</code>s for conditional actions, however GNU <code>AWK</code> allows you to express that without <code>if</code>s, namely you can use pattern-action pairs. Let output of <code>command</code> be</p>\n<pre><code>0:4:1 untagged 192.168.20.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           10 192.168.10.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           30 192.168.30.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           40 192.168.40.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           50 192.168.50.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           60 192.168.60.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           70 192.168.70.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           80 192.168.80.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           90 192.168.90.11 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n0:4:2 untagged 192.168.20.12 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n1:4:1 untagged 192.168.20.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           10 192.168.10.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           30 192.168.30.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           40 192.168.40.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           50 192.168.50.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           60 192.168.60.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           70 192.168.70.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           80 192.168.80.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n-           90 192.168.90.13 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n1:4:2 untagged 192.168.20.14 255.255.255.0     0.0.0.0 0 0.0.0.0        3205\n</code></pre>\n<p>then</p>\n<pre><code>command | awk '$2==&quot;untagged&quot;{saved=$1}$1==&quot;-&quot;{print saved, $2}'\n</code></pre>\n<p>gives output</p>\n<pre><code>0:4:1 10\n0:4:1 30\n0:4:1 40\n0:4:1 50\n0:4:1 60\n0:4:1 70\n0:4:1 80\n0:4:1 90\n1:4:1 10\n1:4:1 30\n1:4:1 40\n1:4:1 50\n1:4:1 60\n1:4:1 70\n1:4:1 80\n1:4:1 90\n</code></pre>\n<p>Explanation: 1st action of saving 1st content to variable named <code>saved</code> if 2nd field is equal to string <code>untagged</code>. 2nd action of <code>print</code>ing content of saved followed by 2nd field is applied if 1st field is equal to string <code>-</code>.</p>\n<p><strong>DISCLAIMER</strong>: this solution assumes that 1st row 2nd field is always equal to untagged, if this does not hold true then ignore this answer entirely.</p>\n<p><em>(tested in GNU Awk 5.3.1)</em></p>\n", "tags": ["awk"]}
{"id": "702c61c9-dec5-4672-8fad-90974b00051a", "text": "Q: How to have primitive discard additional arguments A: <p>No, there's no such global setting. You could make a helper that wraps a function with an <code>na.rm</code> option</p>\n<pre><code>narm &lt;- function(f) function(...) f(..., na.rm=TRUE)\n</code></pre>\n<p>And then use</p>\n<pre><code>list(mean=narm(mean), length=length) |&gt; Map(f=\\(fn) fn(xs))\n# or\nlist(mean=mean |&gt; narm(), length=length) |&gt; Map(f=\\(fn) fn(xs))\n</code></pre>\n<p>Because many of the functions that support <code>na.rm</code> are primitive/generic functions, functions like <code>args()</code> won't work to tell if you if they suppose <code>na.rm</code> or not.</p>\n<p>you could also just drop the NA values</p>\n<pre><code>list(mean=mean, length=length) |&gt; Map(f=\\(fn) fn(na.omit(xs)))\n</code></pre>\n<p>which does change the length value, but you could probably special case that depending on what exactly your needs are. But it's misleading to think of 6 as being the mean of 10, values, it's the mean of the 9 non-missing values.</p>\n<p>You could also special case <code>length</code> in the na.rm helper, something like</p>\n<pre><code>narm &lt;- function(f) function(...) if (!identical(f, length)) f(..., na.rm=TRUE) else f(...)\nlist(mean=mean, length=length) |&gt; Map(f=\\(fn) narm(fn)(xs))\n</code></pre>\n", "tags": ["r"]}
{"id": "7ad17fff-c0f3-4d98-860e-bdd45f538292", "text": "Q: Pytesseract can&#39;t recognize the letter A A: <p>You are currently using <strong>PSM 4</strong> (Column mode). For a single line of text like this, PSM 4 is often less accurate than modes designed for lines.</p>\n<ul>\n<li><p><strong>Try PSM 7:</strong> &quot;Treat the image as a single text line.&quot;</p>\n</li>\n<li><p><strong>Try PSM 6:</strong> &quot;Assume a single uniform block of text.&quot;</p>\n</li>\n</ul>\n<pre><code># Change to PSM 7 for single line detection\nTESSERACT_CONFIG = r'--psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$.-_, '\n</code></pre>\n", "tags": ["python", "ocr", "python-tesseract"]}
{"id": "36fa32bf-0857-4196-ab04-00aaeaf9e73c", "text": "Q: Makefile error when .PHONY target doesn&#39;t contain the output file names A: <p>In typical use, the Make target on the left-hand side of a rule should be the name of the file the rule generates.  Don't use a <code>.PHONY:</code> target if you're building a file; use the name of the file as the target name.  In your setup you're creating three file targets (one shared library and two symlinks) and so this can usefully be three rules.</p>\n<pre class=\"lang-makefile prettyprint-override\"><code>$(SOLIBNAME): lib/src/abc.o\n    g++ -shared -o $(SOLIBNAME) $^ $(LIB_LDFLAGS)\n\n$(LIBNAME).so: $(SOLIBNAME)\n    ln -srf $(SOLIBNAME) $(LIBNAME).so\n\n$(LIBNAME).so.0: $(SOLIBNAME)\n    ln -srf $(SOLIBNAME) $(LIBNAME).so.0\n</code></pre>\n<p>In a comment you ask about still having a consistent name for the command line, even if the library version changes.  Here a <code>.PHONY</code> target makes sense.</p>\n<pre class=\"lang-makefile prettyprint-override\"><code>.PHONY: foobuild\nfoobuild: $(LIBNAME).so $(LIBNAME).so.0\n</code></pre>\n<p>Now even if you change the build metadata, you'll have a fixed name you can use at the command line.</p>\n<pre class=\"lang-makefile prettyprint-override\"><code>LIBNAME := libfoo\nLIBFOO_MAJOR := 0\nLIBFOO_MINOR := 0\nLIBFOO_PATCH := 1\nLIBFOO_SO_SHORT := $(LIBNAME).so.$(LIBFOO_MAJOR)\nLIBFOO_SO_FULL := $(LIBNAME).so.$(LIBFOO_MAJOR).$(LIBFOO_MINOR).$(LIBFOO_PATCH)\n\n.PHONY: foobuild\nfoobuild: $(LIBFOO_SO_SHORT) $(LIBFOO_SO_FULL)\n</code></pre>\n<pre class=\"lang-bash prettyprint-override\"><code>make foobuild LIBFOO_MAJOR=1 LIBFOO_MINOR=0 LIBFOO_PATCH=0\n\n# same as\n# make libfoo.so.1 libfoo.so.1.0.0 LIBFOO_MAJOR=1 LIBFOO_MINOR=0 LIBFOO_PATCH=0\n</code></pre>\n", "tags": ["makefile", "gnu-make"]}
{"id": "9c54038f-b440-4fcd-9006-247a70619d65", "text": "Q: Spring Boot @Valid returns just &quot;Bad Request&quot; message instead of my custom message A: <p>Spring Boot\u2019s default error output uses <code>ProblemDetail</code> with only basic fields by default. To include custom validation messages, you must handle the MethodArgumentNotValidException in a <code>@RestControllerAdvice</code>.</p>\n<p>If you just want one field at a time, you can validate manually in the controller using <code>BindingResult</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@PostMapping\npublic ResponseEntity&lt;?&gt; genShortUrl(@Valid @RequestBody Req req, BindingResult br) {\n\nif (br.hasErrors()) {\n\n    return ResponseEntity.badRequest().body(br.getFieldError().getDefaultMessage());\n\n}\n\n...\n\n}\n</code></pre>\n<p>But global advice is cleaner and reusable.</p>\n", "tags": ["spring-boot", "spring-restcontroller"]}
