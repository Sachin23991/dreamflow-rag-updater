{"id": "4cc05bad-76c9-4e35-bc46-b48002b18d85", "text": "Q: Xcode : Embed different .xcframework based on scheme (dev/uat/prod) without breaking Embed &amp; Sign A: <p>These are local folders (.xcframework); which I put in <code>Project/ios/SDK</code> folder. Inside these folders I have created 3 folders; <code>PROD</code> , <code>UAT</code> and <code>FINAL</code> . I import them inside the xcode imports them all automatically, then I remove the PROD and UAT frameworks from xcode settings and change them embed option for FINAL to &quot;Embed and Sign&quot;</p>\n", "tags": ["ios", "swift", "xcode", "mobile"]}
{"id": "23f795f9-9ae2-4099-8808-c47be2bc0a92", "text": "Q: Flutter/Dart - Using Spacer / Flexible for Column layout A: <p>The issue is your nested Columns. When you put a <code>Spacer</code> inside a Column, that Column needs to know its height. But your inner Column (in <code>myViewBody</code>) is sitting inside another Column (in <code>myView</code>) without any height constraints\u2014so Flutter has no idea how much space the Spacer should fill.</p>\n<p>Wrap <code>myViewBody()</code> with <code>Expanded</code> so the parent Column gives it bounded height:</p>\n<pre><code>Widget myView() {\n  return Column(\n    children: &lt;Widget&gt;[\n      const Text('this is the stepper view'),\n      Expanded(              // &lt;-- this is the fix\n        child: myViewBody(state),\n      ),\n    ],\n  );\n}\n</code></pre>\n<p>Hope it helps!</p>\n", "tags": ["flutter", "dart"]}
{"id": "e8893a7c-17c8-4a07-8057-e7d8e9602156", "text": "Q: How do ride-hailing apps like Uber or Rapido achieve smooth and accurate live driver tracking? A: <p>Apps like Uber, Ola, Rapido, etc. don\u2019t get smooth tracking from GPS alone. What you see is the result of sensor fusion + filtering + backend processing + UI interpolation. At scale, this is a well-understood architecture.</p>\n<pre><code>Driver App\n \u2514\u2500 Fused Location Provider\n \u2514\u2500 Client-side smoothing\n \u2514\u2500 Send location every 1\u20132s\n        \u2193\nBackend\n \u2514\u2500 Validate + filter points\n \u2514\u2500 Map-match to road\n \u2514\u2500 Predict short-term movement\n        \u2193\nRider App\n \u2514\u2500 Interpolate between points\n \u2514\u2500 Smooth animation on map\n\n</code></pre>\n", "tags": ["flutter", "google-maps", "gps", "location", "flutter-animation"]}
{"id": "6c55835e-94b1-4cf7-b5b3-272d75b85006", "text": "Q: How to send an email, with attachment, using rust and google_gmail1 A: <p>This isn't quite the answer you're looking for, since it is not designed for a service account.  However, it might prove useful to others, so here it is.</p>\n<p>You'll want these dependencies (Note that you could save a lot of complexity by also using lettre)</p>\n<pre class=\"lang-ini prettyprint-override\"><code>[dependencies]\nrustls = { version = &quot;0.23&quot;, features = [&quot;ring&quot;] }\nclap = { version = &quot;4.5&quot;, features = [&quot;derive&quot;] }\ntokio = { version = &quot;1.48&quot;, features = [&quot;full&quot;] }\ngoogle-gmail1 = &quot;6.0&quot;\nyup-oauth2 = &quot;11.0&quot;\nhyper = &quot;1.8&quot;\nhyper-util = { version = &quot;0.1&quot; }\nhyper-rustls = { version = &quot;0.27&quot;, features = [&quot;ring&quot;] }\nbase64 = &quot;0.22&quot;\n</code></pre>\n<p>Then you can use <code>yup_oauth2</code> to authenticate a user, and <code>google_gmail1</code> to send an email, like this.  Note that the error checking is a bit weak... you'll certainly want to harden it for production.</p>\n<pre><code>use base64::{Engine as _, engine::general_purpose::STANDARD};\nuse clap::Parser;\nuse google_gmail1::{Gmail, api::Message};\nuse hyper_rustls::HttpsConnectorBuilder;\nuse hyper_util::client::legacy::Client;\nuse hyper_util::rt::TokioExecutor;\nuse std::error::Error;\nuse std::fs;\nuse std::io::Cursor;\nuse std::path::Path;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse yup_oauth2::{InstalledFlowAuthenticator, InstalledFlowReturnMethod};\n\n/// Send an email using the GMail API\n#[derive(Parser)]\n#[command(name = &quot;cli-mailer&quot;)]\n#[command(about = &quot;Send an email using the GMail API&quot;)]\nstruct Args {\n    /// Sender (email address -- optionally format as &quot;Name &lt;address&gt;&quot;)\n    #[arg(short = 'f', required = true)]\n    from: String,\n\n    /// Recipient (email address -- optionally format as &quot;Name &lt;address&gt;&quot;)\n    #[arg(short = 't', required = true)]\n    to: String,\n\n    /// Subject (string)\n    #[arg(short = 's', required = true)]\n    subject: String,\n\n    /// Body (text file name)\n    #[arg(short = 'b', required = true)]\n    body_file: String,\n\n    /// Attachment (file name)\n    #[arg(short = 'a', default_value = &quot;&quot;)]\n    attachment_file: String,\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // Enable a crypto provider or the interactions with Google will fail\n    rustls::crypto::ring::default_provider()\n        .install_default()\n        .expect(&quot;Failed to install rustls crypto provider&quot;);\n\n    // Parse args, read files, fail fast if anything breaks\n    let args = Args::parse();\n    let msg_body = fs::read_to_string(&amp;args.body_file)?;\n    let attachment = if !args.attachment_file.is_empty() {\n        Some((\n            Path::new(&amp;args.attachment_file).to_str().unwrap(),\n            fs::read(&amp;args.attachment_file)?,\n        ))\n    } else {\n        None\n    };\n\n    // Make the email message\n    let raw_msg = build_mime_message(&amp;args.to, &amp;args.from, &amp;args.subject, &amp;msg_body, attachment);\n\n    // Use local credentials.json to authenticate with Google\n    // May request a browser flow\n    // Will cache result in token.json to avoid future browser flows\n    let secret = yup_oauth2::read_application_secret(&quot;credentials.json&quot;).await?;\n    let auth = InstalledFlowAuthenticator::builder(secret, InstalledFlowReturnMethod::HTTPRedirect)\n        .persist_tokens_to_disk(&quot;token.json&quot;)\n        .build()\n        .await?;\n\n    // Build a client, use it to send a message, and report the result\n    let client = Client::builder(TokioExecutor::new()).build(\n        HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .unwrap()\n            .https_or_http()\n            .enable_http1()\n            .build(),\n    );\n    let result = Gmail::new(client, auth)\n        .users()\n        .messages_send(Message::default(), &quot;me&quot;)\n        .upload(Cursor::new(raw_msg.into_bytes()), &quot;message/rfc822&quot;.parse()?)\n        .await?;\n    println!(&quot;Message sent... id = {}&quot;, result.1.id.unwrap_or_default());\n    Ok(())\n}\n\n/// Helper function to construct a raw MIME email string\n/// - `to` The recipient address\n/// - `from` The sender address\n/// - `subject` The message subject\n/// - `body` The (text) body of the message\n/// - `attachment` A filename and file contents for the attachment to send, or None\n///\n/// Returns a base64-encoded string representation of the message\nfn build_mime_message(\n    to: &amp;str,\n    from: &amp;str,\n    subject: &amp;str,\n    body: &amp;str,\n    attachment: Option&lt;(&amp;str, Vec&lt;u8&gt;)&gt;,\n) -&gt; String {\n    // Make a string with the standard headers\n    let mut msg = String::new();\n    msg.push_str(&amp;format!(&quot;From: {}\\r\\n&quot;, from));\n    msg.push_str(&amp;format!(&quot;To: {}\\r\\n&quot;, to));\n    msg.push_str(&amp;format!(&quot;Subject: {}\\r\\n&quot;, subject));\n    msg.push_str(&quot;MIME-Version: 1.0\\r\\n&quot;);\n\n    if let Some((filename, content)) = attachment {\n        // There's an attachment, set up the multipart component.  Start with a\n        // unique boundary\n        let boundary = format!(\n            &quot;boundary_{}&quot;,\n            SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_millis()\n        );\n        msg.push_str(&amp;format!(\n            &quot;Content-Type: multipart/mixed; boundary=\\&quot;{}\\&quot;\\r\\n\\r\\n&quot;,\n            boundary\n        ));\n\n        // Message body\n        msg.push_str(&amp;format!(&quot;--{}\\r\\n&quot;, boundary));\n        msg.push_str(&quot;Content-Type: text/plain; charset=\\&quot;UTF-8\\&quot;\\r\\n\\r\\n&quot;);\n        msg.push_str(body);\n        msg.push_str(&quot;\\r\\n&quot;);\n\n        // Attachment\n        msg.push_str(&amp;format!(&quot;--{}\\r\\n&quot;, boundary));\n        msg.push_str(&quot;Content-Type: application/octet-stream\\r\\n&quot;);\n        msg.push_str(&quot;Content-Transfer-Encoding: base64\\r\\n&quot;);\n        msg.push_str(&amp;format!(\n            &quot;Content-Disposition: attachment; filename=\\&quot;{}\\&quot;\\r\\n\\r\\n&quot;,\n            filename\n        ));\n\n        // Encode the attachment\n        let encoded_attachment = STANDARD.encode(content);\n        msg.push_str(&amp;encoded_attachment);\n        msg.push_str(&quot;\\r\\n&quot;);\n\n        // End the boundary\n        msg.push_str(&amp;format!(&quot;--{}--&quot;, boundary));\n    } else {\n        // No attachment: just put the body into the string\n        msg.push_str(&quot;Content-Type: text/plain; charset=\\&quot;UTF-8\\&quot;\\r\\n\\r\\n&quot;);\n        msg.push_str(body);\n    }\n    msg\n}\n</code></pre>\n", "tags": ["rust", "google-api", "gmail", "gmail-api", "service-accounts"]}
{"id": "bef383ac-f975-4a3d-9032-e37023ff75e5", "text": "Q: Decent ways to handle malloc failure? A: <p>A simple way is to use loops for an array of pointers as for example</p>\n<pre class=\"lang-c prettyprint-override\"><code>int *a = NULL, *b = NULL, *c = NULL;\nint ** arr[] = { &amp;a, &amp;b, &amp;c };\nconst size_t N = sizeof( arr ) / sizeof( *arr );\n\nsize_t i = 0;\n\nwhile ( ( i &lt; N ) &amp;&amp; ( *arr[i] = malloc( sizeof( **arr[i] ) ) ) != NULL ) \n{\n    ++i;\n}\n\nif ( i != N ) // Memory was not allocated for all pointers \n{\n    while ( i != 0 )\n    {\n        free( *arr[--i] );\n    }\n\n    // possibly return from the function\n}\n\n// continue to work with pointers\n</code></pre>\n<p>With this approach you can deal with any number of pointers without changing the code except the initializing list of the array.</p>\n<p>Pay attention to that in code in other answers if you will change the number of pointers then you will need to change the code in many places. Such a code is error prone.</p>\n<p><strong>Edit:</strong></p>\n<p>After you updated your question provided a function definition where there are used several calls of malloc and free I can suggest the following function definition where there are used only one return statement (instead of several return statements as in your function definition) and non-duplicated calls of free and neither goto statement.</p>\n<p>Use the structured programming approach instead of numerous goto statements.</p>\n<p>Here you are.</p>\n<pre class=\"lang-c prettyprint-override\"><code>typedef struct tree tree_t;\n\nstruct tree {\n   tree_t *parent;     // a pointer to the parent tree.\n   list_t *children;   // a pointer to the list which has the pointers to the child trees of this tree.\n                       // list_t is a linked list I've made.\n   void *data;         // a pointer to the data this tree has.\n   size_t data_size;   // the size of the data.\n};\n\n// This function creates a new tree object.\n// This function returns a pointer to the newly created tree.\n// If failed, returns NULL.\ntree_t * tree_plant( void *data, size_t data_size ) \n{\n    tree_t *sapling = NULL;\n   \n    if ( data != NULL &amp;&amp; data_size != 0 )\n    {\n        enum { Tree, Data, Children };\n        int order[] = { Tree, Data, Children };\n        const size_t N = sizeof( order ) / sizeof( *order );\n        \n        void *tree_data = NULL;\n        list_t *tree_children = NULL;\n   \n        int success = 1;\n        for ( size_t i = 0; success &amp;&amp; i &lt; N; i++ )\n        {\n            switch ( order[i] )\n            {\n            case Tree:\n                sapling = malloc( sizeof( tree_t ) );\n                success = sapling != NULL;\n                break;\n            \n            case Data:\n                tree_data = malloc( data_size );\n                success = tree_data != NULL;\n                break;\n            \n            case Children:\n                tree_children = list_create();\n                success = tree_children != NULL;\n                break;\n            }\n            \n            if ( !success )\n            {\n                switch ( order[i] )\n                {\n                case Children:\n                    free( tree_data );\n\n                //[[fallthrough]]\n                case Data:\n                    free( sapling );\n                \n                //[[fallthrough]]\n                case Tree:\n                    sapling = NULL;\n                    break;\n                }\n            }\n        }           \n\n        if ( success )\n        {\n            // Initializes all fields\n            sapling-&gt;parent = NULL;\n            sapling-&gt;children = tree_children;\n            sapling-&gt;data = tree_data;\n            sapling-&gt;data_size = data_size;\n   \n            memcpy( sapling-&gt;data, data, data_size );\n        }\n    }\n\n    return sapling;\n}\n</code></pre>\n", "tags": ["c", "malloc", "free"]}
{"id": "4e5a20c8-c649-4df9-9c3a-c1fc493b4701", "text": "Q: Why is sizeof(unsigned double) equal to 4? A: <p>It is a bug in VS2010.  VS2012 gives the following error for that line of code.</p>\n<pre><code>error CS1002: ; expected\n</code></pre>\n<p>It is expecting a <code>;</code> before the keyword <code>double</code>.</p>\n", "tags": ["c++", "visual-studio-2010"]}
{"id": "120aee7c-747d-4b0e-b179-22fb08f14406", "text": "Q: Small sample TypeScript + Node code doesn&#39;t build A: <p>The guide has incorrect code. According to the <a href=\"https://www.npmjs.com/package/@axonflow/sdk\" rel=\"nofollow noreferrer\">published package</a>, the export is <code>AxonFlow</code>, not <code>AxonFlowClient</code> and that's been true for every version.</p>\n<pre><code>import AxonFlow from '@axonflow/sdk';\n</code></pre>\n<p>For the config shape and available methods, refer to the package's README rather than the guide you're following. The <code>organizationId</code> and <code>executeQuery</code> errors suggest more of the guide's code doesn't match the actual API.</p>\n<p>When a &quot;getting started&quot; guide doesn't match the package it's documenting, trust the package source\u2014check the README or the types in <code>node_modules/@axonflow/sdk</code>.</p>\n", "tags": ["node.js", "typescript"]}
{"id": "a0a212a4-df72-41e4-904a-8354775371d3", "text": "Q: VSTS Extension: &quot;Cannot process command because of one or more missing mandatory parameters: appdirectory webappname ResourceGroupName&quot; A: <p>You still have to pull the values into your script. Look at how the <a href=\"https://github.com/Microsoft/vsts-tasks/tree/master/Tasks\" rel=\"nofollow noreferrer\">reference tasks</a> function, or look at the <a href=\"https://github.com/Microsoft/vsts-task-lib\" rel=\"nofollow noreferrer\">documentation</a>.</p>\n\n<p>Your script needs to import and use the task SDK and call <a href=\"https://github.com/Microsoft/vsts-task-lib/blob/master/powershell/Docs/Commands.md#get-vstsinput\" rel=\"nofollow noreferrer\"><code>Get-VstsInput</code></a> to retrieve the values.</p>\n\n<p>For what it's worth, you should use the <code>PowerShell3</code> handler, as <code>PowerShell</code> is legacy.</p>\n\n<p>Another option is to not create a custom task if this is intended only for internal use, although 100% bias on my part. I dislike turning simple PowerShell scripts into opaque black boxes and prefer to drive everything from source control.</p>\n", "tags": ["azure", "powershell", "tfs", "azure-pipelines-release-pipeline"]}
