{"id": "9bb15317-db39-4dbf-8b06-4d15c8d0276b", "text": "Q: How can I delete all local Docker images? A: <p>To delete all images:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>docker rmi $(docker images -a -q)\n</code></pre>\n<p><em><strong>where -a is all, and -q is return only image IDs</strong></em></p>\n<p>To remove unused images and containers:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>docker system prune\n</code></pre>\n<p>Beware as if you are using Docker Swarm and your local machine is joining a remote swarm (as manager/worker), your local will be the deployed repo. Executing this thus removes the deployed images.</p>\n", "tags": ["docker", "docker-compose"]}
{"id": "7a90fb42-e385-48d3-a747-cb828a977929", "text": "Q: How to change Table Row category based on Slicer? A: <p>There is a much easier way using field parameters:</p>\n<p><a href=\"https://learn.microsoft.com/en-us/power-bi/create-reports/power-bi-field-parameters\" rel=\"nofollow noreferrer\">https://learn.microsoft.com/en-us/power-bi/create-reports/power-bi-field-parameters</a></p>\n", "tags": ["powerbi", "dax", "powerbi-desktop"]}
{"id": "20eea8dc-3eef-40de-8446-0112e0c41896", "text": "Q: QDockWidget initial width A: <p>if you have a lot of dockWidgets the simplest way to save and restore the whole window including hidden and floated widgets is the folowing:</p>\n<pre><code>void MainWindow::saveSettings()\n{\n    m_settings-&gt;setValue(&quot;/Window/geometry&quot;, saveGeometry());\n    m_settings-&gt;setValue(&quot;/Window/state&quot;, saveState());\n}\nvoid MainWindow::restoreSettings()\n{\n    restoreGeometry(m_settings-&gt;value(&quot;/Window/geometry&quot;).toByteArray());\n    restoreState(m_settings-&gt;value(&quot;/Window/state&quot;).toByteArray());\n}\n</code></pre>\n<p>and that's all/ the whole main window with all its child dockWidgets will get restored.</p>\n", "tags": ["c++", "qt", "qdockwidget"]}
{"id": "4834dd83-7f81-4400-b30c-9312de67fbab", "text": "Q: Why Aren&#39;t JoinSets with recursive calls `Send`? A: <p>This is <a href=\"https://github.com/rust-lang/rust/issues/123072\" rel=\"nofollow noreferrer\">a bug in the Rust compiler</a> related to recursive async functions in general, and doesn't have anything to do with <code>JoinSet</code>.  You can work around it by de-sugaring the <code>async fn</code> into a <code>fn</code> returning <code>impl Future + Send</code>:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn massively_parallel_fib(n: u64) -&gt; impl Future&lt;Output = u64&gt; + Send {\n    async move {\n        if n == 0 {\n            0\n        } else if n &lt;= 2 {\n            1\n        } else {\n            let mut set = JoinSet::new();\n            set.spawn(async move { massively_parallel_fib(n - 1).await });\n            set.spawn(async move { massively_parallel_fib(n - 2).await });\n            set.join_all().await.into_iter().sum()\n        }\n    }\n}\n</code></pre>\n<p>(<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a7aae2fd8ae9fdf9ee6ccea7d5f8dc3c\" rel=\"nofollow noreferrer\">Playground</a>)</p>\n<blockquote>\n<p>As an aside, is it true that <code>async move { massively_parallel_fib(n - 1).await }</code> is effectively the same as <code>massively_parallel_fib(n - 1)</code>? If not, what exactly is the difference?</p>\n</blockquote>\n<p>No, the former creates a new opaque future type that wraps the opaque future type returned by <code>massively_parallel_fib</code>.  Mostly what this means is you can't treat them as the same type.</p>\n<pre class=\"lang-rust prettyprint-override\"><code>let mut a = massively_parallel_fib(4);\n\n// This works.\na = massively_parallel_fib(3);\n\n// This fails: error[E0308]: mismatched types\na = async move { massively_parallel_fib(4).await };\n</code></pre>\n<p>It's also worth pointing out that <code>massively_parallel_fib(n - 1)</code> will (obviously) immediately call <code>massively_parallel_fib</code> while <code>async move { massively_parallel_fib(n - 1).await }</code> will not call <code>massively_parallel_fib</code> until the first time it is polled.</p>\n<p>In practice, and in your example in particular, this is unlikely to matter.  The wrapper future type generated by the <code>async</code> block <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=48055f03789cfdd5995872cac0eb38f2\" rel=\"nofollow noreferrer\">may be a bit larger</a> due to the addition of the compiler-generated state machine, but its generated <code>poll</code> function will almost certainly be optimized away.</p>\n<p>Having said that, I would consider it cleaner and more idiomatic to directly use the function's own future when possible and only wrap it in an <code>async</code> block when necessary.</p>\n", "tags": ["asynchronous", "rust", "rust-tokio"]}
{"id": "b338d1a6-4fdf-497f-a1a0-568c838eabba", "text": "Q: Strapi &quot;error: Couldn&#39;t send test email: Missing credentials for &quot;PLAIN&quot; A: <p>This error usually comes from <code>Nodemailer</code> complaining that the SMTP credentials are not being passed correctly.</p>\n<p>The issue could be caused by the typo in the configuration file. Change the following:</p>\n<p><code>defaultReplayTo</code> to <code>defaultReplyTo</code></p>\n<p><strong>Also do these checks:</strong></p>\n<ol>\n<li>Make sure all the environment variables you reference exist and are correct.</li>\n<li>Double-check the <code>Strapi</code> <code>config</code> format.</li>\n<li>Test credentials manually.</li>\n<li>Add <code>tls: { rejectUnauthorized: false }</code> if your SMTP server requires it.</li>\n</ol>\n<p><strong>Updated configurations:</strong></p>\n<pre class=\"lang-js prettyprint-override\"><code>export default ({ env }) =&gt; ({\n  email: {\n    config: {\n      provider: 'strapi-provider-email-nodemailer',\n      providerOptions: {\n        host: env('MAILRELAY_SMTP_HOST'),\n        port: env.int('MAILRELAY_SMTP_PORT'),\n        secure: env.bool('MAILRELAY_SMTP_SECURE'),\n        auth: {\n          user: env('MAILRELAY_SMTP_USER'),\n          pass: env('MAILRELAY_SMTP_PASS'),\n        },\n      },\n      settings: {\n        defaultFrom: env('SME_MAIL'),\n        defaultReplyTo: env('SME_MAIL'),\n      },\n    },\n  },\n});\n</code></pre>\n<p><strong>Provider options:</strong></p>\n<pre class=\"lang-js prettyprint-override\"><code>providerOptions: {\n  host: env('MAILRELAY_SMTP_HOST'),\n  port: env.int('MAILRELAY_SMTP_PORT'),\n  secure: env.bool('MAILRELAY_SMTP_SECURE'),\n  auth: {\n    user: env('MAILRELAY_SMTP_USER'),\n    pass: env('MAILRELAY_SMTP_PASS'),\n  },\n  tls: {\n    rejectUnauthorized: false,\n  },\n},\n</code></pre>\n", "tags": ["javascript", "typescript", "email", "strapi", "nodemailer"]}
