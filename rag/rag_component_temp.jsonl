{"id": "c8643d99-a1a1-464f-a8d0-11e56dbc5409", "text": "Q: multiprocessing.JoinableQueue.empty() seems broken A: <p>Outside of this particular implementation, in general you fundamentally can't rely on given <code>.qsize()</code>, <code>.full()</code>, <code>.empty()</code>, etc. methods for <em>any</em> queue implementation regardless of programming language when it can be filled or consumed in parallel to avoid a push or pull race - these methods at best only guarantee their own immediate status and do not inform you of the state of the queue under normal conditions, only an approximation of its state!</p>\n<hr />\n<p>Note that in the <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue\" rel=\"nofollow noreferrer\">official <code>multiprocessing.Queue</code> docs</a>, each of these length/fullness-checking methods expressly say <em><strong>this is not reliable</strong></em>!</p>\n<p>In your case, you're likely seeing that because these methods are not required by the specification to be reliable, that they have optimizations which behave unexpectedly when you try to misuse them beyond their scope. I have not looked at their internal behaviour, but they're free to have optimizations like updating at fixed times, only being accurate to the nearest N-hundred tasks, or interacting with the garbage collection subsystem, any of which could explain what you're seeing.. such optimizations are frequently used for improved performance when accuracy is not important</p>\n<p>Why have these methods at all then? They don't sound useful! While I suspect that in-part, they exist to mirror the <a href=\"https://docs.python.org/3/library/queue.html\" rel=\"nofollow noreferrer\"><code>queue.Queue()</code></a> spec (especially <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.JoinableQueue\" rel=\"nofollow noreferrer\"><code>multiprocessing.JoinableQueue</code></a>), they can be used for features like</p>\n<ul>\n<li>logging approximate full-ness over time</li>\n<li>rate detection to tune the number of producers or consumers</li>\n<li>managing error conditions where you're sure or suspect all the (other) consumers or producers are blocked</li>\n</ul>\n<hr />\n<p>If you need absolute knowledge of the content size of a queue <em>during</em> put and/or get, don't use any <code>multiprocessing.Queue</code>-like objects and instead create your own mini-implementation which combines a shared lock and list - the put/get performance will be lower, but it may not matter for your case and you'll have full control and knowledge of the length</p>\n<p>You can use <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Manager\" rel=\"nofollow noreferrer\"><code>multiprocessing.Manager</code></a> to create <a href=\"https://docs.python.org/3/library/multiprocessing.html#proxy-objects\" rel=\"nofollow noreferrer\">Proxy Objects</a> for this purpose, but beware they do have a few have caveats, such as being incomparable to normal lists (though I'm not certain exactly why, likely it's always <code>False</code> for performance).. there's also a somewhat-strange <a href=\"https://stackoverflow.com/a/60215330/4541045\"><code>multiprocessing.shared_memory.ShareableList</code></a>, which could be more performant, but is extraordinarily restricted by having a fixed length, only allows certain types, slice might not behave..</p>\n<pre class=\"lang-py prettyprint-override\"><code>def main():\n    M = multiprocessing.Manager()\n    m_list = M.list()\n    m_lock = M.lock()  # same as multiprocessing.Lock()\n\n    # Processes can just be a function named worker\n    workers = [multiprocessing.Process(worker, (m_list, m_lock)) for _ in range(WORKER_COUNT)]\n    for worker in workers:\n        worker.start()\n\n    # opportunity for host process to estimate queue depth normally\n    ...\n</code></pre>\n<hr />\n<p>Finally, you may find for many queued implementations that a <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.ThreadPool\" rel=\"nofollow noreferrer\"><code>multiprocessing.pool.ThreadPool</code></a> is actually both faster and more convenient, as while famously GIL-bound, the shared namespace avoids the overhead of pickling members back and forth repeatedly - another design which avoids this is providing a range or algorithm for jobs for workers to produce themselves internally instead, ideally only signaling completion or similar back to the main process</p>\n", "tags": ["python", "multithreading", "queue"]}
{"id": "96369732-5d7c-4686-97d6-ac0d2bf38e75", "text": "Q: Solving an equation containing a singularity in Boost odeint A: <p>Now, I still cannot see where you find the problem is singularity. Yes, there are singularities. But a numeric solution is always found for a certain set of concrete points.</p>\n<p>Analytically, you already know the points of singularities. Just dont try to find \u0430 solution in a certain <em>neighborhood</em> of a known singularity point. It would not make any sense anyway. What else could be a problem?</p>\n", "tags": ["boost", "odeint"]}
{"id": "b57081f5-461f-426a-a2ae-4d1bdad45b27", "text": "Q: Email notification when a new customer has been added A: <p>This is code for sending new customer email to Admin also <br>\nOverride file <br><code>\\app\\code\\core\\Mage\\Customer\\Model\\Customer.php</code> <br>to local<br> <code>\\app\\code\\local\\Mage\\Customer\\Model\\Customer.php</code></p>\n\n<p>Replace below function </p>\n\n<pre><code>protected function _sendEmailTemplate($template, $sender, $templateParams = array(), $storeId = null)\n    {\n        /** @var $mailer Mage_Core_Model_Email_Template_Mailer */\n        $mailer = Mage::getModel('core/email_template_mailer');\n        $emailInfo = Mage::getModel('core/email_info');\n        $emailInfo-&gt;addTo($this-&gt;getEmail(), $this-&gt;getName());\n        $mailer-&gt;addEmailInfo($emailInfo);\n\n        // Set all required params and send emails\n        $mailer-&gt;setSender(Mage::getStoreConfig($sender, $storeId));\n        $mailer-&gt;setStoreId($storeId);\n        $mailer-&gt;setTemplateId(Mage::getStoreConfig($template, $storeId));\n        $mailer-&gt;setTemplateParams($templateParams);\n        $mailer-&gt;send();\n        return $this;\n    }\n</code></pre>\n\n<p>to</p>\n\n<pre><code>protected function _sendEmailTemplate($template, $sender, $templateParams = array(), $storeId = null)\n    {\n        /** @var $mailer Mage_Core_Model_Email_Template_Mailer */\n        $mailer = Mage::getModel('core/email_template_mailer');\n        $emailInfo = Mage::getModel('core/email_info');\n        $emailInfo-&gt;addTo($this-&gt;getEmail(), $this-&gt;getName());\n\n        if($template=\"customer/create_account/email_template\"){\n\n            $emailInfo-&gt;addBcc(Mage::getStoreConfig('trans_email/ident_general/email'), $this-&gt;getName());\n              //Add email address in Bcc you want also to send\n        }\n\n        $mailer-&gt;addEmailInfo($emailInfo);\n\n\n        // Set all required params and send emails\n        $mailer-&gt;setSender(Mage::getStoreConfig($sender, $storeId));\n        $mailer-&gt;setStoreId($storeId);\n        $mailer-&gt;setTemplateId(Mage::getStoreConfig($template, $storeId));\n        $mailer-&gt;setTemplateParams($templateParams);\n        $mailer-&gt;send();\n        return $this;\n    }\n</code></pre>\n", "tags": ["magento"]}
{"id": "4cc09b54-977a-42f1-9899-15768c9d8637", "text": "Q: JQ - Converting JSON To JSONL Without Losing Original Object Structure A: <p>Use <code>to_entries</code> to decompose the top-level object into key/value pairs first, and then do the iteration. Eventually, re-compose each item into its own object by collecting the single item into a one-element array, and apply <code>from_entries</code> to it:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>jq -c 'to_entries[] | [.] | from_entries'\n</code></pre>\n<pre><code>{&quot;18003432343&quot;:{&quot;04:00:25&quot;:{....},&quot;12:00:25&quot;:{....}}}\n{&quot;18005553332&quot;:{&quot;18:11:25&quot;:{....},&quot;23:00:25&quot;:{....}}}\n</code></pre>\n<p><a href=\"https://play.jqlang.org/s/elKXHoO8xP1pXeA\" rel=\"nofollow noreferrer\">Demo</a></p>\n", "tags": ["json", "select", "filter", "jq"]}
{"id": "ffba6e09-3b69-47d9-ab04-c8daa17f9ec3", "text": "Q: Share a list between different processes? A: <p>the following is from <a href=\"https://docs.python.org/3/library/multiprocessing.shared_memory.html#multiprocessing.shared_memory.ShareableList\" rel=\"nofollow noreferrer\">python documentation</a>:</p>\n<pre><code>from multiprocessing import shared_memory\na = shared_memory.ShareableList(['howdy', b'HoWdY', -273.154, 100, None, True, 42])\n[ type(entry) for entry in a ]\n[&lt;class 'str'&gt;, &lt;class 'bytes'&gt;, &lt;class 'float'&gt;, &lt;class 'int'&gt;, &lt;class 'NoneType'&gt;, &lt;class 'bool'&gt;, &lt;class 'int'&gt;]\na[2]\n-273.154\na[2] = -78.5\na[2]\n-78.5\na[2] = 'dry ice'  # Changing data types is supported as well\na[2]\n'dry ice'\na[2] = 'larger than previously allocated storage space'\nTraceback (most recent call last):\n  ...\nValueError: exceeds available storage for existing str\na[2]\n'dry ice'\nlen(a)\n7\na.index(42)\n6\na.count(b'howdy')\n0\na.count(b'HoWdY')\n1\na.shm.close()\na.shm.unlink()\ndel a  # Use of a ShareableList after call to unlink() is unsupported\n</code></pre>\n", "tags": ["python", "list", "multiprocessing"]}
{"id": "cfa6522e-ec31-4ec7-b9d6-027cff42b5de", "text": "Q: VBA Create a macro to match items in a bank reconciliation - payment booking/ Bank debit A: <p>I'd split the algorithm down like this.</p>\n\n<ol>\n<li>User highlights the column used to group data; in your case, doc#</li>\n<li>VBA sorts the data by this column, which results in like-data appearing in adjacent rows</li>\n<li>VBA steps through the rows, looking at the group column for changes. When it finds a change it starts a new group. If it finds no-change, it expands the existing group to include the current row.</li>\n<li>VBA applies 'conditions' to each group. A condition might be \"Do all contents of column(5) (for a particular group) net/add to zero?\". Conditional results are stored in a new column as Yes, or No. Any number of conditions can be defined as will fit into new columns.</li>\n<li>Once conditional data is calculated and applied, you can do all the cosmetic stuff as a separate pass - it might be better to keep the original data in one place, and copy 'extracts' out to different spreadsheets, in case you want to rerun the reconciliation later. </li>\n</ol>\n\n<p>The advantage of writing it like this is that steps 1, 2 and 3 can be reused for almost any reconciliation you have to do in the future.\nWriting some code for parts 4 and 5 might be specific to your rec, but if you wrote it just so, you should be able to use as a template for future recs.</p>\n", "tags": ["excel", "accounting", "vba"]}
{"id": "988e696c-342c-49b3-bab3-7056ee7da1b2", "text": "Q: How can retrieve chain of certificates via openssl A: <p>I have no idea what exactly you mean by '.crt' or '.cer' format. If you copy those pieces of output between <strong>-----BEGIN CERTIFICATE-----</strong> and <strong>-----END CERTIFICATE-----</strong> and save them to a text file you will get a certificate chain file in PEM format (default for openssl). Your file should look something like this (2 certificates in the chain):</p>\n\n<pre><code>-----BEGIN CERTIFICATE-----\nMIIF/DCCBWWgAwIBAgIKUCYyawAAAAB1rzANBgkqhkiG9w0BAQUFADBGMQswCQYD\n&lt;the rest of the certificate 1&gt;\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIICsDCCAhmgAwIBAgIDC2dxMA0GCSqGSIb3DQEBBQUAME4xCzAJBgNVBAYTAlVT\n&lt;the rest of the certificate 2&gt;\n-----END CERTIFICATE-----\n</code></pre>\n", "tags": ["openssl"]}
