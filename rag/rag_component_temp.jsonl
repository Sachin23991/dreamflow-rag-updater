{"id": "d5c41b5b-6637-45e1-b340-9752eb329714", "text": "Q: Is the constant complexity requirement of begin() too strict for std::map? A: <p>The standard requires <code>begin()</code> to be constant time, and standard libraries do comply with this. The easiest way to do this is to store the leftmost node in a member.</p>\n<p>In libstdc++ for example, see <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_tree.h#L85C1-L89C23\" rel=\"noreferrer\">this comment</a>:</p>\n<pre><code>// (1) the header cell is maintained with links not only to the root\n// but also to the leftmost node of the tree, to enable constant\n// time begin(), and to the rightmost node of the tree, to enable\n// linear time performance when used with the generic set algorithms\n// (set_union, etc.)\n</code></pre>\n", "tags": ["c++", "iterator", "containers", "time-complexity", "stdmap"]}
{"id": "c40fb019-a7a5-4fe0-81a3-d5654ce085e7", "text": "Q: Vector is not updated, after performing a class method (c++) A: <p>You forgot to read the name of a hotel to query the size. Add code to read that.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>    } else if (query_type == &quot;CHECK&quot;) {\n      string hotel_name;\n      cin &gt;&gt; hotel_name; // add this\n      cout &lt;&lt; hotel.check_hotel_size(hotel_name) &lt;&lt; &quot;\\n&quot;;\n    }\n</code></pre>\n<p>This fix should also be done for <code>&quot;CLIENTS&quot;</code> and <code>&quot;ROOMS&quot;</code>.</p>\n", "tags": ["c++"]}
{"id": "12734dc3-ef3b-4fa0-847b-406efd0f5713", "text": "Q: Problem with js function for Leaflet Marker Cluster A: <p>The problem is that you\u2019re mixing plug-ins.</p>\n<p>The catch: in your code, <code>geojsonPoints</code> is a <code>L.GeoJSON.AJAX</code> layer, but the event you want is actually called <code>data:loaded</code> on the AJAX plug-in object. If you\u2019re using the latest <code>leaflet-ajax</code>, the correct event name is:</p>\n<pre class=\"lang-js prettyprint-override\"><code>geojsonPoints.on('data:loaded', function () { console.log('Hello1'); clusterM.addLayer(geojsonPoints); map.addLayer(clusterM); });\n</code></pre>\n<p>Example code:</p>\n<pre class=\"lang-html prettyprint-override\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;title&gt;Leaflet&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet/dist/leaflet.css&quot; /&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css&quot; /&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css&quot; /&gt;\n    &lt;style&gt;\n        #map { height: 100vh; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;https://unpkg.com/leaflet/dist/leaflet.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://unpkg.com/leaflet-ajax/dist/leaflet.ajax.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script&gt;\n        var map = L.map('map').setView([46.8, 8.3], 7);\n        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);\n        var clusterM = L.markerClusterGroup();\n        var geojsonPoints = new L.GeoJSON.AJAX(&quot;Files/Coordinates/coordonate_rk.geojson&quot;, {\n            pointToLayer: function (feature, latlng) {\n                return L.circleMarker(latlng, { radius: 6, fillColor: &quot;#ff7800&quot;, color: &quot;#000&quot;, weight: 1, opacity: 1, fillOpacity: 0.8 });\n            },\n            onEachFeature: function (feature, layer) {\n                layer.bindPopup(&quot;Servicii: &quot; + feature.properties.Servicii);\n            }\n        });\n        geojsonPoints.on('ready', function () {\n            console.log(&quot;GeoJSON loaded&quot;);\n            clusterM.addLayer(geojsonPoints);\n            map.addLayer(clusterM);\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n", "tags": ["javascript", "leaflet", "leaflet.markercluster"]}
{"id": "546f95b3-c0f1-4dbc-a44b-d5e31acd4229", "text": "Q: How to explicitly refer to a function/class in a python module to avoid naming collision A: <p>Side-note on that though loosly related ... I already had to somehow self-import with <code>__future__</code>to ensure return type with annotations before even definying for <code>Unit</code>:</p>\n<pre><code>## --- Imports\nfrom __future__ import annotations  ### To return correct type in 'GetKnownUnits' because Unit is defined later\nfrom enum import Enum\n\nclass Metric(StrEnum):\n#[\n    ## Enumeration constants\n    # ...\n\n    # Helpers\n    def GetKnownUnits(self) -&gt; set[Unit]:\n    #[\n        knownUnits = set()\n        for uu in Unit:\n            if (uu.Metric == self):\n                knownUnits.add(uu)\n        return knownUnits\n    #]\n#] \n</code></pre>\n", "tags": ["python", "name-collision"]}
{"id": "3b544b5f-a905-4a78-b54a-883d7d18af04", "text": "Q: WeasyPrint + pypdf: visible, non-editable escape characters on parentheses A: <p>You are already calling <code>update_page_form_field_values(auto_regenerate=False)</code>. To fix the bad <code>/AP</code>, let pypdf rebuild them:</p>\n<pre><code>for page in writer.pages: \n    writer.update_page_form_field_values(page, data, auto_regenerate=True)\n</code></pre>\n<p>Kindly note that the document\u2019s <code>/AcroForm</code> has a Default Appearance (<code>/DA</code>) and Default Resources (<code>/DR</code>) so viewers can render without guesswork.</p>\n<pre><code>from pypdf.generic import (\n    DictionaryObject, NameObject, TextStringObject, BooleanObject\n)\n\nroot = writer._root_object\nacroform = root.get(NameObject(&quot;/AcroForm&quot;))\nif acroform is None:\n    acroform = DictionaryObject()\n    root[NameObject(&quot;/AcroForm&quot;)] = acroform\n\nacroform[NameObject(&quot;/DA&quot;)] = TextStringObject(&quot;/Helv 10 Tf 0 g&quot;)\n\n# Provide default resources (at least Helvetica)\nfont_helv = DictionaryObject()\nfont_helv.update({\n    NameObject(&quot;/Type&quot;): NameObject(&quot;/Font&quot;),\n    NameObject(&quot;/Subtype&quot;): NameObject(&quot;/Type1&quot;),\n    NameObject(&quot;/BaseFont&quot;): NameObject(&quot;/Helvetica&quot;),\n})\nfont_helv_ref = writer._add_object(font_helv)\n\ndr = acroform.get(NameObject(&quot;/DR&quot;))\nif dr is None:\n    dr = DictionaryObject()\n    acroform[NameObject(&quot;/DR&quot;)] = dr\n\nfont_dict = dr.get(NameObject(&quot;/Font&quot;))\nif font_dict is None:\n    font_dict = DictionaryObject()\n    dr[NameObject(&quot;/Font&quot;)] = font_dict\n\nfont_dict[NameObject(&quot;/Helv&quot;)] = font_helv_ref\n\nif NameObject(&quot;/NeedAppearances&quot;) in acroform:\n    del acroform[NameObject(&quot;/NeedAppearances&quot;)]\n</code></pre>\n<p>If you previously set <code>NeedAppearances</code>, you can remove it because we regenerated <code>/AP</code>. Then merge the (now properly rendered) form page into your 4 page template, exactly as you already do. Because the form page has correct appearance streams, the merged content looks right across viewers.</p>\n<p>Other options could be to Flatten the fields to pure page content or dont use <code>AcroForm</code> at all for the overlay. If your final document never needs to be interactive, skip <code>pdf_forms=True</code> in WeasyPrint and render the overlay as normal text in HTML. Then you\u2019re just merging a regular PDF page - no <code>/V</code>, no <code>/AP</code>, no viewer-dependent rendering, and parentheses are handled like any other text by WeasyPrint\u2019s typesetting.</p>\n<pre><code>empty_form_pdf = HTML(string=html_form).render(pdf_forms=False).write_pdf()\n# no fill step needed. Your HTML should already contain the resolved text\n</code></pre>\n<p>Keep in mind that to always embed or reference a standard font (e.g., Helvetica) in <code>/AcroForm/DR</code> when relying on viewer-generated appearances.</p>\n<p>After merging pages, if any annotations survived (they shouldn\u2019t if you flatten first), remove them to avoid invisible but interactive artifacts and Make sure you run the <strong>fill + appearance regeneration</strong> before you perform your merge; the merge will capture the correct drawn content.</p>\n<p>Hope it gives you the clarity.</p>\n", "tags": ["python", "pdf", "pypdf", "weasyprint"]}
