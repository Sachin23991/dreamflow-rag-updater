{"id": "f82f50ff-f7cf-4673-8f7b-09cc65ade4bb", "text": "Q: Firestore collection -&gt; doc -&gt; collection returning empty list in flutter A: <p>Please set at least one property field for <code>profiles/default</code>, otherwise Firestore won't list any of its sub-collections.</p>\n<p><strong>Firestore will only list documents in a collection if those documents actually exist with at least one field set.</strong></p>\n<p>If there's no fields set to the documents, Firestore treats that document as basically non-existent, hence this is an expected result.</p>\n", "tags": ["flutter", "firebase", "dart", "google-cloud-firestore"]}
{"id": "59363b34-f9a4-4c1e-8fb8-3df9b5bd73df", "text": "Q: What are references, instruction and examples for the simplest way of building clang from this LLVM project on Windows? A: <p>It is not useful to just report that you didn't find anything or to point to complete other resources expecting us to guess what was relevant &amp; why. Explain your search &amp; paraphrase or quote with credit exactly what is relevant &amp; say why. (Like always: Put only &amp; all info needed to ask &amp; relate it to your question.)</p>\n", "tags": ["c++", "cmake", "reflection", "compilation", "clang"]}
{"id": "6fe18b58-2557-457c-a5e0-84d3194d8f8e", "text": "Q: How do you replace multiple elements of an array in C with elements of a different array A: <p>It is often best to use a loop for this sort of thing because that is usually more clear and less error-prone.</p>\n<p>But if you have reasons for avoiding a loop you can use either <code>memcpy</code> or <code>memmove</code>. <code>memcpy</code> copies a number of bytes pointed to by its second argument to the storage pointed to by its first argument. Often compilers will optimize looping code that fills an array into a call to <code>memcpy</code>, so it is unlikely that using a loop to fill <code>foo</code> as in the OP code would have a performance penalty.</p>\n<p>Note that you shouldn't use <code>memcpy</code> of you are copying to overlapping storage, i.e., copying bytes from an array to itself: attempting to do so leads to undefined behavior. In such cases you can use <code>memmove</code> which can safely copy bytes to overlapping storage.</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // for `memcpy` and `memmove`\n\nint main(void) {\n  int foo[3];\n  int bar[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} ;\n\n  /* Using `memcpy` to copy from `bar` to `foo`. */\n  memcpy(foo, bar, sizeof *bar * 3);\n\n  for (int i = 0; i &lt; 3; i++) {\n    printf(&quot;%d &quot;, foo[i]);\n  }\n  putchar('\\n');\n\n  memcpy(&amp;foo[1], &amp;bar[6], sizeof *bar * 2);\n  for (int i = 0; i &lt; 3; i++) {\n    printf(&quot;%d &quot;, foo[i]);\n  }\n  putchar('\\n');\n\n  /* Using `memmove` to copy from `bar` to itself. */\n  memmove(&amp;bar[2], &amp;bar[5], sizeof *bar * 4);\n  for (int i = 0; i &lt; 10; i++) {\n    printf(&quot;%d &quot;, bar[i]);\n  }\n  putchar('\\n');\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>$ gcc -std=c17 -Wall -Wextra -Wpedantic memcpy_example.c\n\n$ ./a.exe\n1 2 3\n1 7 8\n1 2 6 7 8 9 7 8 9 10\n</code></pre>\n", "tags": ["arrays", "c", "pointers"]}
{"id": "f912db7c-473f-4702-985b-d76e862a4a01", "text": "Q: Handle many broadcast receivers A: <p>It actually works.</p>\n<p>I've should set passing data method from barcode scanners on each device to broadcast receiver (in device settings).</p>\n<p>Now it works well on all 3 devices</p>\n", "tags": ["c#", "android", "maui", "broadcastreceiver"]}
{"id": "93446ac1-ba25-4133-badb-22b9ab0ac909", "text": "Q: ASIC chip change A: <p><strong>IF</strong> the ASIC has ROM.  Some designs do, many do not.  And, of course, you would have to have complete and detailed documentation on the internals of the ASIC, which you almost never have.</p>\n<p>This is not an idea that is worth pursuing.</p>\n", "tags": ["cryptocurrency"]}
{"id": "10e661f3-3867-4b72-b938-26c7cadc7faa", "text": "Q: if(!isset($_SESSION[&#39;username&#39;])) causing users to be redirected from verify_login_form.php back to index.php A: <p>&lt;?php</p>\n<p>session_start();</p>\n<p>if (!isset($_SESSION['login'])) {</p>\n<pre><code>header(&quot;Location: login.php&quot;);\n\nexit;\n</code></pre>\n<p>}</p>\n<p>?&gt;</p>\n<p>&lt;!DOCTYPE html&gt;</p>\n<p>&lt;html&gt;</p>\n<p>&lt;head&gt;</p>\n<pre><code>\\&lt;title\\&gt;Home Admin\\&lt;/title\\&gt;\n</code></pre>\n<p>&lt;/head&gt;</p>\n<p>&lt;body&gt;</p>\n<p>&lt;h2&gt;Berhasil Masuk ke Halaman Home Admin&lt;/h2&gt;</p>\n<p>&lt;p&gt;Login berhasil dan tombol login berfungsi dengan benar.&lt;/p&gt;</p>\n<p>&lt;a href=&quot;logout.php&quot;&gt;Logout&lt;/a&gt;</p>\n<p>&lt;/body&gt;</p>\n<p>&lt;/html&gt;</p>\n", "tags": ["php", "html", "mysql"]}
{"id": "9c16771d-e91a-4c8e-9503-46bc8a206dd8", "text": "Q: Instantiation of type with recursive type constraints A: <p>The <code>Number</code> class in this example is a bit pointless, since it does nothing but reimplement addition, but here's an example that shows how it can be instantiated:</p>\n<pre class=\"lang-ml prettyprint-override\"><code>type MyType = MyInt of int with\n    interface IAddition&lt;MyType&gt; with\n        static member (+)(MyInt a, MyInt b) =\n            MyInt (a + b)\n\nlet x = Number(MyInt 1)\n</code></pre>\n<p>Note that <code>MyType</code> implements <code>IAddition&lt;MyType&gt;</code>, which means it can be wrapped via <code>Number</code>. As Fyodor mentioned, there is no infinite regress.</p>\n<p>As far as I know, there is no difference between <code>'T when 'T :&gt; IAddition&lt;'T&gt;</code> and <code>'T when IAddition&lt;'T&gt;</code>, but I could be wrong. The second form is not well documented, I think.</p>\n", "tags": ["generics", "interface", "f#", "operators"]}
