{"id": "adc08401-a06b-46e5-a742-da02c4bf1191", "text": "Q: Android APK to a streaming website A: <p>From my personal experience working with Android APKs and streaming platforms, yes, it is possible to stream live video from an Android APK to a streaming website, but not in the way many beginners expect.</p>\n<p>There is no direct \u201cUstream APK\u201d that you can simply plug into your code and start broadcasting. Instead, most live streaming apps work by capturing video from the phone\u2019s camera and then sending it to a streaming server using protocols like RTMP or HLS. On the website side, platforms such as Ustream (now IBM Video Streaming) provide APIs or stream keys that your app can connect to.</p>\n<p>I\u2019ve seen developers successfully do this by:</p>\n<p>Capturing live camera video inside the Android app</p>\n<p>Encoding it in real time</p>\n<p>Sending it to a streaming service using their SDK or RTMP endpoint</p>\n<p>If you are building or testing such APKs, I strongly recommend downloading libraries or example APKs only from safe APK sites or official developer sources. In my experience, unofficial APKs often contain outdated code or security risks that can break streaming or even compromise user data.</p>\n<p>So, technically it can be done via code, but it requires backend setup, proper streaming protocols, and trusted tools. Simply installing an APK without server-side integration won\u2019t be enough to turn an Android app into a full streaming website solution.</p>\n", "tags": ["android"]}
{"id": "c1cae4a8-1350-4d64-90c6-4bc8a29f4684", "text": "Q: Most efficient T-SQL way to pad a varchar on the left to a certain length? A: <p>I use this so I can copy a table with variable length values, like names, and past it into an email without skewing the columns:</p>\n<pre><code>CAST([FirstName] AS CHAR(20)) AS [PaddedFirstName]\n</code></pre>\n", "tags": ["sql", "sql-server", "t-sql"]}
{"id": "12d7aeb8-f850-4bb9-b589-46ba7a6fc2aa", "text": "Q: Best practices for architecting a Go CLI with ~100 commands and many flags, how to organize commands/flags? A: <p>I don't understand exactly what you mean. Can you explain better?</p>\n", "tags": ["go", "design-patterns", "command-line-interface"]}
{"id": "a4f13e35-1c14-41a4-96ea-704d3ce38143", "text": "Q: Reading a 64-bit variable that is updated by an ISR A: <blockquote>\n<p>Is there a \u201cstandard\u201d or idiomatic way of handling this so that the reader function will not get a half-updated value?</p>\n</blockquote>\n<p>You need to use what I call <em>&quot;atomic access guards&quot;</em>, or <em>&quot;interrupt guards&quot;</em>. This is an area of interest of mine that I have spent a <em>ton</em> of time learning about and using in microcontrollers of various types.</p>\n<p><a href=\"https://stackoverflow.com/a/71625379/4561887\">@chux - Reinstate Monica, is correct</a>, but here's some additional clarity I want to make:</p>\n<h2>For <strong>reading</strong> from volatile variables, make copies in order to read quickly:</h2>\n<p>Minimize time with the interrupts off by quickly <em>copying</em> out the variable, and then using the copy in your calculation:</p>\n<pre class=\"lang-c prettyprint-override\"><code>// ==========\n// Do this:\n// ==========\n\n// Global volatile variables for use in ISRs\nvolatile uint64_t u1;\nvolatile uint64_t u2;\nvolatile uint64_t u3;\n\nint main()\n{\n    // Main loop\n    while (true)\n    {\n        uint64_t u1_copy;\n        uint64_t u2_copy;\n        uint64_t u3_copy;\n\n        // Use atomic access guards to copy out the volatile variables\n\n        // 1. Save the current interrupt state\n        const uint32_t INTERRUPT_STATE_BAK = INTERRUPT_STATE_REGISTER;\n\n        // 2. Turn interrupts off\n        interrupts_off();\n\n        // Copy your volatile variables out\n        u1_copy = u1;\n        u2_copy = u2;\n        u3_copy = u3;\n\n        // 3. Restore the interrupt state to what it was before disabling\n        //    it. This leaves interrupts disabled if they were previously\n        //    disabled (example: inside an ISR where interrupts get\n        //    disabled by default as it enters--not all ISRs are this way,\n        //    but many are, depending on your device), and it re-enables\n        //    interrupts if they were previously enabled. Restoring\n        //    interrupt state rather than enabling interrupts is the right\n        //    way to do it, and it enables this atomic access guard style\n        //    to be used both inside inside **and** outside ISRs.\n        //\n        INTERRUPT_STATE_REGISTER = INTERRUPT_STATE_BAK;\n\n        // Now use your copied variables in any calculations\n    }\n}\n\n// ==========\n// NOT this!\n// ==========\n\nvolatile uint64_t u1;\nvolatile uint64_t u2;\nvolatile uint64_t u3;\n\nint main()\n{\n    // Main loop\n    while (true)\n    {\n        // 1. Save the current interrupt state\n        const uint32_t INTERRUPT_STATE_BAK = INTERRUPT_STATE_REGISTER;\n\n        // 2. Turn interrupts off\n        interrupts_off();\n\n        // Now use your volatile variables in any long calculations\n        // - This is not as good as using copies! This would leave\n        //   interrupts off for an unnecessarily long time, introducing\n        //   a ton of jitter into your measurements and code.\n\n        // 3. Restore the interrupt state to what it was before disabling it.\n        INTERRUPT_STATE_REGISTER = INTERRUPT_STATE_BAK;\n    }\n}\n</code></pre>\n<h2>For <strong>writing</strong> to volatile variables, write quickly:</h2>\n<p>Minimize time with the interrupts off by quickly only disabling them while updating the volatile variables:</p>\n<pre class=\"lang-c prettyprint-override\"><code>// Global volatile variables for use in ISRs\nvolatile uint64_t u1;\nvolatile uint64_t u2;\nvolatile uint64_t u3;\n\nint main()\n{\n    // Main loop\n    while (true)\n    {\n        // Do calculations here, **outside** the atomic access interrupt guards\n\n        const uint32_t INTERRUPT_STATE_BAK = INTERRUPT_STATE_REGISTER;\n        interrupts_off();\n\n        // Quickly update your variables and exit the guards\n        u1 = 1234;\n        u2 = 2345;\n        u3 = 3456;\n        INTERRUPT_STATE_REGISTER = INTERRUPT_STATE_BAK;\n    }\n}\n</code></pre>\n<h2>Alternative: <em>lock-free atomic reads</em> via a repeat read loop: <code>doAtomicRead()</code>: ensure atomic reads withOUT turning interrupts off!</h2>\n<p>An alternative to using <em>atomic access guards</em>, as shown above, is to read the variable repeatedly until it doesn't change, indicating that the variable was <em>not</em> updated mid-read after you read only some bytes of it.</p>\n<p><em>Note that this works on memory chunks of <em>any</em> size. The <code>uint64_t</code> type used in my examples below could instead be a <code>struct my_struct</code> of dozens or hundreds of bytes even. It is not limited to any size. <code>doAtomicRead()</code> still works.</em></p>\n<p>Here is that approach. @Brendan and @chux-ReinstateMonica and I discussed some ideas of it under <a href=\"https://stackoverflow.com/a/71625379/4561887\">@chux-ReinstateMonica's answer</a>.</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdint.h&gt;  // UINT64_MAX\n\n#define MAX_NUM_ATOMIC_READ_ATTEMPTS 3\n\n// Errors\n#define ATOMIC_READ_FAILED (UINT64_MAX)\n\n/// @brief  Use a repeat-read loop to do atomic-access reads of a\n///         volatile variable, rather than using atomic access\n///         guards which disable interrupts.\nuint64_t doAtomicRead(const volatile uint64_t* val)\n{\n    uint64_t val_copy;\n    uint64_t val_copy_atomic = ATOMIC_READ_FAILED;\n\n    for (size_t i = 0; i &lt; MAX_NUM_ATOMIC_READ_ATTEMPTS; i++)\n    {\n        val_copy = *val;\n        if (val_copy == *val)\n        {\n            val_copy_atomic = val_copy;\n            break;\n        }\n    }\n\n    return val_copy_atomic;\n}\n</code></pre>\n<p>If you want to understand deeper, here is the same <code>doAtomicRead()</code> function again, but this time with extensive explanatory comments. I also show a commented-out slight variation to it which may be helpful in some cases, as explained in the comments.</p>\n<pre class=\"lang-c prettyprint-override\"><code>/// @brief    Use a repeat-read loop to do atomic-access reads of a\n///           volatile variable, rather than using atomic access\n///           guards which disable interrupts.\n///\n/// @param[in]   val    Ptr to a volatile variable which is updated\n///                     by an ISR and needs to be read atomically.\n///\n/// @return    A copy of an atomic read of the passed-in variable,\n///            if successful, or sentinel value ATOMIC_READ_FAILED\n///            if the maximum number of attempts to do the atomic\n//             read was exceeded.\nuint64_t doAtomicRead(const volatile uint64_t* val)\n{\n    uint64_t val_copy;\n    uint64_t val_copy_atomic = ATOMIC_READ_FAILED;\n\n    // In case we get interrupted during this code block, and `val` gets updated\n    // in that interrupt's ISR, try `MAX_NUM_ATOMIC_READ_ATTEMPTS` times to get\n    // an atomic read of `val`.\n    for (size_t i = 0; i &lt; MAX_NUM_ATOMIC_READ_ATTEMPTS; i++)\n    {\n        val_copy = *val;\n\n        // An interrupt could have fired mid-read while doing the **non-atomic**\n        // read above, updating the 64-bit value in the ISR and resulting in\n        // 32-bits of the old value in the 64-bit variable being wrong now\n        // (since the whole 64-bit value has just been updated with a new\n        // value), so verify the read above with a new read again.\n        //\n        // Caveat:\n        //\n        // Note that this method is **not _always_** foolproof, as technically\n        // the interrupt could fire off and run again during this 2nd read,\n        // causing a very rare edge-case where the exact same incorrect value\n        // gets read again, resulting in a false positive where it assigns an\n        // erroneous value to `val_copy_atomic`! HOWEVER, that is for **you or\n        // I** to design and decide as the architect.\n        //\n        // Is it _possible_ for the ISR to really fire off again immediately\n        // after returning? Or, would that never happen because we are\n        // guaranteed some minimum time gap between interrupts? If the former,\n        // you should read the variable again a 3rd or 4th time by uncommenting\n        // the extra code block below in order to check for consistency and\n        // minimize the chance of an erroneous `val_copy_atomic` value. If the\n        // latter, however, and you know the ISR won't fire off again for at\n        // least some minimum time value which is large enough for this 2nd\n        // read to occur **first**, **before** the ISR gets run for the 2nd\n        // time, then you can safely say that this 2nd read is sufficient, and\n        // you are done.\n        //\n        if (val_copy == *val)\n        {\n            val_copy_atomic = val_copy;\n            break;\n        }\n\n        // Optionally, delete the &quot;if&quot; statement just above and do this instead.\n        // Refer to the long &quot;caveat&quot; note above to see if this might be\n        // necessary. It is only necessary if your ISR might fire back-to-back\n        // with essentially zero time delay between each interrupt.\n        // for (size_t j = 0; j &lt; 4; j++)\n        // {\n        //     if (val_copy == *val)\n        //     {\n        //         val_copy_atomic = val_copy;\n        //         break;\n        //     }\n        // }\n    }\n\n    return val_copy_atomic;\n}\n</code></pre>\n<p>The above could be optimized to only obtain a new reading of <code>*val</code> <em>only once per iteration</em>, instead of twice, by adding one extra read before the start of the loop, and reading only once in the loop, like this:</p>\n<p><strong>[This is my favorite version:]</strong></p>\n<pre class=\"lang-c prettyprint-override\"><code>uint64_t doAtomicRead(const volatile uint64_t* val)\n{\n    uint64_t val_copy_new;\n    uint64_t val_copy_old = *val;\n    uint64_t val_copy_atomic = ATOMIC_READ_FAILED;\n\n    for (size_t i = 0; i &lt; MAX_NUM_ATOMIC_READ_ATTEMPTS; i++)\n    {\n        val_copy_new = *val;\n        if (val_copy_new == val_copy_old)\n        {\n            // No change in the new reading, so we can assume the\n            // read was not interrupted during the first reading\n            val_copy_atomic = val_copy_new;\n            break;\n        }\n        // Update the old reading, to compare it with\n        // the new reading in the next iteration\n        val_copy_old = val_copy_new;\n    }\n\n    return val_copy_atomic;\n}\n</code></pre>\n<p>General usage Example of <code>doAtomicRead()</code>:</p>\n<pre class=\"lang-c prettyprint-override\"><code>// Global volatile variable shared between ISRs and main code\nvolatile uint64_t u1;\n\n// Inside your function: &quot;atomically&quot; read and copy the volatile variable\nuint64_t u1_copy = doAtomicRead(&amp;u1);\nif (u1_copy == ATOMIC_READ_FAILED)\n{\n    printf(&quot;Failed to atomically read variable `u1`.\\n&quot;);\n\n    // Now do whatever is appropriate for error handling; examples:\n    goto done;\n\n    // OR:\n    return;\n    // etc.\n}\n</code></pre>\n<p>This requires the writer to be atomic with respect to any readers, which is true, for example, in the case of a single writer writing to this variable. This write might occur inside an ISR, for example.  We're detecting only torn <em>reads</em> (due to the <em>reader</em> being interrupted) and retrying.  If the 64-bit value was ever already in a torn written state in memory when this reader ran, the reader could erroneously see it as valid.</p>\n<p>A <a href=\"https://stackoverflow.com/a/54611235/4561887\">SeqLock</a> doesn't have that limitation, so is useful for multi-core cases. But, if you don't need that (ex: you have a single-core microcontroller), it is probably less efficient, and the <code>doAtomicRead()</code> trick works just fine.</p>\n<p>For the special edge case of a monotonically-incrementing counter (<strong>not</strong> for a variable which can be updated with any value, such as a variable storing a sensor reading!), <a href=\"https://stackoverflow.com/questions/71624109/reading-a-64-bit-variable-that-is-updated-by-an-isr/71625693#comment126587664_71625379\">as Brendan suggested here</a> you only need to re-read the most-significant half of the 64-bit value and check that it didn't change. So, to (probably) slightly improve the efficiency of the <code>doAtomicRead()</code> function above, update it to do that. The only possible tearing (unless you miss 2^32 counts) is when the low half wraps and the high half gets incremented. This is like checking the whole thing, but retries will be even less frequent.</p>\n<h2>Using <code>doAtomicRead()</code> in FreeRTOS</h2>\n<ol>\n<li>A single FreeRTOS task gathers sensor data from all sensors (via SPI, I2C, serial UART, ADC readings, etc). It writes into shared <code>volatile</code> global variables encapsulated in a module, so they don't feel like global variables. This is a &quot;shared memory&quot; multi-threaded model. These variables are not required to be atomic. Setters and getters are provided for all variables. ONLY this one task can write into the variables. <strong>It must be a higher-priority than the reader tasks for this to work properly. ie: by being a higher-priority task than the consumers, it emulates being in a protected ISR, and is able to <em>write</em> atomically with respect to the readers/consumers</strong>.</li>\n<li>Lower-priority reader tasks can read the data. They use my lockless <code>doAtomicRead()</code> function as described above. Note that this works on memory chunks of <em>any</em> size. The <code>uint64_t</code> type used in my example could be a struct of dozens or hundreds of bytes even. It is not limited to any size.</li>\n<li>That's it! No semaphores, locks, or mutexes are required, whatsoever. One task &quot;produces&quot; data. All other tasks consume it, lock-free. This is a <strong>single-producer, multi-consumer model.</strong></li>\n<li>It drops data, which is okay for most sensor data. In other words, the producer is always overwriting the values with the latest data, and the consumers are only getting the latest data. If any moving averages or filters need to be conducted with no lost data on the input to the filters, this filtering should be conducted by the producer task prior to storing the data into the shared memory to be consumed by the consumers.</li>\n</ol>\n<h2>Going further on this topic of <em>atomic access guards</em>, <em>disabling interrupts</em>, etc.</h2>\n<ol>\n<li><p>My <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/c/containers_ring_buffer_FIFO_GREAT.c\" rel=\"nofollow noreferrer\">c/containers_ring_buffer_FIFO_GREAT.c</a> demo from my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/tree/master\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo. Description of this code example from my comments at the top of this file:</p>\n<blockquote>\n<p>Demonstrate a basic, efficient <strong>lock-free</strong> SPSC (Single-Producer Single-Consumer) ring buffer FIFO\nqueue in C (that also runs in C++).</p>\n<p>This queue is intended to work lock-free in a SPSC context only, such as on a bare-metal\nmicrocontroller where an ISR needs to send data to the main loop, for example.</p>\n</blockquote>\n</li>\n<li><p>[Peter Cordes's answer on the <a href=\"https://en.wikipedia.org/wiki/Seqlock\" rel=\"nofollow noreferrer\"><strong>SeqLock</strong></a> (&quot;sequence lock&quot;) pattern] <a href=\"https://stackoverflow.com/a/54611235/4561887\">Implementing 64 bit atomic counter with 32 bit atomics</a></p>\n</li>\n<li><p>[my answer] <a href=\"https://stackoverflow.com/a/39693278/4561887\">C++ decrementing an element of a single-byte (volatile) array is not atomic! WHY? (Also: how do I force atomicity in Atmel AVR mcus/Arduino)</a></p>\n</li>\n<li><p><a href=\"https://arduino.stackexchange.com/a/77579/7727\">My long and detailed answer</a> on <strong>Which Arduinos support ATOMIC_BLOCK?</strong> and:</p>\n<ol>\n<li>How are the ATOMIC_BLOCK macros implemented in C with the gcc compiler, and where can I see their source code?, and</li>\n<li>How could you implement the ATOMIC_BLOCK functionality in Arduino in C++ (as opposed to avrlibc's gcc C version)?</li>\n<li>I explain in detail how this really clever <em>atomic access guard macro</em> works in C via gcc extensions, and how it could easily be implemented in C++:\n<pre class=\"lang-c prettyprint-override\"><code>ATOMIC_BLOCK(ATOMIC_RESTORESTATE)\n{\n    my_var_copy = my_var;\n}\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>[my Q&amp;A] <a href=\"https://stackoverflow.com/a/52785864/4561887\">Which variable types/sizes are atomic on STM32 microcontrollers?</a></p>\n<ol>\n<li>Not all variables <em>need</em> atomic access guards for simple reads and writes (for increment/decrement they ALWAYS do!--see my first link in this list above!), as some variables have <em>naturally atomic reads and writes</em> for a given architecture.\n<ol>\n<li><strong>For 8-bit AVR microcontrollers (like ATmega328 on Arduino Uno): 8-bit variables have <em>naturally atomic reads and writes</em>.</strong></li>\n<li><strong>For 32-bit STM32 microcontrollers, all non-struct (simple) types 32-bits and smaller have <em>naturally atomic reads and writes</em>.</strong> See my answer above for details and source documentation and proof.</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Techniques to disable interrupts on STM32 mcus: <a href=\"https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/\" rel=\"nofollow noreferrer\">https://stm32f4-discovery.net/2015/06/how-to-properly-enabledisable-interrupts-in-arm-cortex-m/</a></p>\n</li>\n<li><p>[my answer] <a href=\"https://arduino.stackexchange.com/a/77512/7727\">global volatile variable not being updated in ISR: How to recognize and fix race conditions in Arduino by using atomic access guards:</a></p>\n</li>\n<li><p>[my answer] <a href=\"https://stackoverflow.com/a/71626598/4561887\">What are the various ways to disable and re-enable interrupts in STM32 microcontrollers in order to implement atomic access guards?</a></p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock</a></p>\n</li>\n</ol>\n", "tags": ["c", "embedded", "atomic", "interrupt"]}
{"id": "2d26ad1b-2e52-457e-9577-0fd010e62cd2", "text": "Q: How can I use atomic variables in C? A: <p>I am going to toss in my two cents in case someone benefits.  Atomic operations are a major problem on Linux.  I used gatomic.h at one time, only to find it is gone.  I see all kinds of different atomic options of either questionable reliability or availability -- and I see things changing all the time.  They can be complex with tests needed by O/S level, processor, whatever.  You can use a mutex -- not only complex by dreadfully slow.</p>\n<p>Although perhaps not ideal in threads, this works great for atomic operations on shared memory variables.  It is simple, and it works on every O/S and processor and configuration known to man (or woman), dead reliable, easy to code, and will always work.</p>\n<p>Any code can be made atomic with a simple primitive -- a semaphore.  It is something that is true/false, 1/0, yes/no, locked/unlocked -- binary.</p>\n<p>Once you establish the semaphore:</p>\n<pre><code>set semaphore   //must be atomic\n</code></pre>\n<p>do all the code you like, which will be atomic as the semaphore will block for you</p>\n<pre><code>release semaphore  //must be atomic\n</code></pre>\n<p>Relatively straight forward except the &quot;must be atomic&quot; lines.</p>\n<p>It turns out that you easily assign your semaphores a number. I use a <code>#define</code> so they have a name like <code>#define OPEN_SEM 1</code> and <code>#define &quot;CLASS_SEM 2</code> and so forth.</p>\n<p>Find out your largest number and when your program initializes, open a file in some directory (I use one just for this purpose).  If it does not exist, create it:</p>\n<pre><code>if (ablockfd &lt; 0) {         //ablockfd is static in case you want to \n                            //call it over and over           \n    char *get_sy_path();                \n    char lockname[100];                 \n                                     \n    strcpy(lockname, get_sy_path());    \n    strcat(lockname, &quot;/metlock&quot;);       \n    ablockfd = open(lockname, O_RDWR);\n    //error code if ablockfd bad\n}\n</code></pre>\n<p>Now to gain a semaphore:</p>\n<p>Now use your semaphore number to &quot;lock&quot; a &quot;record&quot; in your file of length one byte.  Note -- the file will never actually occupy disk space and no disk operation occurs.</p>\n<pre><code>// sem_id is passed in and is set from OPEN_SEM or \n// CLASS_SEM or whatever you call your semaphores.\n\nlseek(ablockfd, sem_id, SEEK_SET); // seeks to the bytes in file  \n                                   // of your semaphore number\nresult = lockf(ablockfd, F_LOCK, 1);\n                                   \nif (result != -1) {\n   //got the semaphore\n} else {\n   //failed\n}\n</code></pre>\n<p>To test if the semaphore is held:</p>\n<pre><code>result = lockf(ablockfd, F_TEST, 1);  // after same lseek\n</code></pre>\n<p>To release the semaphore:</p>\n<pre><code>result = lockf(ablockfd, F_ULOCK, 1);  // after same lseek\n</code></pre>\n<p>And all the other things you can do with <code>lockf()</code> -- blocking/non-blocking, etc.</p>\n<p>Note -- this is WAY faster than a mutex, it goes away if the process dies (a good thing), simple to code, and I know of no operating system with any processor with any number of them or number of cores that cannot atomically lock a record ... so simple code that just works.  The file never really exists (no bytes but in directory), seems to be no practical limit to how many you may have.  I have used this for years on machines with no easy atomic solutions.</p>\n", "tags": ["c", "linux", "atomic"]}
{"id": "18737826-31c5-4a04-81a6-aa26a52f7a3c", "text": "Q: faster methods to remove substrings stored in one column from strings stored in another column A: <p>If your 'timestamp' column is actually a timestamp (or can be converted to one), this is the most robust and performant way.</p>\n<pre class=\"lang-py prettyprint-override\"><code>hist_df_2['timestamp_dt'] = pd.to_datetime(hist_df_2['timestamp'])\nhist_df_2['time'] = hist_df_2['timestamp_dt'].dt.time\n</code></pre>\n<p>Or, if you want the time in a specific string format (e.g., &quot;HH:MM:SS&quot;), you can use <code>strftime</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>hist_df_2['timestamp_dt'] = pd.to_datetime(hist_df_2['timestamp'])\nhist_df_2['time'] = hist_df_2['timestamp_dt'].dt.strftime('%H:%M:%S')\n</code></pre>\n", "tags": ["pandas", "dataframe"]}
{"id": "423e1830-a903-4780-93ec-7d2883237e18", "text": "Q: Trying to Deserialize JSON to typed Object in Powershell A: \n<p><sup>Note: This answer was substantially rewritten based on helpful feedback from <a href=\"https://stackoverflow.com/users/1701026/iron\">iRon</a>.</sup></p>\n<p>The <strong>problem</strong> at hand <strong>affects <em>Windows PowerShell</em></strong> (the legacy, ships-with-Windows, Windows-only edition of PowerShell whose latest and <em>final</em> version is 5.1), but has been <strong>fixed in <a href=\"https://github.com/PowerShell/PowerShell/blob/master/README.md\" rel=\"nofollow noreferrer\"><em>PowerShell (Core) 7</em></a></strong>.</p>\n<p>It isn't specific to JSON processing, but <strong>boils down to trying to initialize an instance of a generic list type</strong> such as <a href=\"https://learn.microsoft.com/en-US/dotnet/api/System.Collections.Generic.List-1\" rel=\"nofollow noreferrer\"><code>System.Collections.Generic.List`1</code></a> or <a href=\"https://learn.microsoft.com/en-US/dotnet/api/System.Collections.ObjectModel.Collection-1\" rel=\"nofollow noreferrer\"><code>System.Collections.ObjectModel.Collection`1</code></a> <strong>with an <code>[object[]]</code>-typed array that has <em>exactly 1 element</em></strong>,<sup>[1]</sup> as the following minimal example shows (note that <code>@(...)</code>, the <a href=\"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_Operators#array-subexpression-operator--\" rel=\"nofollow noreferrer\">array-subexpression operator</a> always creates <code>[object[]]</code>-typed arrays):</p>\n<pre class=\"lang-bash prettyprint-override\"><code>  # UNEXPECTEDLY FAILS in Windows PowerShell (works in PowerShell 7),\n  # if the LHS array has EXACTLY ONE ELEMENT.\n  [System.Collections.Generic.List[int]] $List = @(42)\n  \n  # OK, in both editions (2 or more elements).\n  [System.Collections.Generic.List[int]] $List = @(42, 43)\n</code></pre>\n<p>This kind of initialization happens <em>implicitly</em> in your case, in the context of  casting the <code>[pscustomobject]</code> graph that <a href=\"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-restmethod\" rel=\"nofollow noreferrer\"><code>Invoke-RestMethod</code></a> parsed the JSON response into (in a manner of speaking, it has <a href=\"https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/convertfrom-json\" rel=\"nofollow noreferrer\"><code>ConvertFrom-Json</code></a> built in) to your <code>[Root]</code> class in order to instantiate it; specifically:</p>\n<ul>\n<li>JSON arrays invariably become <code>[object[]]</code> arrays in <code>[pscustomobject]</code> graphs.</li>\n<li>Situationally, if the generic list-typed (<code>[List[&lt;type&gt;]]</code>) <code>.events</code> (class <code>[Root]</code>) and <code>.DataTypeList</code> (class <code>[Event]</code>) properties happen to be initialized with a <em>single-element</em> <code>[object[]]</code> array, the <code>Cannot create object of type &quot;&lt;type&gt;&quot;. Cannot convert the &quot;System.Object[]&quot; value of type &quot;System.Object[]&quot; to type &quot;System.Collections.Generic.List`1[&lt;element-type&gt;]</code> error occurs in  Windows PowerShell.</li>\n</ul>\n<p>However, the <strong>sample JSON in your question would <em>not</em> trigger the problem, because the arrays in question are both <em>2</em>-element arrays</strong>, sample JSON that <em>would</em> is used in the next section.</p>\n<hr />\n<h4>Workarounds (only required in <em>Windows PowerShell</em>):</h4>\n<p>Options:</p>\n<ul>\n<li><p>The simplest workaround is to <strong>use a list-like type that isn't affected by the problem</strong>, namely a <strong>strongly typed <em>array</em></strong>; e.g., instead of <code>[List[Event]]</code>, use <code>[Event[]]</code></p>\n</li>\n<li><p>If you need a <em>resizable</em> list-like type (the ability to remove or add elements later), you can alternatively use the non-generic <a href=\"https://learn.microsoft.com/en-US/dotnet/api/System.Collections.ArrayList\" rel=\"nofollow noreferrer\"><code>System.Collections.ArrayList</code></a> type, albeit at the expense of type safety (this type is in essence the resizable equivalent of an <code>[object[]]</code> array).</p>\n</li>\n<li><p>Finally, if you don't mind an extra, preprocessing step that involves walking the <code>[pscustomobject]</code> graph in order to convert single-element arrays in it to scalars (which bypasses the initialization problem), you could stick with your original <code>class</code> definitions; see <a href=\"https://stackoverflow.com/a/79850418/45375\">this answer</a>.</p>\n</li>\n</ul>\n<p>Here's <strong>self-contained sample</strong> code that demonstrates the workaround using strongly typed arrays instead of lists, specifically <code>[Event[]]</code> in lieu of <code>[List[Event]]</code> and  <code>[DataTypeList[]]</code> instead of: <code>[List[DataTypeList]]</code>.</p>\n<ul>\n<li><p>The sample JSON from your question has been pared down to <em>single</em>-element arrays in order to demonstrate the effectiveness of the solution.</p>\n<ul>\n<li>Conversely, if you tried to run the code with the original <code>[List[&lt;type&gt;]]</code> properties, you would see the error in Windows PowerShell.</li>\n</ul>\n</li>\n<li><p>The sample JSON is parsed into a <code>[pscustomobject]</code> object graph via <a href=\"https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/convertfrom-json\" rel=\"nofollow noreferrer\"><code>ConvertFrom-Json</code></a>, to simulate your <a href=\"https://learn.microsoft.com/powershell/module/microsoft.powershell.utility/invoke-restmethod\" rel=\"nofollow noreferrer\"><code>Invoke-RestMethod</code></a> call.</p>\n</li>\n<li><p>A simple cast to <code>[Root]</code> is sufficient to convert the <code>[pscustomobject]</code> graph into a strongly typed object graph based on your custom classes.</p>\n</li>\n<li><p>The result is re-converted to JSON to demonstrate that the data was correctly parsed - note the source-code comments regarding case of the property names.</p>\n</li>\n</ul>\n<pre class=\"lang-bash prettyprint-override\"><code>using namespace System.Collections.Generic\n\n# Your custom classes.\nclass DataType\n{\n    [string] $key\n    [string] $dataName\n}\n\nclass DataTypeList\n{\n    [string] $key \n    [string] $name \n    [string] $localeKey \n}\n\nclass Event\n{\n    [string] $key\n    [string] $name\n    [string] $localeKey\n    [DataType] $DataType\n    # Workaround: Use a (strongly typed) *array* instead of a list.\n    [DataTypeList[]] $DataTypeList # instead of: [List[DataTypeList]] $DataTypeList\n}\n\nclass Root\n{\n    # Workaround: Use a (strongly typed) *array* instead of a list.\n   [Event[]] $Events # instead of: [List[Event]] $Events\n}\n\n# Simulate an Invoke-RestMethod call that\n# returns JSON, which Invoke-RestMethod automatically\n# parses into a [pscustomobject] object graph.\n$fromJson = ConvertFrom-Json @'\n{\n  &quot;Events&quot;:[\n     {\n        &quot;key&quot;:&quot;1234&quot;,\n        &quot;name&quot;:&quot;Bob Muprhy&quot;,\n        &quot;localeKey&quot;:&quot;4&quot;,\n        &quot;DataType&quot;:{\n           &quot;key&quot;:&quot;1111111&quot;,\n           &quot;dataName&quot;:&quot;Name One&quot;\n        },\n        &quot;DataTypeList&quot;:[\n           {\n              &quot;key&quot;:&quot;983984&quot;,\n              &quot;name&quot;:&quot;New name&quot;,\n              &quot;localeKey&quot;:&quot;34985&quot;\n           }\n        ]\n     }\n  ]\n}\n'@\n\n# Parse the [pscustomobject] graph into a strongly\n# typed object graph based on the custom classes.\n# Note: PowerShell ignores case differences between\n#       the property names as specified in the original JSON\n#       and the custom-class property names.\n$fromJsonStronglyTyped = [Root] $fromJson \n\n# Reconvert to JSON to demonstrate that roundtripping succeeds.\n# Note: The property names are written with the case as defined\n#       in your custom classes, which may differ from the original JSON.\n$fromJsonStronglyTyped | ConvertTo-Json -Depth 4\n</code></pre>\n<hr />\n<p><sup>[1] Note that, by contrast, initializing with a <em>scalar</em> (<code>[System.Collections.Generic.List[int]] $List = 42</code>) or an appropriately <em>strongly typed</em> array (<code>[System.Collections.Generic.List[int]] $List = [int[]] 42</code>)works as expected.</sup></p>\n", "tags": ["powershell"]}
