{"id": "53be96fd-1705-4604-ab30-b698bdbe9f4e", "text": "Q: How to print a list without brackets and commas A: <p>Editing answer as per your edits , have added regex</p>\n<pre><code>import re\n\nextraparamts = []\nwith open(inputt, &quot;r&quot;) as f1:\n    f1 = f1.read()\n    for line in f1.splitlines():  # you can ignore splitlines if your data does not require it\n        if &quot;ts&quot; in line:\n            matches = re.findall(&quot;ts.*&quot;, line)\n            extraparamts.append(str(matches)[5:-5])\n\nfor data in extraparamts:\n    print(data)\n</code></pre>\n<p>Will Give</p>\n<pre><code>1625090\n1625090\n1625090\n1625090\n1625090\n</code></pre>\n", "tags": ["python", "list"]}
{"id": "aaa778d1-d943-4d18-9f32-fecd56903dab", "text": "Q: I&#39;m a beginner learner and i&#39;d like some feedback on this really simple program calculating an employee&#39;s pay A: <p>Check out:</p>\n<p><a href=\"https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response\">Asking the user for input until they give a valid response</a></p>\n", "tags": ["python"]}
{"id": "80c25212-a96f-44b0-8d61-3188fee35aa9", "text": "Q: Why do WebRTC video streams work on PC but not on iPhone for multi-user calls? A: <p>This is a tricky iOS Safari WebRTC issue.\nThe asymmetry you're describing (sender sees everyone, but receivers can't see each other) points to problems with the <strong>mesh connection establishment</strong> when initiated from iOS.</p>\n<h2>Likely iOS Autoplay Restrictions</h2>\n<p>iOS Safari is extremely strict about autoplaying video with audio. When the mesh connections are established between receivers, there's no direct user gesture triggering the video playback:</p>\n<pre><code>async startMediaStream(elementId: string, mediaStream: MediaStream) {\n  // ...\n  videoElement.muted = false;  // \u2190 Problem: iOS blocks unmuted autoplay\n</code></pre>\n<h2>Other possibilities</h2>\n<h3>ICE Candidate Timing Issue</h3>\n<p>Your ICE candidates are gathered asynchronously but sent separately from the offer/answer. On iOS (which can be slower at ICE gathering), the candidates might not be ready when you try to send them.</p>\n<h3><code>ontrack</code> Handler Race Condition</h3>\n<p>You're setting up the ontrack handler after creating the peer connection, but in acceptCall, it's set up late in the flow. Move the ontrack handler setup to immediately after peer connection creation.</p>\n<h3>Add TURN Server</h3>\n<p>iOS Safari behind NAT often fails with STUN-only configurations. Your config only has STUN so try adding a TURN server</p>\n<p>If the IOS autuplay doesn't work, i can add more info on the others.</p>\n", "tags": ["c#", "html", "typescript", "signalr"]}
{"id": "6e566654-a1d7-4341-ad75-3c60fc69a680", "text": "Q: What are commonly-used ways to iterate over an enum class in C++? A: <p>See also my much shorter and generic answer here: <a href=\"https://stackoverflow.com/a/69774217/4561887\">How can I iterate over an enum?</a>, where I cover C++20 or later, pre-C++20, and strong (C++ enum classes) and weak (C-style) enums.</p>\n<hr />\n<p>Limitation for this entire answer: the enum has to be continuous, with no gaps (skipped integers not assigned to an enum member) between the two enum values you want to iterate between.</p>\n<h2>Quick summary</h2>\n<h3>Option 0: use a C++20 range generator function to iterate over the enum class using a modern range-based for loop.</h3>\n<p>In C++20 or later you can write an <code>enum_range()</code> range generator function to allow you to iterate over an <code>enum</code> or <code>enum class</code> (scoped enum) <em>using modern range-based for loops</em> like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>for (const MyErrorType enum_element : \n    enum_range(MyErrorType::begin, MyErrorType::end))\n{\n    // switch statement here, operating on `enum_element`\n}\n</code></pre>\n<p>Here is the custom <code>enum_range()</code> range generator function definition that works in C++20 or later. Comments in the function body have been removed for brevity:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// Generate a C++20 &quot;range&quot; iterating from the enum value `first` to `last`,\n// inclusive, to be used in modern C++ range-based for loops.\n// - This is also using the C++20 feature of &quot;abbreviated function templates&quot;,\n//   or &quot;template argument deduction for functions&quot;, where `auto` can be used\n//   for all input parameter types and for the return type in place of making\n//   this a function template. \nconstexpr inline auto enum_range(auto first, auto last) \n{\n    auto enum_range = \n        std::views::iota(\n            static_cast&lt;std::underlying_type_t&lt;decltype(first)&gt;&gt;(first), \n            static_cast&lt;std::underlying_type_t&lt;decltype(last)&gt;&gt;(last) + 1\n        ) \n        | std::views::transform([](auto enum_val) \n            {\n                return (decltype(first))enum_val; \n            }\n        ); \n\n    return enum_range; \n};\n</code></pre>\n<p><strong>Explanation:</strong></p>\n<p><code>enum_range()</code> is a custom &quot;abbreviated function template&quot; function that generates a C++20 &quot;range&quot; object for iterating over enum values. It uses <code>std::views::iota()</code> (AKA: <a href=\"https://en.cppreference.com/w/cpp/ranges\" rel=\"nofollow noreferrer\"><code>std::ranges::views::iota()</code></a>) to create a <em>sequence</em> of underlying integer values from enum value <code>MyErrorType::begin</code> to <code>MyErrorType::end</code>, and then pipes that range to <code>std::views::transform()</code> with a lambda function as the operator argument to transform those integers back into the enum type. Piping the sequence to the <code>std::views::transform()</code> function is what generates the <em>range</em> object, which is then returned from the <code>enum_range()</code> function and used as the range container object in the range-based for loop for iterating through each enum element.</p>\n<p>Note: for those coming from C, don't confuse <a href=\"https://en.cppreference.com/w/cpp/ranges/iota_view\" rel=\"nofollow noreferrer\"><code>std::ranges::views::iota()</code></a> with <code>&lt;cstdlib&gt;</code>'s <a href=\"https://cplusplus.com/reference/cstdlib/itoa/\" rel=\"nofollow noreferrer\"><code>itoa()</code></a> function. In the former, <code>iota</code> refers to the <a href=\"https://en.wikipedia.org/wiki/Iota\" rel=\"nofollow noreferrer\">Greek letter &quot;iota&quot;</a>, meaning: <a href=\"https://www.merriam-webster.com/dictionary/iota\" rel=\"nofollow noreferrer\">&quot;an infinitesimal amount&quot;</a>, or in my own words, &quot;a small increment or a sequence of consecutive values&quot;, and in the latter C function it stands for &quot;integer to ASCII (C-string)&quot;.</p>\n<p><em>(End of the quick summary)</em></p>\n<p>See below for details and alternatives for earlier versions of C++.</p>\n<hr />\n<h2>Details, and alternatives for C++11 through C++23, inclusive</h2>\n<p>In C++20 or later, you can iterate over an <code>enum</code> or <code>enum class</code> (scoped enum) using range-based for loops by writing a custom range-generator function. While this range generator function is complicated to <em>write</em>, it is simple to <em>use</em>. And, \u5eb7\u6853\u744b (Kang Huanwei) paved the way <a href=\"https://stackoverflow.com/a/69762782/4561887\">in his answer here</a>. That answer is where I first learned about ranges in C++.</p>\n<p>For C++11 or later, you can use a standard for loop with some casts. While this is less &quot;modern&quot;, its advantages are that it is widely available in C++11 or later and is far more accessible and understandable to the average C++ programmer.</p>\n<p>Since <code>enum class</code>es (scoped enums) were not introduced until C++11, this answer does not work for C++03 or earlier at all.</p>\n<p>For all of my code below, see these files in my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo:</p>\n<ol>\n<li><a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/cpp/enum_class_iterate.cpp\" rel=\"nofollow noreferrer\"><strong>enum_class_iterate.cpp</strong></a></li>\n<li><a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/cpp/enum_class_iterate_via_cpp20_range-based_views.cpp\" rel=\"nofollow noreferrer\"><strong>enum_class_iterate_via_cpp20_range-based_views.cpp</strong></a></li>\n</ol>\n<h2>In C++23 or later</h2>\n<p>Note that:</p>\n<blockquote>\n<p>The namespace alias <code>std::views</code> is provided as a shorthand for <code>std::ranges::views</code>.</p>\n<p>Defined in header <code>&lt;ranges&gt;</code></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace std {\n    namespace views = ranges::views;\n}\n</code></pre>\n</blockquote>\n<p>Source: <a href=\"https://en.cppreference.com/w/cpp/ranges\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/ranges</a></p>\n<p>So, <strong>for this enum:</strong></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>enum class MyErrorType \n{\n    SOMETHING_1 = 0,\n    SOMETHING_2,\n    SOMETHING_3,\n    SOMETHING_4,\n    SOMETHING_5,\n    // Helpers for iterating over the enum:\n    // - Note: adding these helpers adds no new enum values, since `begin`\n    //   already has the same value as `SOMETHING_1`, and `end` already has the\n    //   same value as `SOMETHING_5`. These are just aliased names is all. \n    begin = 0,\n    end = SOMETHING_5,\n};\n</code></pre>\n<p>*<em>Use this range generator function:</em></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// C++23 or later: using `std::to_underlying()`, a C++23 feature:\n\n#include &lt;ranges&gt;\n\n// Generate a C++20 &quot;range&quot; iterating from the enum value `first` to `last`,\n// inclusive, to be used in modern C++ range-based for loops.\n// - This is also using the C++20 feature of &quot;abbreviated function templates&quot;,\n//   or &quot;template argument deduction for functions&quot;, where `auto` can be used\n//   for all input parameter types and for the return type in place of making\n//   this a function template. \nconstexpr inline auto enum_range(auto first, auto last) \n{\n    // Note that &quot;ranges&quot; exist only in C++20 or later\n    auto enum_range = \n        // `std::views::iota` is a C++20 range generator that auto-generates a\n        // sequence of values from (param1) to (param2 - 1).\n        // - See: https://en.cppreference.com/w/cpp/ranges/iota_view\n        // - The word &quot;iota&quot; refers to the Greek letter &quot;iota&quot; which apparently\n        //   is often used in math and computer science to represent a small\n        //   increment or a sequence of consecutive values.\n        // - In range factories, `|` is apparently the &quot;pipe&quot; operator, which is\n        //   used to chain together range operations.\n        std::views::iota(\n            std::to_underlying(first), \n            std::to_underlying(last) + 1\n        ) \n        | std::views::transform([](auto enum_val) \n            { \n                return (decltype(first))enum_val; \n            }\n        ); \n\n    return enum_range; \n};\n</code></pre>\n<p><strong>...to iterate over the enum class using a modern range-based for loop like this:</strong></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>    for (const MyErrorType e : enum_range(MyErrorType::begin, MyErrorType::end))\n    {\n        switch (e)\n        {\n            case MyErrorType::SOMETHING_1:\n                printf(&quot;MyErrorType::SOMETHING_1\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_2:\n                printf(&quot;MyErrorType::SOMETHING_2\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_3:\n                printf(&quot;MyErrorType::SOMETHING_3\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_4:\n                printf(&quot;MyErrorType::SOMETHING_4\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_5:\n                printf(&quot;MyErrorType::SOMETHING_5\\n&quot;);\n                break;\n        }\n    }\n</code></pre>\n<h2>In C++20 or later</h2>\n<p>In C++20 and earlier you don't have access to <code>std::to_underlying(my_variable)</code>, so you must use <code>static_cast&lt;std::underlying_type_t&lt;decltype(my_variable)&gt;&gt;(my_variable)</code> instead. So, here is the range generator function that works in C++20 or later:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// For C++20 range-based views:\n\n// Generate a C++20 &quot;range&quot; iterating from the enum value `first` to `last`,\n// inclusive, to be used in modern C++ range-based for loops.\n// - This is also using the C++20 feature of &quot;abbreviated function templates&quot;,\n//   or &quot;template argument deduction for functions&quot;, where `auto` can be used\n//   for all input parameter types and for the return type in place of making\n//   this a function template. \nconstexpr inline auto enum_range(auto first, auto last) \n{\n    // Note that &quot;ranges&quot; exist only in C++20 or later\n    auto enum_range = \n        // `std::views::iota` is a C++20 range generator that auto-generates a\n        // sequence of values from (param1) to (param2 - 1).\n        // - See: https://en.cppreference.com/w/cpp/ranges/iota_view\n        // - The word &quot;iota&quot; refers to the Greek letter &quot;iota&quot; which apparently\n        //   is often used in math and computer science to represent a small\n        //   increment or a sequence of consecutive values.\n        // - In range factories, `|` is apparently the &quot;pipe&quot; operator, which is\n        //   used to chain together range operations.\n        std::views::iota(\n            static_cast&lt;std::underlying_type_t&lt;decltype(first)&gt;&gt;(first), \n            static_cast&lt;std::underlying_type_t&lt;decltype(last)&gt;&gt;(last) + 1\n        ) \n        | std::views::transform([](auto enum_val) \n            {\n                return (decltype(first))enum_val; \n            }\n        ); \n\n    return enum_range; \n};\n</code></pre>\n<p>Everything else is the same as above.</p>\n<h2>In C++11 or later</h2>\n<p>The &quot;ranges&quot; library (see: <a href=\"https://en.cppreference.com/w/cpp/ranges\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/ranges</a>) was introduced in C++20, so you can't use it in C++11, C++14, or C++17. The following therefore works in C++11 or later, including in C++20 and C++23.</p>\n<p>While the above technique is very easy to <em>use</em>, the range generator is very hard to initially write, and to understand. Therefore, the following approach has the following benefits:</p>\n<ol>\n<li>It is the simplest for anyone to follow.</li>\n<li>It has the lowest barrier-to-entry.</li>\n<li>It works in any version of C++11 or later, rather than requiring C++20. And...</li>\n<li>It still has the possibility of introducing no new enum values into the enum. Rather, &quot;option 1&quot; of this approach below name-aliases a couple of the already-existing values in the enum for convenience.</li>\n</ol>\n<p>Additional info (also applies to the above examples): it compiles with the <code>-Wall -Wextra -Werror</code> compiler build options, which ensure that a compile-time error is thrown if you forget to handle any of the enum values in your switch statements. This is a great safety feature to ensure you keep the enum definition and all switch cases in-sync, handling all possible enums in all of your switch statements.</p>\n<h3>Option 1: introduces no new enum values</h3>\n<p>From <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/blob/master/cpp/enum_class_iterate.cpp\" rel=\"nofollow noreferrer\"><strong>enum_class_iterate.cpp</strong></a> in my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world/\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>///usr/bin/env ccache g++ -Wall -Wextra -Werror -O3 -std=gnu++17 &quot;$0&quot; -o /tmp/a &amp;&amp; /tmp/a &quot;$@&quot;; exit\n// For the line just above, see my answer here: https://stackoverflow.com/a/75491834/4561887\n\n#include &lt;cstdio&gt;   // For `printf()`\n\nenum class MyErrorType \n{\n    SOMETHING_1 = 0,\n    SOMETHING_2,\n    SOMETHING_3,\n    SOMETHING_4,\n    SOMETHING_5,\n    // Helpers for iterating over the enum:\n    // - Note: adding these helpers adds no new enum values, since `begin`\n    //   already has the same value as `SOMETHING_1`, and `end` already has the\n    //   same value as `SOMETHING_5`. These are just aliased names is all. \n    begin = 0,\n    end = SOMETHING_5,\n};\n\nint main()\n{\n    printf(&quot;C++ enum class iteration demo.\\n&quot;);\n\n    // Iterate over the enum class\n\n    // Option 1\n    for (MyErrorType myErrorType = MyErrorType::begin;\n        myErrorType &lt;= MyErrorType::end;\n        myErrorType = static_cast&lt;MyErrorType&gt;(\n            static_cast&lt;size_t&gt;(myErrorType) + 1))\n    {\n        switch (myErrorType)\n        {\n            case MyErrorType::SOMETHING_1:\n                printf(&quot;MyErrorType::SOMETHING_1\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_2:\n                printf(&quot;MyErrorType::SOMETHING_2\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_3:\n                printf(&quot;MyErrorType::SOMETHING_3\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_4:\n                printf(&quot;MyErrorType::SOMETHING_4\\n&quot;);\n                break;\n            case MyErrorType::SOMETHING_5:\n                printf(&quot;MyErrorType::SOMETHING_5\\n&quot;);\n                break;\n        }\n    }\n}\n</code></pre>\n<p>Make the file above executable and run it as follows. Tested in Linux Ubuntu 22.04:</p>\n<pre class=\"lang-bash prettyprint-override\"><code># Ensure you have `ccache`\nsudo apt update\nsudo apt install ccache\n\n# make the file executable\nchmod +x enum_class_iterate.cpp\n\n# compile and run it\n./enum_class_iterate.cpp\n</code></pre>\n<p>Sample run and output:</p>\n<pre><code>eRCaGuy_hello_world/cpp$ ./enum_class_iterate.cpp \nC++ enum class iteration demo.\nMyErrorType::SOMETHING_1\nMyErrorType::SOMETHING_2\nMyErrorType::SOMETHING_3\nMyErrorType::SOMETHING_4\nMyErrorType::SOMETHING_5\n</code></pre>\n<h3>Option 2 (my preference): introduces a new <code>count</code> enum class value, but makes the last portion of the enum class definition always the same for all enum classes, which is nice</h3>\n<p>This is my preferred way to define an enum class in C++, for all versions of C++, including C++11 through C++23, inclusive. For C++20, rather than the manual iteration approach below, however, I do like to use the <code>enum_range()</code> range generator function I showed above to iterate using modern range-based for loops.</p>\n<p>Note that you can also optionally add a count value if you need to use it anywhere to get the number of valid enum values in your enum class. This also has the really nice added benefit of making the last portion of the enum class definition, starting with <code>count,</code> always the exact same for all enum classes, so you can easily copy-paste this code and recognize it throughout your code base. In the first example above, in <code>end = SOMETHING_5,</code>, the <code>SOMETHING_5</code> enum value must be manually updated for all of your enums, which is error-prone. <em>So, this is my preferred way to define an enum class in C++:</em></p>\n<pre class=\"lang-cpp prettyprint-override\"><code>enum class MyErrorType2 \n{\n    SOMETHING_1 = 0,\n    SOMETHING_2,\n    SOMETHING_3,\n    SOMETHING_4,\n    SOMETHING_5,\n\n    // Helpers\n    count,\n    begin = 0,\n    end = count - 1,\n};\n</code></pre>\n<p>Iteration over the enum is still exactly the same as above, except you must add a dummy &quot;nothing to do&quot; case for the <code>count</code> value in your switch statement, in order to cover all possible values in the enum class:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// Option 2: same as above, except we must also include the `count` value\n// as a switch case. \nfor (MyErrorType2 myErrorType2 = MyErrorType2::begin;\n    myErrorType2 &lt;= MyErrorType2::end;\n    myErrorType2 = static_cast&lt;MyErrorType2&gt;(\n        static_cast&lt;size_t&gt;(myErrorType2) + 1))\n{\n    switch (myErrorType2)\n    {\n        case MyErrorType2::SOMETHING_1:\n            printf(&quot;MyErrorType2::SOMETHING_1\\n&quot;);\n            break;\n        case MyErrorType2::SOMETHING_2:\n            printf(&quot;MyErrorType2::SOMETHING_2\\n&quot;);\n            break;\n        case MyErrorType2::SOMETHING_3:\n            printf(&quot;MyErrorType2::SOMETHING_3\\n&quot;);\n            break;\n        case MyErrorType2::SOMETHING_4:\n            printf(&quot;MyErrorType2::SOMETHING_4\\n&quot;);\n            break;\n        case MyErrorType2::SOMETHING_5:\n            printf(&quot;MyErrorType2::SOMETHING_5\\n&quot;);\n            break;\n        case MyErrorType2::count:\n            // Nothing to do\n            break;\n    }\n}\n</code></pre>\n<p>If you forget the <code>case MyErrorType2::count:</code> case in the switch statement but are compiling using the compiler's <code>-Wall -Wextra -Werror</code> options, you will get this error: <code>error: enumeration value \u2018count\u2019 not handled in switch [-Werror=switch]</code>, as shown here:</p>\n<pre><code>eRCaGuy_hello_world/cpp$ ./enum_class_iterate.cpp \n./enum_class_iterate.cpp: In function \u2018int main()\u2019:\n./enum_class_iterate.cpp:127:16: error: enumeration value \u2018count\u2019 not handled in switch [-Werror=switch]\n  127 |         switch (myErrorType2)\n      |                ^\ncc1plus: all warnings being treated as errors\n</code></pre>\n<p>Compiling with <code>-Wall -Wextra -Werror</code> and <em>not</em> using a <code>default</code> switch case in any switch statements is therefore the recommended approach to help you always keep your enum definitions and switch statements in-sync, covering all possible enum values.</p>\n<h2>References</h2>\n<ol>\n<li>*****+ <a href=\"https://stackoverflow.com/a/69762782/4561887\">This really helpful answer by \u5eb7\u6853\u744b (Kang Huanwei) here</a></li>\n<li>C++20 views and ranges: <a href=\"https://en.cppreference.com/w/cpp/ranges\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/ranges</a>\n<ol>\n<li><a href=\"https://en.cppreference.com/w/cpp/ranges/iota_view\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/ranges/iota_view</a></li>\n</ol>\n</li>\n<li>Algorithm: <a href=\"https://en.cppreference.com/w/cpp/algorithm/transform\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/algorithm/transform</a></li>\n<li>Utility: <a href=\"https://en.cppreference.com/w/cpp/utility/to_underlying\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/utility/to_underlying</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow noreferrer\">https://en.cppreference.com/w/cpp/language/decltype</a></li>\n<li>Abbreviated Function Templates and Constrained Auto -\n<a href=\"https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/\" rel=\"nofollow noreferrer\">https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/</a></li>\n</ol>\n<h2>Related</h2>\n<ol>\n<li>Common techniques for iterating over <code>enum</code>s (as opposed to <code>enum class</code>es): <a href=\"https://stackoverflow.com/questions/261963/how-can-i-iterate-over-an-enum\">How can I iterate over an enum?</a>\n<ol>\n<li>[my answer] <a href=\"https://stackoverflow.com/questions/261963/how-can-i-iterate-over-an-enum/69774217#69774217\">How can I iterate over an enum?</a></li>\n</ol>\n</li>\n<li>My answer on some of the differences between <code>enum class</code>es (<em>strongly-typed</em> enums) and regular <code>enum</code>s (<em>weakly-typed</em> enums) in C++: <a href=\"https://stackoverflow.com/questions/8357240/how-to-automatically-convert-strongly-typed-enum-into-int/65014885#65014885\">How to automatically convert strongly typed enum into int?</a></li>\n<li><a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world#additional-c-and-c-build-notes-ex-wgcc-or-clang-compilers\" rel=\"nofollow noreferrer\">Some of my personal notes on the <code>-Wall -Wextra -Werror</code> and other build options</a>, from my <a href=\"https://github.com/ElectricRCAircraftGuy/eRCaGuy_hello_world\" rel=\"nofollow noreferrer\">eRCaGuy_hello_world</a> repo.</li>\n<li><a href=\"https://stackoverflow.com/questions/15450914/incrementation-and-decrementation-of-enum-class\">Incrementation and decrementation of \u201cenum class\u201d</a></li>\n</ol>\n<p><sub>Other keywords: common way to iterate over enum or enum class in C or C++; best way to iterate over enum class in C++; enum class C++ iterate; c++ iterate over enum class</sub></p>\n", "tags": ["c++", "enums", "enumeration", "enum-class"]}
{"id": "6b8a372a-5833-4f5c-92c3-42a718878409", "text": "Q: org.hibernate.type.SerializationException: could not deserialize A: <p>I forgot to add autoApply=true to my converter</p>\n", "tags": ["hibernate", "exception", "serialization", "deserialization"]}
