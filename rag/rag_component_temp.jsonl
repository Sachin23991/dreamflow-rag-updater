{"id": "1f54994d-bd1a-4923-aabe-d7522949331f", "text": "Q: What is the idiomatic way to organize shared helper functions in Go projects? A: <p>The repo you link to is not in any way a &quot;standard&quot; of any kind. You'll find many people, myself included, who would argue that the structure proposed in that repo not only isn't ideal - it is terrible. The proposed structure is super complex, much more complex than most production Go repos tend to be. While some people might adhere to this organization scheme, many do not, including some of the Go language authors themselves. Please don't present this as any kind of generally-accepted repo architecture.</p>\n", "tags": ["go"]}
{"id": "6245f08f-7a90-409a-bef4-b166e00f16ee", "text": "Q: Can an abstract class enforce trait usage? A: <p>Here in the reply as not to pollute the scope of the answer.....<br />\nHowever, why not implement an interface? if you must use a trait we can go around a few loops but we can do it I'll see you in the next video. pretty? Is there a reason you really need the trait?</p>\n", "tags": ["php", "oop", "abstract-class", "traits"]}
{"id": "efd70023-0085-4904-ab91-2b168e3bc7ff", "text": "Q: Memory Leak using StreamReader and XmlSerializer A: <p>From MSDN: <a href=\"https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-xml-serialization-xmlserializer#dynamically-generated-assemblies\" rel=\"nofollow noreferrer\">System.Xml.Serialization.XmlSerializer class: Dynamically generated assemblies</a></p>\n<blockquote>\n<p>To increase performance, the XML serialization infrastructure dynamically generates assemblies to serialize and deserialize specified types. The infrastructure finds and reuses those assemblies. This behavior occurs only when using the following constructors:</p>\n<p><a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer.-ctor#system-xml-serialization-xmlserializer-ctor(system-type)\" rel=\"nofollow noreferrer\"><code>XmlSerializer.XmlSerializer(Type)</code></a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/dotnet/api/system.xml.serialization.xmlserializer.-ctor#system-xml-serialization-xmlserializer-ctor(system-type-system-string)\" rel=\"nofollow noreferrer\"><code>XmlSerializer.XmlSerializer(Type,\u2002String)</code></a></p>\n<p>If you use any of the other constructors, multiple versions of the same assembly are generated and never unloaded, which results in a memory leak and poor performance. The easiest solution is to use one of the previously mentioned two constructors. Otherwise, you must cache the assemblies in a Hashtable, as shown in the following example.</p>\n</blockquote>\n<p>So to fix it you have to use this constructor <code>XmlSerializer xml = new XmlSerializer(typeof(XMLObj))</code>  instead of <code>XmlSerializer xml = new XmlSerializer(typeof(XMLObj), new XmlRootAttribute(&quot;rootNode&quot;));</code></p>\n<p>and add root XML attribute into XMLObj class.</p>\n<pre><code>[Serializable()]\n[XmlRoot(&quot;root&quot;)]\npublic class XMLObj: IDisposable\n{\n    [XmlElement(&quot;block&quot;)]\n    public List&lt;XMLnode&gt; nodes{ get; set; }\n\n    public XMLObj() { }\n\n    public void Dispose()\n    {\n        nodes.ForEach(n =&gt; n.Dispose());\n        nodes= null;\n\n        GC.SuppressFinalize(this);\n    }\n}\n</code></pre>\n", "tags": ["c#", "xml", "streamreader", "xmlserializer"]}
{"id": "cccc8413-a2e0-44d8-8204-7d1da3acfb4c", "text": "Q: Installing packages on an EC2 instance in a private subnet A: <ol>\n<li><p>In a Private Subnet to reach out to the internet you'll need a NAT Instance or cheaper a NAT Gateway.</p>\n</li>\n<li><p>What many people do instead is bake an AMI with all the tools installed on the base OS image, this way spinning up an EC2 is super fast and everything required is baked in.</p>\n</li>\n<li><p>Alternatively you might switch to containers and ECS as you can build docker images with all the dependencies easier than building an AMI with a tool like Packer.</p>\n</li>\n</ol>\n", "tags": ["amazon-web-services", "amazon-ec2", "private", "subnet"]}
{"id": "88d41c73-955c-4905-bc98-1d99e02352f8", "text": "Q: Apache Camel AWS/SQS component A: <p>This may not be the best option because it limits the client, but I was already creating and registering an AmazonSQSClient (to use in the route definition parameter amazonSQSClient).  I created a subclass to override listQueues to instead make a call to getQueueURL which has a QueueOwnerAWSAccountId parameter.  Here is my custom client:</p>\n\n<pre><code>import com.amazonaws.AmazonClientException;\nimport com.amazonaws.AmazonServiceException;\nimport com.amazonaws.ClientConfiguration;\nimport com.amazonaws.auth.AWSCredentials;\nimport com.amazonaws.services.sqs.AmazonSQSClient;\nimport com.amazonaws.services.sqs.model.GetQueueUrlRequest;\nimport com.amazonaws.services.sqs.model.GetQueueUrlResult;\nimport com.amazonaws.services.sqs.model.ListQueuesResult;\n\npublic class CustomSQSClient extends AmazonSQSClient {\n\nprivate String queueName;\nprivate String accountId;\n\npublic CustomSQSClient(AWSCredentials awsCredentials, ClientConfiguration clientConfiguration, String queueName, String accountId) {\n    super(awsCredentials, clientConfiguration);\n    this.queueName = queueName;\n    this.accountId = accountId;\n}\n\n@Override\npublic ListQueuesResult listQueues() throws AmazonServiceException,\n        AmazonClientException {\n\n    GetQueueUrlRequest getQueueUrlRequest = new GetQueueUrlRequest();\n    getQueueUrlRequest.setQueueName(queueName);\n    getQueueUrlRequest.setQueueOwnerAWSAccountId(accountId);\n    GetQueueUrlResult getQueueUrlResult = getQueueUrl(getQueueUrlRequest );\n\n    if (getQueueUrlResult.getQueueUrl() != null) {\n        ListQueuesResult listQueuesResult = new ListQueuesResult();\n        listQueuesResult.getQueueUrls().add(getQueueUrlResult.getQueueUrl());\n        return listQueuesResult;\n    } else {\n        return super.listQueues();\n    }\n}\n}\n</code></pre>\n\n<p>The better option would be to override org.apache.camel.component.aws.sqs.SqsEndpoint.doStart, but I am working with the easier approach.</p>\n", "tags": ["amazon-web-services", "apache-camel", "amazon-sqs", "apache-servicemix"]}
{"id": "832fbfe6-4c6c-45b4-b3f5-5f77b60dd75e", "text": "Q: Difference between initializing a class and instantiating an object? A: <p>There are three pieces of terminology associated with this topic: declaration, initialization and instantiation.</p>\n<p>Working from the back to front.</p>\n<p><strong>Instantiation</strong></p>\n<p>This is when memory is allocated for an object. This is what the <code>new</code> keyword is doing. A reference to the object that was created is returned from the <code>new</code> keyword.</p>\n<p><strong>Initialization</strong></p>\n<p>This is when values are put into the memory that was allocated. This is what the <a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html\" rel=\"nofollow noreferrer\">Constructor</a> of a class does when using the <code>new</code> keyword.</p>\n<p>A variable must also be initialized by having the reference to some object in memory passed to it.</p>\n<p><strong>Declaration</strong></p>\n<p>This is when you state to the program that there will be an object of a certain type existing and what the name of that object will be.</p>\n<p><strong>Example of Initialization and Instantiation on the same line</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>// Declaration\nSomeClass s;\n// Instantiates and initializes the memory and initializes the variable 's'\ns = new SomeClass();\n</code></pre>\n<p><strong>Example of Initialization of a variable on a different line to memory</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>void someFunction(SomeClass other) {\n    // Declaration\n    SomeClass s;\n    // Initializes the variable 's' but memory for variable other \n    // was set somewhere else\n    s = other;\n}\n</code></pre>\n<p>I would also highly recommend reading <a href=\"http://javadude.com/articles/passbyvalue.htm\" rel=\"nofollow noreferrer\">this article</a> on the nature of how Java handles passing variables.</p>\n", "tags": ["java"]}
{"id": "65c745b6-f9ed-4e31-96df-6cc175085ca3", "text": "Q: Create Post endpoint with article content returns 424 A: <p>I found the culprit.</p>\n<p>It was breaking because the <code>content.article.source</code> field was a localhost URL. For some reason, if it's localhost, it breaks. But only about 95% of the time, not 100%, and it doesn't say what the issue is.</p>\n<p>To top it all off it's fine if the <code>contentLandingPage</code> field is a localhost URL.</p>\n", "tags": ["javascript", "linkedin-api"]}
{"id": "6040b0bb-9a37-4934-bd91-a59c18cf4f75", "text": "Q: Get classpath without installing maven projects A: <p>It does take minutes. If a change is made in <code>my-group:lib-parent</code>, I need to rebuild that, install it into local .m2, rebuild <code>bar:bar-lib</code>, install it into .m2 and rebuild <code>my-group:app</code>. For multi-module projects, it goes through all the modules and all the lifecycles. It adds up quickly with many dependencies that all need to be built, even though most of them are a no-op. Plus I need to worry about the ordering, which IDE handles nicely.</p>\n<p>I'm not necessarily married to maven in terms of tooling. Any tool that can read pom.xml would work - in the same way IDEs do - would work.</p>\n", "tags": ["java", "maven"]}
