{"id": "d80688a8-7901-41d3-a649-a94fc01c5673", "text": "Q: WhatsApp Cloud API - Is typing_indicator supported in message read payload? A: <p>i did implemented the typing indicator and it is working also, it turns off automatically after 25 seconds if not responded within that time.<br />\nBut, the issue is that within that 25 seconds if the AI has responded and we have another user response for which we want to show typing indicator, it is not working.<br />\nsomehow i believe in whatsapp backend, the typing indicator is getting suppressed if we send another typing indicator request within 25 seconds.</p>\n", "tags": ["whatsapp", "whatsapp-cloud-api"]}
{"id": "c52e2a28-9e57-4f1c-b7d5-e4ccf1d0fa2b", "text": "Q: Passing a local reference to a closure A: <p><strong>TLDR:</strong></p>\n<p>The code is valid.</p>\n<p><strong>More info:</strong></p>\n<p>You title (<em>&quot;Passing a local reference ...&quot;</em>) is not entirely correct.<br />\nIn C++ there is <strong>no such thing as a reference to a reference</strong>.<br />\nHere <code>t</code> is a reference to an element in the <code>vector</code>, and when you capture it by reference in the lambda, you are not capturing a local by ref, but rather keep a reference to the element in the <code>vector</code> (a reference to a reference is the same as the original reference).</p>\n", "tags": ["c++", "lambda", "reference", "lambda-capture"]}
{"id": "79e049c3-05d9-438f-86aa-b10f9b756339", "text": "Q: DVTDeviceOperation: Encountered a build number that is incompatible with DVTBuildVersion A: <p>Open Xcode</p>\n<p>select Xcode &gt; Windows &gt; Devices and Simulators.</p>\n<p>Unpair all device that is not the one you are using.</p>\n<p>Test your xcodebuild is not giving the error anymore.</p>\n<p>Pair again the devices you previously removed.</p>\n<p>You should be fine.</p>\n", "tags": ["xcode"]}
{"id": "68bc3093-91e6-4357-83fb-e07544438a03", "text": "Q: ASPNET Core Server Sent Events / Response flush A: <p>Adding to the existing responses here, you can also target specific SSE events by appending the event type and listening for that event on the client:</p>\n<pre><code> &lt;script&gt;\n        const eventSource = new EventSource('https://localhost:XXXX/api/messages/unread-count-stream');\n\n        eventSource.addEventListener('UnreadMessagesCount', event =&gt; {\n            console.log('unread count:', event.data);\n        });\n    &lt;/script&gt;\n</code></pre>\n<p>On the server side, you must add the event field, which in this case is <code>UnreadMessagesCount</code>:</p>\n<pre><code>await response.WriteAsync($&quot;{event}: UnreadMessagesCount\\n&quot;);\nawait response.WriteAsync($&quot;data: {Messages.Count}\\n\\n&quot;);\nresponse.Body.Flush();\n</code></pre>\n", "tags": ["c#", "asp.net-core", "asp.net-core-mvc", "asp.net-core-1.0"]}
{"id": "421d04e1-7192-48e9-a042-b60cd48ed2cd", "text": "Q: Is there any way to modify `req.query` in Express v5? A: <p>Edit: Here's <a href=\"https://gist.github.com/thom-nic/361cc4bb7e7d0d3ee7543b5f774b5286\" rel=\"nofollow noreferrer\">a better example</a> (inspired by zecat's answer) that only updates the query instance when it's necessary, in middleware, and the query remains immutable downstream. So it has no global side-effects but we gain the benefits of Joi validation.</p>\n<p>Usage Example:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const { Router } = require('express')\nconst { Joi } = require('joi');\nconst { validateQueryMiddleware } = require('validate_express');\n\nconst SEARCH_QUERY_SCHEMA = Joi.object({\n  q: Joi.string().min(3).max(200).required(), \n  limit: Joi.number().integer().min(5).max(100).default(30), \n  page: Joi.number().integer().min(1).default(1),\n});\n\nconst router = Router();\n\n// GET /search?limit=20&amp;page=3&amp;q=tigers    -- passes validation; query values 'limit' and 'page' will be converted to integers\n// GET /search?limit=foo                   -- fails validation: 'q' is required, 'limit' must be an integer\nrouter.get('search', \n  validateQueryMiddleware(SEARCH_QUERY_SCHEMA), \n  (req, res, next) =&gt; {\n    const { limit, page, q } = req.query;  // these will be validated and limit,page will be integers\n    // ... route logic\n  });\n\nmodule.exports = router;\n</code></pre>\n<p>Middleware:</p>\n<pre class=\"lang-js prettyprint-override\"><code>// validate_express.js\nconst Boom = require('@hapi/boom');\nconst Joi = require('joi');\n\n// This only modifies req.query when it must change due to validation.\n// `req.query` remains immutable after changing it here.\nfunction updateQuery(req, value) {\n  Object.defineProperty(\n    req,\n    'query',\n    {\n      ...Object.getOwnPropertyDescriptor(req, 'query'),\n      writable: false,\n      value,\n    });\n}\n\n// validate the request query and update the request object, or \n// call next(err) if validation fails. \nfunction validateQuery(schema, req, next) {\n  try {\n    updateQuery(req, Joi.attempt(req.query, schema));\n    next(); // valid\n  }\n  catch (err) {\n    // `error` is a Joi ValidationError. You could extract `err.details` and \n    // put them in your Boom payload.\n    // See: https://joi.dev/api/?v=17.13.3#validationerror\n    // See: https://hapi.dev/module/boom/api/?v=10.0.1\n    next(Boom.conflict('validation error', {data: err.details}));\n  }\n}\n\n/**\n * This thunk returns an Express middleware that will validate requests against the given schema.\n */\nfunction validateQueryMiddleware(schema) {\n  return (req, res, next) =&gt; validateQuery(schema, req, next);\n}\n\nmodule.exports = {\n  validateQueryMiddleware,\n  validateQuery,\n};\n</code></pre>\n<hr />\n<h2>Old answer</h2>\n<p>The request class uses <code>Object.defineProperty</code> to define the getter. It <em>is technically</em> possible to monkey patch the class.  Above method is recommended, this is included since it does answer my original question.</p>\n<p>Here's an example:</p>\n<pre><code>/* eslint-disable no-invalid-this */\nconst { request: Request } = require('express');\n\nconst parseQuery = Object.getOwnPropertyDescriptor(Request, 'query').get;\n\nfunction getQuery() {\n  if (this.__queryModified)\n    return this.__queryModified;\n  return parseQuery.call(this);\n}\n\nfunction setQuery(value) {\n  this.__queryModified = Object.freeze(value);\n}\n\nmodule.exports = function monkeyPatchExpress5RequestQuery() {\n  Object.defineProperty(Request, 'query', {\n    configurable: true,\n    enumerable: true,\n    get: getQuery,\n    set: setQuery,\n  });\n};\n</code></pre>\n<p><strong>Edit</strong>: I understand all the pitfalls and caveats that come with monkey patching.</p>\n<p>Ref:</p>\n<ul>\n<li><a href=\"https://gist.github.com/thom-nic/361cc4bb7e7d0d3ee7543b5f774b5286\" rel=\"nofollow noreferrer\">https://gist.github.com/thom-nic/361cc4bb7e7d0d3ee7543b5f774b5286</a></li>\n<li><a href=\"https://github.com/expressjs/express/blob/5.x/lib/request.js#L217-L228\" rel=\"nofollow noreferrer\">https://github.com/expressjs/express/blob/5.x/lib/request.js#L217-L228</a></li>\n</ul>\n", "tags": ["node.js", "express"]}
{"id": "640ba45a-2458-49ac-9e3d-7171541892dc", "text": "Q: PHP Oracle cursor issue ORA-01000: maximum open cursors exceeded A: <p>In Oracle, an open cursor is a handle or pointer to a private SQL area in memory, representing an active session's execution of a SQL statement (like SELECT, INSERT, UPDATE, DELETE) or PL/SQL block.</p>\n<p>The default value for OPEN_CURSORS in an Oracle database is often 50, but for newer versions might default to 300.</p>\n<p>In your case you have 500 options, if all chosen, I believe it may cause the cursors opened to be say 500. (so ... exceeding the allowed 300 limit)</p>\n<p>To fix this problem:</p>\n<p>(A) you may close the resources used (after the query ends), such as using the following</p>\n<pre><code> $this-&gt;db-&gt;close();\n// then establish a new db connection, but make sure \n// your database-related statements are amended accordingly \n</code></pre>\n<p><strong>Note</strong>: (1) Make sure after you close the connection, you create a new connection otherwise the loop cannot continue (you may need to revise the commands inside the loop). Actually you may enclose the &quot;new / close&quot; block inside the loop. In my experience, better create and use a new db connection which is different from the original db connection so that your amendments will not affect other database statements in your script (2) On the other hand, as stated by other volunteers , better create prepared statement(s) and use it in the loop.</p>\n<p>(B) Alternatively, you may change the open_cursors value to a higher value. If your system has sufficient resources then set it as 1000 is also ok.</p>\n<p>Say <strong>execute</strong> the following query at the top of your script:</p>\n<pre><code> $startquery = &quot;ALTER SYSTEM SET open_cursors = 1000 SCOPE=BOTH;&quot;;\n\n</code></pre>\n<p>(C) But the above (option B) will only apply to that particular script, if you want to do it permanently and globally, you need to modify the SPFILE (using ALTER SYSTEM) and restart the database. (but of course you may need to have the <code>ALTER SYSTEM</code> system privilege to use this option)</p>\n", "tags": ["php", "oracle-database"]}
{"id": "7a1d7a8f-e6eb-4744-bef2-6ff7880b8760", "text": "Q: jBPM Email Workhandler - Attaching a document A: <p>JBPM Email tasks can\u2019t consume <code>Document</code> objects directly, so what you are going to need to do is load the document bytes via <code>DocumentStorageService</code> and pass a <code>Map&lt;String, byte[]&gt;</code> as the attachment.</p>\n<p>This should work, I think?</p>\n", "tags": ["docker", "email", "handler", "jbpm"]}
