{"id": "6d09f34a-5292-433f-8db5-8d0c95e78980", "text": "Q: CloudKit remote notifications in macOS get clogged up A: <p>After a lot of trial and error I found that using <a href=\"https://developer.apple.com/documentation/appkit/nsapplication/registerforremotenotifications(matching:)\" rel=\"nofollow noreferrer\"><code>registerForRemoteNotifications(matching:)</code></a> works as expected, even though it is &quot;<strong>deprecated</strong>&quot; according to the docs, or &quot;<strong>soft deprecated</strong>&quot; according to Xcode.</p>\n<p><a href=\"https://i.sstatic.net/tQYzXCyf.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/tQYzXCyf.png\" alt=\"Xcode showing warning of soft deprecated\" title=\"soft deprecated\" /></a></p>\n<p>Both point to using the newest <a href=\"https://developer.apple.com/documentation/appkit/nsapplication/registerforremotenotifications()\" rel=\"nofollow noreferrer\">registerForRemoteNotifications()</a> but as the original question mentions, notifications are unreliable, even silent remote notifications coming from iCloud would take hours to arrive.</p>\n<h1>Solution</h1>\n<p>Use the deprecated <code>registerForRemoteNotifications(matching:)</code> and notifications work as well as on iOS.</p>\n<h2>Example</h2>\n<pre class=\"lang-swift prettyprint-override\"><code> NSApplication.shared.registerForRemoteNotifications(matching: [])\n</code></pre>\n<h3>Note</h3>\n<p>Using empty array <code>[]</code> for silent remote notifications, i.e. notifications from CloudKit.</p>\n", "tags": ["macos", "push-notification", "apple-push-notifications", "cloudkit"]}
{"id": "135cbbaf-1356-4546-86b7-d0d0e3282e85", "text": "Q: Detect online users? A: <p>The core issue here is treating \u201conline\u201d as a binary property of a user.</p>\n<p>In request/response applications, approximating online users via recent activity timestamps was often the only practical option. That\u2019s why many older answers frame this as \u201cinherently inaccurate.\u201d</p>\n<p>Once you introduce persistent connections and lifecycle signals, the problem changes.</p>\n<p>A more reliable approach is:</p>\n<ul>\n<li><p>track presence at the <strong>session</strong> level (tab, device, client), not the user level</p>\n</li>\n<li><p>record lightweight heartbeat or activity signals per session</p>\n</li>\n<li><p>derive presence state from <strong>time since last signal</strong>, not connect/disconnect events</p>\n</li>\n<li><p>tolerate brief gaps with TTLs and grace windows instead of marking offline immediately</p>\n</li>\n</ul>\n<p>This doesn\u2019t make presence perfectly certain, but it makes it <strong>truthful</strong> and stable. Offline becomes a derived state reached after confidence decays, not an event.</p>\n<p>In practice, this avoids flapping, handles tab closes and network hiccups gracefully, and gives downstream systems a much more useful signal than a boolean \u201conline\u201d flag.</p>\n<p>If you want a deeper explanation of this session-first, signal-based model (and why the older timestamp approach breaks down), this write-up covers it cleanly:</p>\n<p><a href=\"https://www.joegalaxy.net/docs/presence-online-offline\" rel=\"nofollow noreferrer\">https://www.joegalaxy.net/docs/presence-online-offline</a></p>\n", "tags": ["php"]}
