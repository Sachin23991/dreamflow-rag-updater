{"id": "fc2e0e40-e479-476d-8342-bbacc5e6d01a", "text": "Q: What are safe patterns for Service A to consume data from Service B without direct DB access? A: <p>The typical pattern would be to make a network request from Service A to Service B.</p>\n<p>Most often these days, it'd be either via REST or gRPC, but there are approximately too many ways to accomplish this.</p>\n", "tags": ["postgresql", "apache-kafka", "microservices", "api-design", "cdc"]}
{"id": "98ffa55d-b996-488a-846a-1403d00729b8", "text": "Q: Postgres replication corner case A: <p>Please ask a normal question. This is not &quot;advice&quot;. And the question had better be asked on DBA Stackexchange. And you should separate the issues of latency in synchronous replication and data loss due to disk failuere.</p>\n", "tags": ["postgresql", "database-replication"]}
{"id": "b8980095-510d-4d79-9029-ee03940ec05b", "text": "Q: How can I format a number with commas as thousands separators? A: <p>I challenge with another solution.</p>\n<p>The first code part was this:</p>\n<pre class=\"lang-js prettyprint-override\"><code>function formatNumber(number) {\n  if (number &lt; 1000) {\n    return String(number);\n  }\n  if (number &lt; 1000000) {\n    let numbers = String(number).split('');\n    numbers.splice(-3, 0, ',');\n    return numbers.join('');\n  }\n  if (number &lt; 1000000000) {\n    let numbers = String(number).split('');\n    numbers.splice(-3, 0, ',');\n    numbers.splice(-7, 0, ',');\n    return numbers.join('');\n  }\n  if (number &lt; 1000000000000) {\n    let numbers = String(number).split('');\n    numbers.splice(-3, 0, ',');\n    numbers.splice(-7, 0, ',');\n    numbers.splice(-11, 0, ',');\n    return numbers.join('');\n  }\n\n  throw new Error(`number: ${number} is too big`);\n}\n</code></pre>\n<p>This code is lengthy and not scalable, but it is effective because it checks the number itself, not the length of the string that was converted from the number.</p>\n<p>So I converted to neat code based on this idea.\n(You can make <code>12</code> bigger to prevent an error.)</p>\n<pre class=\"lang-js prettyprint-override\"><code>function formatNumber(number) {\n  let commas = -1;\n  for (let n3 = 3; n3 &lt;= 12; n3 += 3) {\n    commas++;\n    const max = Math.pow(10, n3);\n    if (number &lt; max) {\n      let numbers = String(number).split('');\n      for (let i = 0; i &lt; commas; i++) {\n        numbers.splice(-(3 * (i + 1) + i), 0, ',');\n      }\n      return numbers.join('');\n    }\n  }\n\n  throw new Error(`number: ${number} is too big`);\n}\n</code></pre>\n", "tags": ["javascript", "formatting", "numbers"]}
{"id": "79e84e50-ecfc-4d31-af4b-c8edcdfa1877", "text": "Q: Why is the WSL (Nat) able to reach to Vmware (Nat)? A: <p>That seems like completely ordinary IP routing. Packets from one VM reach your host system, which acts as a router \u2013 and since the host system is directly connected to both networks (i.e. has virtual interfaces belonging to each network), it inherently knows where to forward packets.</p>\n<ol>\n<li><p>WSL VM sends packet according to its default route (0.0.0.0/0 route) through the host.</p>\n</li>\n<li><p>Host receives packet through the Hyper-V virtual network interface, checks what routes it has for the destination.<br />\nThe destination network is directly attached (host directly has an interface configured in the same network), so of course the route is known.</p>\n</li>\n<li><p>Host forwards packet through the VMware virtual network interface.</p>\n</li>\n<li><p>VMware VM sends a reply packet \u2013 repeat basically the same steps.</p>\n</li>\n</ol>\n<p>NAT has no impact on this process, as it applies to source addresses but routing only cares about destination addresses (see note at the end).</p>\n<p>(If anything, NAT on the initial packet would only <em>help</em> the second VM send a response... but in this case, both networks are equally directly adjacent to the router, so routes exist in both directions and NAT basically has no impact anyway.)</p>\n<hr />\n<p>Note: Having outbound NAT doesn't automatically block inbound packets. When you think of your home LAN devices behind NAT being unreachable from the Internet, <strong>it isn't the NAT that makes them unreachable</strong> \u2013 rather, it's the <em>lack of routes</em> (which itself is caused by lack of public IP addresses and the necessity for private addresses) that makes your LAN unreachable from the outside, while NAT is actually a <em>mitigation</em> for the unreachability (i.e. given the situation, NAT is what helps your devices receive at least the 'reply' packets).</p>\n<p>But if the sender somehow <em>has</em> the correct routes all the way to the destination, then it can indeed send packets right into the NATed network. (A home router will have separate firewall &quot;filter&quot; rules to protect against that.)</p>\n", "tags": ["network-programming", "virtual-machine", "windows-subsystem-for-linux", "vmware", "nat"]}
{"id": "0ca826c5-d8d7-4e67-bd9d-3844262532b1", "text": "Q: C++ template parameter packs for math functions A: <p>You don't actually need a specialization for one argument.</p>\n<p>You can use the <a href=\"https://en.cppreference.com/w/cpp/language/fold.html\" rel=\"nofollow noreferrer\"><strong>fold-expression</strong></a> syntax to calculate the average in the following way:</p>\n<p>To get the sum of arguments use: <code>(... + args)</code>.<br />\nTo get the number of arguments use: <code>sizeof...(args)</code>.</p>\n<p>Put together:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename... Args&gt;\nauto average(Args... args) {\n    if constexpr (sizeof...(args) == 0) {\n        return 0.0;  // some default\n    }\n    else {\n        auto sum = (... + args);\n        return static_cast&lt;double&gt;(sum) / sizeof...(args);\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; average(10, 20, 30, 40) &lt;&lt; &quot;\\n&quot;;\n    std::cout &lt;&lt; average(33) &lt;&lt; &quot;\\n&quot;;\n    std::cout &lt;&lt; average() &lt;&lt; &quot;\\n&quot;;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>25\n33\n0\n</code></pre>\n<p><a href=\"https://godbolt.org/z/8G374EYYG\" rel=\"nofollow noreferrer\">Live demo</a></p>\n<p><strong>Note</strong> that the <code>if constexpr</code> is required to handle the case of no arguments (where the fold expression would fail to compile).</p>\n", "tags": ["c++", "templates", "variadic-templates", "parameter-pack"]}
{"id": "e8a97dbc-9309-48fa-b5b8-51cfacab194f", "text": "Q: Unable to run shell script from AzureDevops pipeline A: <p>I tested it in three tasks(Command line\n,Shell Exec\n,Bash\n) with a simple <code>.sh</code> file sample , every thing work well in these tasks , sh file executes normally.</p>\n\n<p><a href=\"https://i.sstatic.net/B4HhG.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/B4HhG.png\" alt=\"enter image description here\"></a>\n<a href=\"https://i.sstatic.net/brqfQ.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/brqfQ.png\" alt=\"enter image description here\"></a></p>\n\n<p>So can you share the <code>token.sh</code> sample file for further investigation? If there is any personal privacy information, please protect it.</p>\n", "tags": ["azure", "shell", "azure-devops", "azure-pipelines"]}
