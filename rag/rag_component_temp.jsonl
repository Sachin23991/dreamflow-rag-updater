{"id": "4ee8bffb-40de-47d4-84ec-74175b840db9", "text": "Q: How to get rid of unnecessary #includes in C++ code in visual studio 2026? A: <p>It works perfectly well for my own projects that are compiled with both GCC and clang on Linux and MSVC on Windows.</p>\n", "tags": ["c++"]}
{"id": "dc9d4fea-d396-4746-ade7-f151d15bc214", "text": "Q: I want to insert in A: <p>You cannot insert nested objects into related tables using Supabase\u2019s REST (PostgREST) API.<br />\nThe error occurs because PostgREST tries to insert the <code>position</code> object into a column that is defined as <code>bigint</code> (a foreign key), which results in:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>invalid input syntax for type bigint\n</code></pre>\n<p>Supabase REST only accepts <strong>scalar values</strong> for columns.<br />\nForeign-key columns must receive the referenced row\u2019s ID, not an object.</p>\n<hr />\n<h2>Correct approach</h2>\n<h3>1. Insert into <code>positions</code></h3>\n<pre><code>const posRes = await fetch(`${SUPABASE_URL}/rest/v1/positions`, {\n  method: &quot;POST&quot;,\n  headers: {\n    &quot;apikey&quot;: SUPABASE_ANON_KEY,\n    &quot;Authorization&quot;: `Bearer ${SUPABASE_ANON_KEY}`,\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n    &quot;Prefer&quot;: &quot;return=representation&quot;\n  },\n  body: JSON.stringify({\n    lat: 41.623655390686395,\n    lng: -0.6591796875\n  })\n});\n\nconst [position] = await posRes.json();\n</code></pre>\n<hr />\n<h3>2. Insert into <code>cities</code> using the returned ID</h3>\n<pre class=\"lang-js prettyprint-override\"><code>await fetch(`${SUPABASE_URL}/rest/v1/cities`, {\n  method: &quot;POST&quot;,\n  headers: {\n    &quot;apikey&quot;: SUPABASE_ANON_KEY,\n    &quot;Authorization&quot;: `Bearer ${SUPABASE_ANON_KEY}`,\n    &quot;Content-Type&quot;: &quot;application/json&quot;\n  },\n  body: JSON.stringify({\n    cityName: &quot;Alfajarin&quot;,\n    date: &quot;2025-12-17T13:52:08.812Z&quot;,\n    notes: &quot;&quot;,\n    emoji: &quot;\ud83c\uddea\ud83c\uddf8&quot;,\n    country: &quot;Spain&quot;,\n    position: position.id\n  })\n});\n</code></pre>\n", "tags": ["reactjs", "supabase"]}
{"id": "af4de21b-0a19-41c9-aca2-58d80ef0fd70", "text": "Q: imap_utf8 not always converting utf-8 text A: <p>The imap_utf8 function is designed to convert MIME-encoded text (like =?charset?encoding?encoded-text?=) to UTF-8.</p>\n<p>The issue you have encountered may be due to the input string, which may contain intended double quotes (U+0022 or &quot;fancy quotes&quot; like U+201C), is not a correctly formatted MIME header string according to RFC standards</p>\n<p>One of the possible causes of the above is due to improper encoding by the sending client.</p>\n<p>One of the workarounds is to use a function applying <code>imap_mime_header_decode</code> and <code>mb_convert_encoding</code> to perform the parsing job in a function.</p>\n<p>Please note that <code>mb_convert_encoding</code> is needed to convert text from its original charset to UTF-8, if necessary.</p>\n<p>so the function is:</p>\n<pre><code>function custom_imap_utf8_decode($mime_encoded_text) {\n    $decoded_elements = imap_mime_header_decode($mime_encoded_text);\n    $decoded_string = '';\n\n    foreach ($decoded_elements as $element) {\n        // Convert the text to UTF-8 from its original charset, if necessary\n        if ($element-&gt;charset != 'utf-8' &amp;&amp; $element-&gt;charset != 'default') {\n            $decoded_string .= mb_convert_encoding($element-&gt;text, 'UTF-8', $element-&gt;charset);\n        } else {\n            $decoded_string .= $element-&gt;text;\n        }\n    }\n    return $decoded_string;\n}\n</code></pre>\n<p>So the following is a working example code:</p>\n<pre><code>&lt;?php\n$original = '&quot;=?utf-8?Q?part1=40part2.com?=&quot; &lt;part1@part2.com&gt;' ;\n\n\nfunction custom_imap_utf8_decode($mime_encoded_text) {\n    $decoded_elements = imap_mime_header_decode($mime_encoded_text);\n    $decoded_string = '';\n\n    foreach ($decoded_elements as $element) {\n        // Convert the text to UTF-8 from its original charset, if necessary\n        if ($element-&gt;charset != 'utf-8' &amp;&amp; $element-&gt;charset != 'default') {\n            $decoded_string .= mb_convert_encoding($element-&gt;text, 'UTF-8', $element-&gt;charset);\n        } else {\n            $decoded_string .= $element-&gt;text;\n        }\n    }\n    return $decoded_string;\n}\n\n//$converted = imap_utf8($original) ;\n$converted = custom_imap_utf8_decode($original);\n\n\n//printf(&quot;Original: %s\\nConverted: %s\\n&quot;, $original, $converted) ;\necho &quot;Original:&quot;. $original;\necho &quot;&lt;br&gt;&quot;;\necho &quot;Converted:&quot;. $converted; \n?&gt;\n</code></pre>\n<p>The result will be:</p>\n<p><a href=\"https://i.sstatic.net/HsPLS2Oy.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/HsPLS2Oy.jpg\" alt=\"enter image description here\" /></a></p>\n", "tags": ["php", "utf-8", "imap", "decode"]}
{"id": "66267439-39ae-47fc-b47e-2a66df64ff84", "text": "Q: Dynamically adding properties to an ExpandoObject A: <p>As explained here by Filip - <a href=\"http://www.filipekberg.se/2011/10/02/adding-properties-and-methods-to-an-expandoobject-dynamicly/\" rel=\"nofollow noreferrer\">http://www.filipekberg.se/2011/10/02/adding-properties-and-methods-to-an-expandoobject-dynamicly/</a></p>\n<p>You can also add methods at runtime.</p>\n<pre><code>dynamic x = new ExpandoObject();\nvar y = x as IDictionary&lt;string, Object&gt;;\ny.Add(&quot;Shout&quot;, new Action(() =&gt; { Console.WriteLine(&quot;Hellooo!!!&quot;); }));\nx.Shout();\n</code></pre>\n", "tags": ["c#", "c#-4.0", "dynamic", "expandoobject"]}
{"id": "6a27f44f-f534-43d5-bfac-b61a7b53ae7d", "text": "Q: Perl expect - how to control timeout on target machine A: <p>I just found out something about the expect module. There is an undef option that can be used with expect like $exp->expect(undef). This will wait indefinitely and lets all commands finish their processing. But the problem is that, it does not return back the control to the host machine. There is one more option of using expect with eof which will wait until it encounters an eof and then returns to the host machine. Although no idea precisely how to use it. An elegant solution that I found is to use ssh to run commands on remote machine rather than using expect in which case we do not have to deal with timeouts. :)</p>\n", "tags": ["perl", "send", "expect"]}
