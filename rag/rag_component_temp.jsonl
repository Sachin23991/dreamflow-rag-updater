{"id": "4ce7fec6-7630-4e7a-be98-2a9f87f27e36", "text": "Q: How open a GIF image in with turtle? A: <p>Make sure that your python code and your gif is in the same folder and then try this code:</p>\n<pre><code>import turtle\nscreen = turtle.Screen()\nscreen.setup(500, 500) # You can change the dimensions(500, 500) to any number\nt = turtle.Turlte()\nscreen.addshape(&quot;name_of_the_gif.gif&quot;) #don't forget they have to be in the same file\nt.shape(&quot;name_of_the_gif.gif&quot;)# make the same gif as the screen.addshape\n</code></pre>\n", "tags": ["python", "turtle-graphics", "python-turtle", "animated-gif"]}
{"id": "52a9a092-49cb-4b03-bf1f-a64bb5a325b8", "text": "Q: Animated GIF with Python Turtle A: <p>I suggest to change <code>ImageLabel</code> from <code>tk.Label</code> to image item of <code>Canvas</code> as below:</p>\n\n<pre><code>class ImageLabel:\n    def __init__(self, canvas):\n        self.canvas = canvas\n\n    def load(self, im, x=0, y=0):\n        # create a canvas image item\n        self.image = self.canvas.create_image(x, y, image=None)\n        self.canvas.tag_lower(self.image)\n\n        if isinstance(im, str):\n            im = Image.open(im)\n\n        self.frames = []\n        try:\n            for i in count(1):\n                self.frames.append(ImageTk.PhotoImage(im.copy()))\n                im.seek(i)\n        except EOFError:\n            pass\n\n        try:\n            self.delay = im.info['duration']\n        except:\n            self.delay = 100\n\n        num_frames = len(self.frames)\n        if num_frames == 1:\n            self.canvas.itemconfig(self.image, image=self.frames[0])\n        else:\n            self.next_frame(0, num_frames)\n\n    def unload(self):\n        self.canvas.delete(self.image)\n        self.frames = None\n\n    def next_frame(self, loc, total):\n        if self.frames:\n            self.canvas.itemconfig(self.image, image=self.frames[loc])\n            loc = (loc + 1) % total\n            self.canvas.after(self.delay, self.next_frame, loc, total)\n</code></pre>\n\n<p>Then load it at specific position:</p>\n\n<pre><code>gif_window = tkinter_gif.ImageLabel(canvas)\ngif_window.load(\"giphy.gif\", -200, -200) # 0, 0 is the center of canvas\n</code></pre>\n", "tags": ["python", "tkinter", "turtle-graphics", "python-turtle", "animated-gif"]}
{"id": "26d477a3-f8a1-42bd-b0b5-0c398d0c200b", "text": "Q: How to play GIF&#39;s using turtle module in Python? A: <pre><code># in order to use GIF as shape you have to register them first\nfrom turtle import Screen\nfrom snake import Snake\nfrom food import Food\nfrom scoreboard import ScoreBoard\nimport time\n\n\nscreen = Screen()\nscreen.setup(width=600, height=600)\nscreen.bgpic(&quot;background.gif&quot;)\nscreen.title(&quot;Snake Game&quot;)\nscreen.tracer(0)\nscreen.register_shape(&quot;apple.gif&quot;)\nscreen.register_shape(&quot;snake.gif&quot;)\nscreen.register_shape(&quot;snake_head.gif&quot;)\nscreen.register_shape(&quot;snake_head_right.gif&quot;)\nscreen.register_shape(&quot;snake_head_up.gif&quot;)\nscreen.register_shape(&quot;snake_head_down.gif&quot;)\n\n</code></pre>\n<p>you can find more detailed information at <a href=\"https://docs.python.org/3/library/turtle.html#turtle.register_shape\" rel=\"nofollow noreferrer\">https://docs.python.org/3/library/turtle.html#turtle.register_shape</a></p>\n", "tags": ["python", "python-3.x", "turtle-graphics", "python-turtle"]}
{"id": "d3be76cb-9f73-45c9-9924-ecbe9f5f6bbf", "text": "Q: R lmer random effect variances depending on nested factors: lmer never stops A: <p><strong>tl;dr</strong> the main thing you have to do is set <code>control = lmerControl(calc.derivs = FALSE)</code>. By default in the current CRAN version of <code>lme4</code>, <code>lme4</code> tries to calculate a Hessian (second-derivative matrix) by finite differences. This takes approximately <code>n^2/2</code> function evaluations, where <code>n=51</code> for your first model and <code>n=247</code> for your second model ... In the current development version of <code>lme4</code>, these computations are automatically disabled for 'big' models (more than 1e4 observations or 10 parameters).</p>\n<p>On my machine (a fairly powerful desktop, but 5 years old), with these Hessian calculations disabled (by default, in the devel version) your first example takes about 14 seconds and the second takes about 68 seconds.</p>\n<p>However ... I suspect this is going to be tough even with the finite-difference Hessian calculations disabled. Your models have (model 1) 51 and 247 variance parameters to estimate (the fixed-effect parameters and residual variance are profiled out of the objective function, so they don't count toward the dimensionality of the problem). This means you'll be doing optimization over a 51- or 247-dimensional space, which is going to be slow/tough ... <code>glmmTMB</code> might do a little better, I'll try it out below.</p>\n<p>You're also going to need a <strong>lot</strong> of data to estimate 247 variance parameters ...</p>\n<p>I condensed a lot of your code into functions, it's at the end of the answer.</p>\n<h2>design 1</h2>\n<pre class=\"lang-r prettyprint-override\"><code>dat_aug1 &lt;- mk_data(G0 = 50, R0 = 50, ngr=10)\nform1 &lt;- mk_form(dat_aug1)\nf1 &lt;- lFormula(form1, data = dat_aug1)\n## dimensions of the random-effects covariance matrix\ndim(f1$reTrms$Lambdat)  ## 5000 x 5000\n## length of parameter vector\nlength(f1$reTrms$theta) ## 51\nsystem.time(\n  lmm &lt;- lmer(form1, data = dat_aug1,\n             verbose=2, control=lmerControl(optCtrl=list(maxeval=4)))\n)\n##  14 seconds\n</code></pre>\n<h2>design 2</h2>\n<pre class=\"lang-r prettyprint-override\"><code>dat_aug2 &lt;- mk_data(G0 = 246, R0 = 4, ngr=6)\nform2 &lt;- mk_form(dat_aug2)\nf2 &lt;- lFormula(form2, data = dat_aug2)\ndim(f2$reTrms$Lambdat)  ## 1968 x 1968\nlength(f2$reTrms$theta)  ## 247\nsystem.time(\n  update(lmm, formula = form2, data = dat_aug2)\n)\n## 62 seconds\n</code></pre>\n<pre class=\"lang-r prettyprint-override\"><code>library(glmmTMB)\nsystem.time(\n  lmm &lt;- glmmTMB(form1, data = dat_aug1,\n             verbose=2, control=glmmTMBControl(optCtrl=list(maxeval=4)))\n)\n</code></pre>\n<h2>glmmTMB</h2>\n<p><code>glmmTMB</code> takes 11 and 4 seconds, respectively, for designs 1 and 2, and might scale better to high-dimensional ('top-level', i.e. number of variance parameters) problems.</p>\n<pre class=\"lang-r prettyprint-override\"><code>library(glmmTMB)\nctrl &lt;- glmmTMBControl(optCtrl=list(iter.max=4))\nsystem.time(\n  lmm &lt;- glmmTMB(form1, data = dat_aug1,\n              verbose = TRUE, control = ctrl)\n)\n\nsystem.time(\n  update(lmm, formula = form2, data = dat_aug2)\n)\n</code></pre>\n<hr />\n<pre class=\"lang-r prettyprint-override\"><code>library(lme4)\nlibrary(tidyverse)\n\n## Return a vector equal to X whenever G = g or zero otherwise\nmake_xg &lt;- function(g, data) {\n    idx &lt;- as.integer(data$G == g)\n    data$X * idx\n}\n\nmk_data &lt;- function(G0, R0, ngr, a = 10, b = 20,\n                    sigma = 10, rho = 5) {\n  tau = 2 * sqrt(seq(1,G0))\n  n = G0 * R0 * ngr\n  alpha = rnorm(G0*R0, 0, rho)\n  betagr = rnorm(G0*R0, 0, 1)\n  betagr = betagr * rep(tau, each = R0)\n  dd &lt;- data.frame(G= rep(1:G0, each=R0*ngr),\n                   R = rep(rep(1:R0, each = ngr), G0)\n                   )\n  dd &lt;- transform(dd, \n                  rep = paste(&quot;R&quot;, G, &quot;-&quot;, R, sep=&quot;&quot;),\n                  X = sqrt(rep(1:G0, each=R0*ngr)),\n                  BG = rep(alpha, each=ngr),\n                  alpha = rep(alpha, each=ngr),\n                  beta = rep(betagr, each = ngr))\n  dd &lt;- transform(dd,\n                  y = a + alpha + (beta + BG + b) * X + rnorm(n, 0, sigma),\n                  G = factor(G))\n  lG &lt;- levels(dd$G)\n  dat_aug &lt;- dd |&gt; \n    bind_cols(\n        map(lG, ~ make_xg(., dd)) |&gt;\n            setNames(paste0('X', lG)) |&gt; \n            as_tibble()\n    )\n\n  return(dat_aug)\n}\n\nmk_form &lt;- function(dd) {\n  random.terms = paste0(&quot;X&quot;, levels(dd$G))\n  random.formula.part = paste(random.terms, collapse = &quot; + &quot;)\n  reformulate(c(&quot;X&quot;,&quot;G*X&quot;, &quot;(1|rep)&quot;, sprintf(&quot;(0 + %s || R)&quot;, random.formula.part)),\n              response=&quot;y&quot;)\n}\n</code></pre>\n", "tags": ["r", "model", "nested", "lme4"]}
{"id": "b58cbafd-0585-4936-a06f-827d7e3096d3", "text": "Q: How to type hint class tuple itself not instance without pylance complaining A: <p>You probably already know this, but this is a linting problem, not a type safety problem. <code>tuple[Any, ...]</code> is equivalent to <code>tuple</code>, so if you're absolutely sure that you want the latter (as you are in this case), it's safe to ignore the <a href=\"https://github.com/microsoft/pylance-release/blob/main/docs/diagnostics/reportMissingTypeArgument.md\" rel=\"nofollow noreferrer\"><code>reportMissingTypeArgument</code></a> diagnostic.</p>\n<p>The best way to do this is with a diagnostic-specific directive:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from pydantic import BaseModel\n\nclass Task1(BaseModel):\n    result_formatter: type[tuple] # pyright: ignore[reportMisingTypeArgument]\n</code></pre>\n<p>You can also disable the diagnostic globally, but do so with caution; it's a useful linting diagnostic, this is just a special case where it's wrong.</p>\n", "tags": ["python", "generics", "python-typing", "pydantic", "pyright"]}
{"id": "5f0cb185-b512-4561-8d95-e676c870e4dc", "text": "Q: Implementing Google Search in the search bar A: <p>Checkout:</p>\n\n<ul>\n<li><a href=\"http://johntwang.com/blog/2009/06/08/how-to-use-google-apis-with-iphone-sdk/\" rel=\"nofollow\">How To Use Google APIs with iPhone SDK</a></li>\n</ul>\n", "tags": ["iphone", "objective-c", "xcode", "ipad", "uisearchbar"]}
{"id": "7f1e6b72-9123-4404-b958-f8739dbf5fb0", "text": "Q: How can the operand of a dereference operator be of type &amp;mut T, but fail to be a mutable place expression? A: <p>&quot;The expression&quot; in this quote refers specifically to the operand of <code>*</code>, not the whole dereference.</p>\n<p>A pointer to mutable data can perfectly well be immutable itself.</p>\n<pre><code>let mut x: u8 = 5;\nlet mut y: &amp;mut u8 = &amp;mut x;\nlet z: &amp;&amp;mut u8 = &amp;y;\n**z = 0; // &quot;error: cannot assign to `**z`, which is behind a `&amp;` reference&quot;\n// *z is a non-mutable place expression of type &amp;mut u8\n// so **z cannot be assigned to\n</code></pre>\n", "tags": ["rust", "expression", "dereference"]}
