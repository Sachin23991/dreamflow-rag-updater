{"id": "87616780-9e11-4f61-b5d6-83424183f6c8", "text": "Q: Python Tkinter &quot;tag mechanism&quot; broken - _tkinter.TclError: invalid boolean operator in tag search expression A: <p>The root of the problem is that tkinter by default adds a <code>!</code> to the front of the name of each widget. The <code>!</code> is interpreted by the <code>find</code> command as a boolean operator. When passed to <code>find</code>, the string <code>.!canvas.!label</code> is treated as an expression. It is an invalid expression which is why you get the error &quot;_tkinter.TclError: invalid boolean operator in tag search expression&quot;</p>\n<p>These are all defined behaviors, but are an unfortunate consequence of the tkinter team choosing to add a <code>!</code> in front of dynamically created widget names.</p>\n<p>One answer to this question suggests removing the <code>!</code> from the widget name. That is a reasonable solution. I'll offer a separate solution, which is to give your widgets explicit names without the <code>!</code>. You can do this with the <code>name</code> parameter when creating the canvas and the label.</p>\n<p>This will create a tag with the text <code>&quot;.canvas.label&quot;</code>, which will work with your <code>find</code> command.</p>\n<pre><code>import tkinter as tk\n\nroot = tk.Tk()\ncnvs = tk.Canvas(root, name=&quot;canvas&quot;)\ncnvs.pack()\nlabl = tk.Label(cnvs, text='hello world', name=&quot;label&quot;)\nlaid = cnvs.create_window(0,0,window=labl,anchor='nw', tags=str(labl))\ntags = cnvs.gettags(laid)\ncnvs.find_withtag(tags)\nroot.mainloop()\n</code></pre>\n", "tags": ["python", "tkinter", "tcl"]}
{"id": "bab583fc-a729-40e0-be56-6dfb9a3551e3", "text": "Q: How can I remove extra indentation from CodeBlockItemListSyntax? A: <p>When you call <code>trimmedDescription</code> on <code>statements</code>, you are only trimming the <code>CodeBlockItemListSyntax</code>'s empty spaces (leading and trailing trivias). You actually need to individually get the trimmed descriptions of each underlying expression.</p>\n<pre class=\"lang-swift prettyprint-override\"><code>let closureString = closure.statements\n    .map(\\.trimmedDescription)\n    .joined(separator: &quot;\\n&quot;)\n</code></pre>\n<p>The reason this happens is because the list node conforms to <code>SyntaxProtocol</code> (via <code>SyntaxCollection</code>) and the <code>trimmedDescription</code> is implemented in <code>SyntaxProtocol</code> like so:</p>\n<pre class=\"lang-swift prettyprint-override\"><code>public var trimmedDescription: String {\n    return self.trimmed.description\n}\n\npublic var trimmed: Self {\n    return self.detached\n        .with(\\.leadingTrivia, [])\n        .with(\\.trailingTrivia, [])\n}\n</code></pre>\n<p>All of the list syntaxes behave this way.</p>\n", "tags": ["swift", "swift-macro", "swift-syntax"]}
{"id": "f6d98f4b-8022-4714-832f-ca06e5757fb7", "text": "Q: &quot;Cannot convert the &quot;System.Object[]&quot; value&quot; when reading and parsing JSON file in Powershell A: <p>To complement the helpful answer from <a href=\"https://stackoverflow.com/users/712649/mathias-r-jessen\">@Mathias</a>, this bug no longer exists in the newer versions of PowerShell (tested with version <code>7.5</code>).<br />\nFor each <strong>single element array</strong> in Windows PowerShell <code>5.1</code>, you might also use a <a href=\"https://learn.microsoft.com/powershell/module/microsoft.powershell.core/about/about_operators#subexpression-operator--\" rel=\"nofollow noreferrer\">subexpression</a>, like: <code>[List[Group]]$($json.groups)</code> to workaround this issue.\nThe reason that this is effective, is because it unwraps a single-element array and casting from a scalar to a <code>[List`1]</code> instance works fine:</p>\n<pre class=\"lang-bash prettyprint-override\"><code># for single element arrays:\n[List[Group]]$Json.Groups    # Produces an error (in Windows PowerShell)\n[List[Group]]$Json.Groups[0] # Works fine\n</code></pre>\n<p>In case it concerns a (large) object-graph converted from Json, you might consider to use the general <code>Restore-PS5ObjectFromJson</code> function below to recursively apply this on each single item array in the object-graph:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>using namespace System.Collections\nusing namespace System.Collections.Generic\nusing namespace System.Management.Automation\n\nfunction Restore-PS5ObjectFromJson($ObjectGraph) {\n    $Stack = [Stack]::new()\n    if ($null -ne $ObjectGraph) { $Stack.Push($ObjectGraph) }\n    while ($Stack.Count -gt 0) {\n        $Item = $Stack.Pop()\n        if ($Item -is [Array]) {\n            for ($i = 0; $i -lt $Item.Count; $i++) {\n                $Value = $Item[$i]\n                if ($Value -is [Array] -and $Value.Count -eq 1) { $Item[$i] = $($Value) }\n                $Stack.Push($Value)\n            }\n        }\n        elseif ($Item -is [PSCustomObject]) {\n            foreach ($Property in $Item.PSObject.Properties) {\n                $Value = $Property.Value\n                if ($Value -is [Array] -and $Value.Count -eq 1) { $Property.Value = $($Value) }\n                $Stack.Push($Value)\n            }\n        }\n    }\n}\n\n$Data = ConvertFrom-Json '{ &quot;groups&quot;:[ { &quot;name&quot;: &quot;test&quot; } ] }'\n\nif ($PSVersionTable.PSVersion -lt '6.0') { Restore-PS5ObjectFromJson $Data }\n\nclass Group { [string]$name }\n\n[List[Group]] $Data.groups\n\n</code></pre>\n<p>For more background on this issue, see <a href=\"https://stackoverflow.com/a/69855390/1701026\">this helpful answer</a> from <a href=\"https://stackoverflow.com/users/45375/mklement0\"><strong>mklement0</strong></a></p>\n", "tags": ["json", "powershell"]}
{"id": "d6db1289-b770-4428-b809-fad91b49e9ac", "text": "Q: Validate if input number is prime A: <p>You just needed to make your, Yes it's prime, leg into the else: of the for loop.  Then it works.  It is slow for large primes  Try 3333555227:</p>\n<pre><code>num = int(input(&quot;Provide number to check if prime: &quot;))\nif num &lt;=1:\n    print(&quot;Invalid choice, try again&quot;)\n    num = int(input(&quot;Provide number to check if prime: &quot;))\n\nfor i in range(2,num):\n    if num% i ==0:\n        print(&quot;Number is not prime&quot;)\n        break\nelse:\n    print(&quot;Number is prime&quot;)\n</code></pre>\n<p>This takes advantage of the conjecture that all primes greater than three are in the range 6k\u00b11 That is to say (6*1)\u00b11 = (5,7)  (6*10)\u00b11 = (59,61) There are many many cases where the numbers are not primes.  But the are are no cases of primes not in that range.  The mod 6 of the number will be either 5 for 6k-1 or 1 for 6k+1.  If it is not in that range drop it.  This gets rid of many many numbers we don't need to test at all. It also stops dividing at the square root of n because any number found after that would be one of a pair of factors.  It is about a thousand times faster than the divide from 2 to n tests for prime.  There are many many faster tests Miller-Raban and others.</p>\n<pre class=\"lang-py prettyprint-override\"><code>def k6Prime(n):\n   if n &lt;= 3: return n &gt; 1\n   if n%6 not in [1,5]: return False\n   for k6 in range(5,int(n**.5)+1,6):\n      if n%k6==0 or n%(k6+2)==0: return False\n   return True \n</code></pre>\n", "tags": ["python", "python-3.x", "numbers", "primes"]}
{"id": "45413ac7-b718-47eb-9144-1d7349ddf167", "text": "Q: else without if - can&#39;t see the issue A: <p>Basically, there are two variations of the <code>If</code>-statement:</p>\n<p>The &quot;normal&quot; one looks like this:</p>\n<pre><code>If ... Then\n    DoSomething\nElse\n    DoSomethingElse\nEnd If\n</code></pre>\n<p>And then there is a form where you put the statement directly after the <code>Then</code>:</p>\n<pre><code>If ... Then DoSomething\n</code></pre>\n<p>Using this form, the <code>If</code>-statement is seen as &quot;finished&quot;, there is not <code>Else</code>-branch expected (in theory, you could put the <code>Else</code> plus the command in the same line, but I have never seen or used that variation)</p>\n<p>You did exactly this with the statement</p>\n<pre><code>If Dir(strnewname) &lt;&gt; &quot;&quot; Then listsource.Cells(i, &quot;S&quot;).Value = &quot;checked and ready for import on&quot; &amp; Format(Date, &quot;dd/mm/yyyy&quot;)\n</code></pre>\n<p>... but you put an <code>Else</code> as next statement.</p>\n<p>So write instead</p>\n<pre><code>\nIf Dir(strExistingFile) &lt;&gt; &quot;&quot; Then\n    Call fso.Copyfile(strExistingFile, strnewname, True)\nElse\n    If Dir(strnewname) &lt;&gt; &quot;&quot; Then\n        listsource.Cells(i, &quot;S&quot;).Value = &quot;checked and ready for import on&quot; &amp; Format(Date, &quot;dd/mm/yyyy&quot;)\n    Else\n        listsource.Cells(i, &quot;S&quot;).Value = &quot;copy failed  on&quot; &amp; Format(Date, &quot;dd/mm/yyyy&quot;)\n    End If\n    listsource.Cells(i, &quot;S&quot;).Value = &quot;source file missing&quot;\nEnd If\n</code></pre>\n", "tags": ["excel", "vba"]}
{"id": "af43edf1-c29b-4feb-86bb-80548e8939f4", "text": "Q: Implementing voip in a MAUI application? A: <p>.NET 5 and later are .NET <em>Core</em> versions, a completely different platform from .NET <em>Framework</em> 4.8. It's not a matter of newer vs older. On top of that, VoIP is generally an OS service, unless you want to implement everything from scratch.</p>\n<p>That makes the question impossible to answer without knowing the OS. <em>Windows</em> VoIP services don't need Java or C++ bindings. Googling for <code>C# VoIP</code> I find <a href=\"https://learn.microsoft.com/en-us/uwp/api/windows.phone.networking.voip.voipphonecall?view=winrt-26100\" rel=\"nofollow noreferrer\">VoIPPhoneCall</a>, a deprecated class, which in turn links to the supported <a href=\"https://learn.microsoft.com/en-us/uwp/api/windows.applicationmodel.calls?view=winrt-26100\" rel=\"nofollow noreferrer\">Windows.ApplicationModel.Calls</a></p>\n<p>On the other hand, Android and AOSP services are generally available through Java interfaces.</p>\n<p>MAUI itself does offer abstractions, as the <a href=\"https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/communication/phone-dialer?view=net-maui-10.0&amp;tabs=windows\" rel=\"nofollow noreferrer\">Phone Dialer</a> example shows, which uses the classes in the <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.maui.applicationmodel.communication?view=net-maui-10.0\" rel=\"nofollow noreferrer\">Microsoft.Maui.ApplicationModel.Communication </a> namespace</p>\n", "tags": ["c#", "maui", "sip", "voip", ".net-9.0"]}
{"id": "fef8ebd3-152d-4156-a424-3d0a4c96bede", "text": "Q: Retrieve the error cause / exception from failed task instances A: <p>You could potentially <em>augment</em> its functionality or use a separate, custom XCom pushed within the failing task itself.</p>\n<hr />\n<p>You can wrap the logic of your source tasks in a <code>try...except</code> block. In the <code>except</code> block, you can push the exception details to XCom.</p>\n<pre class=\"lang-py prettyprint-override\"><code>from airflow.decorators import task\nfrom airflow.utils.state import TaskInstanceState\nimport traceback\n\n@task\ndef source_task_with_exception_logging():\n    try:\n        # Your task logic that might fail\n        raise ValueError(&quot;Something went wrong in source_task!&quot;)\n    except Exception as e:\n        # Push the exception details to XCom\n        task_instance = task_instance_context[&quot;ti&quot;] # Access the TaskInstance directly\n        task_instance.xcom_push(key=&quot;exception_details&quot;, value=str(e))\n        task_instance.xcom_push(key=&quot;exception_traceback&quot;, value=traceback.format_exc())\n        raise # Re-raise the exception so the task still fails\n</code></pre>\n<p>Then, in your <code>sink</code> task, you can retrieve these XCom values:</p>\n<pre class=\"lang-py prettyprint-override\"><code>@task(trigger_rule=TriggerRule.ALWAYS)\ndef sink_task(dag_run, **kwargs):\n    failed_tis = dag_run.get_task_instances([TaskInstanceState.FAILED])\n    for ti in failed_tis:\n        exception_details = ti.xcom_pull(task_ids=ti.task_id, key=&quot;exception_details&quot;, default=&quot;No exception details found.&quot;)\n        exception_traceback = ti.xcom_pull(task_ids=ti.task_id, key=&quot;exception_traceback&quot;, default=&quot;No traceback found.&quot;)\n        print(f&quot;Task {ti.task_id} failed with exception: {exception_details}&quot;)\n        print(f&quot;Traceback for {ti.task_id}:\\n{exception_traceback}&quot;)\n</code></pre>\n", "tags": ["airflow", "airflow-2.x", "airflow-taskflow"]}
