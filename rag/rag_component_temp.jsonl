{"id": "526ad0e0-12c6-455d-8b8a-10b566d0fdbe", "text": "Q: randomTrips.py hangs indefinitely on Windows; outputs written only after force termination A: <p>Root cause was MCP\u2019s sandboxed runtime blocking external binaries; switching from <code>subprocess</code> to SUMO\u2019s Python <code>randomTrips</code> API resolved the issue.</p>\n", "tags": ["python", "windows", "subprocess", "simulation", "sumo"]}
{"id": "43195df5-f653-4ae6-a7d2-0090eb4050e9", "text": "Q: POST request with list[UploadFile] results in HTTP 422: Unprocessable Entity A: <p>You need to construct <code>form_data</code> as a list of tuples, where each tuple represents a file and starts with the field name <code>&quot;files&quot;</code>.</p>\n<p>Change this line:</p>\n<pre class=\"lang-py prettyprint-override\"><code>form_data_for_httpx.append((&quot;files&quot;, (file.filename, file.file, file.content_type)))\n</code></pre>\n<p>Adding <code>files: list[UploadFile] = File(...)</code> is correct, but it wouldn't fix the issue with the client-side <code>form_data</code> construction.</p>\n", "tags": ["python", "fastapi", "httpx"]}
{"id": "b6d254d8-66ed-49de-b024-58d0a1ede4f1", "text": "Q: Create a trigger with clause to update only one specific row A: <p>Danilof, FranchPachot's example is the correct way to use triggers. Your method will only work with an AFTER statement-level (not row-level) trigger. And it would require optimal indexing. Why do that when you can intercept the value in-flight and prevent it from ever being set to the incorrect value in the first place? That's what the &quot;before update...for each row&quot; will do for you.</p>\n", "tags": ["sql", "oracle-database", "triggers", "sql-update", "oracle19c"]}
{"id": "f2182e30-41df-444c-9de5-45652a1c6437", "text": "Q: How can I best optimize a Bigquery SQL by appending completely redundant filters to the query? A: <p>If you <em>really</em> want to optimize this, then you need to break with the bad habit of storing identically-shaped JSON in table rows and change your table design to match your actual data: when you ingest the data (presumably from JSON?) then your ETL process should be responsible for extracting JSON data and mapping them to Big Table columns.</p>\n<p>...that way you can properly take full-advantage of Big Query's table partitioning and indexing.</p>\n", "tags": ["google-bigquery"]}
{"id": "bd1ffde6-512b-40ae-bf07-0bb7ce6f3ce5", "text": "Q: Parse error from using .setValue or .SetFormula to set a formula containing a query function that has multiple single and double quotes A: <p>Too easy! instead of <code>'+</code> just use <code>\\</code> to escape the single quotes in my formula so answer is:</p>\n<p><code>range.setFormula('=QUERY(Data!A1:G,&quot;select G, sum(E) where F is not null AND toDate(D)&gt;= date \\'&quot; &amp; text(\\'Settings\\'!B5, &quot;yyyy-MM-dd&quot;)&amp;&quot;\\' and toDate(D)&lt;= date \\'&quot; &amp; text(\\'Settings\\'!B6, &quot;yyyy-MM-dd&quot;)&amp;&quot;\\'group by G pivot B label G\\'Pivot table for data in range\\'&quot;)\\');</code></p>\n", "tags": ["google-sheets", "google-apps-script", "google-sheets-formula", "parse-error"]}
{"id": "b074914d-cc4c-44a8-8201-fa5ed7cfb2a2", "text": "Q: Complete SWIFT_STRICT_CONCURRENCY does not show errors for non thread-safe code A: <p>All your Tasks are running on the main actor, so there is no crossing of actor boundaries in your code. &quot;Sendable&quot; is the ability to cross actor isolation boundaries, so the compiler has no objection to your Sendable marking because you never ask an instance of this class to cross any actor isolation boundaries.</p>\n<p>So your code is not even multi-threaded, and the code does not crash because of anything having to do with concurrency; it crashes because you wrote an exclamation mark (<code>String!</code>), which means &quot;Crash me&quot;. Don't do that. Write it as <code>String?</code> and unwrap safely.</p>\n", "tags": ["swift", "swift6", "xcode26", "sendable"]}
