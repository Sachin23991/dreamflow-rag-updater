{"id": "41a652c4-02fc-451e-8cce-f7ed50a8186a", "text": "Q: Preview form in javascript A: <p>You can use <code>e.preventDefault()</code> in <code>Javascript</code>.</p>\n<pre class=\"lang-html prettyprint-override\"><code>&lt;form onsubmit=&quot;preview(event)&quot;&gt;\n    ...\n&lt;/form&gt;\n</code></pre>\n<pre class=\"lang-js prettyprint-override\"><code>const preview = (e) =&gt; {\n    e.preventDefault();\n    const form = $(e.target);\n\n    form.find(&quot;input&quot;).forEach(inp =&gt; {\n        console.log(inp.value)\n    })\n}\n</code></pre>\n", "tags": ["javascript", "jquery", "onsubmit"]}
{"id": "477a2a50-ca82-4b46-8c55-06b46cd88b97", "text": "Q: How is TinyVec the same size as Vec? A: <p>This answer assumes a 64-bit platform.</p>\n<p>There are a few parts here.</p>\n<p>Firstly one of the fields in Vec is a &quot;notnull pointer&quot;. 8 bytes in size, and with a single invalid value available for niche optimisations. There are two other fields which come to a total of 16 bytes in size.</p>\n<p>Secondly this field is located at one end of the representation of the Vec. More recent versions of rustc will re-order fields to achieve this, but the standard libraries Vec type has this layout in the source code.</p>\n<p>So when it comes to lay out your AinyVec with a capacity of 14 or lower, the compiler can determine that.</p>\n<ul>\n<li>The largest variant is the Vec</li>\n<li>The Vec has a field available for niche optimisation.</li>\n<li>After using that field for niche optimisation there are 16 bytes available for the other variant.</li>\n<li>The arrayvec is 16 or less bytes in size (14 for data, 2 for length)</li>\n<li>Niche optimisation is possible.</li>\n<li>Overall size is 24</li>\n</ul>\n<p>If the tinyvec's capacity is 15-28 bytes then the tinyvec ends up 32 bytes in size. There is no longer space to fit the arrayvec around the Vec's niche and alignment requirements means 32 bytes is the next available size.</p>\n<p>If the tinyvec's capacity is 29 bytes then we run into an annoying corner case, our ArrayVec ends up with a padding byte making it 32-bytes in size. Unfortunately padding bytes cannot be used for niche optimisations so the overall structure is pushed over the limit and ends up 40 bytes in size.</p>\n", "tags": ["rust"]}
{"id": "d3855f6f-6919-4964-be46-9c7dff5485e6", "text": "Q: React useEffect with div reference dependency updated on first setState in component A: <p>Don't use <strong>ref.current</strong> as a dependency. Refs are mutable and React doesn't track their changes. If you need to respond to a ref being attached, use a callback ref:</p>\n<pre class=\"lang-jsx prettyprint-override\"><code>function RefUpdated() {\n  const [container, setContainer] = useState&lt;HTMLDivElement | null&gt;(null);\n  const [counter, setCounter] = useState(0);\n\n  // Callback ref called when element is attached/detached\n  const containerRef = useCallback((node: HTMLDivElement | null) =&gt; {\n    console.log(&quot;Container ref changed&quot;, node);\n    setContainer(node);\n  }, []);\n\n  return (\n    &lt;div id=&quot;container&quot; ref={containerRef}&gt;\n      &lt;p&gt;Counter: {counter}&lt;/p&gt;\n      &lt;p&gt;\n        &lt;button onClick={() =&gt; setCounter(c =&gt; c + 1)}&gt;inc&lt;/button&gt;\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n", "tags": ["javascript", "reactjs", "hook"]}
{"id": "cf8ec7a5-e6a8-4ea4-9cf0-946184427d39", "text": "Q: Epson SureLab 1070DE / SL-D1000: Why is duplex (two-sided) printing disabled unless DS media is selected? A: <p>On the SureLab 1070DE / SL-D1000 series, <strong>duplex printing is only enabled when the Media Type is a DS-series paper profile</strong>. These have names like:</p>\n<ul>\n<li><p><strong>SureLab Photo Paper Gloss \u2013 DS(225)</strong></p>\n</li>\n<li><p><strong>SureLab Photo Paper Gloss \u2013 DS(190)</strong></p>\n</li>\n<li><p><strong>SureLab Photo Paper Luster \u2013 DS(225)</strong></p>\n</li>\n<li><p><strong>SureLab Photo Paper Luster \u2013 DS(190)</strong></p>\n</li>\n</ul>\n<p>If you select any non-DS media (Gloss 250, Luster 250, Matte, Card Stock, etc.), the Epson driver disables all duplex options because those papers are not flagged internally as duplex-capable.</p>\n<p>This behavior is not documented by Epson, and support confirmed they were unaware of it.</p>\n<p><strong>Solution:</strong><br />\nSelect a DS(###) media type in <em>Media Type \u2192 SureLab Photo Paper Gloss/Luster \u2013 DS(###)</em>, and the duplex options will appear.</p>\n", "tags": ["printing", "epson"]}
{"id": "ef6f0e49-606a-4121-93ac-b8dc860d7ba6", "text": "Q: how to get a result from a query where the first columns do not repeat their value until it changes A: <p>It should also be possible to do this without <code>LEAD()</code> or <code>LAG()</code> or comparing those rows to one another.</p>\n<pre><code>WITH cte AS\n    (select isnull(d.FirstName, '') + ' ' + isnull(d.LastName, '') as Chauffeur,\n            t.securysatnr,\n            convert(date, p.PlanningDate) as Datum,\n            p.StartTime as LaadUur,\n            r.LotNr,\n            isnull(pFrom.City, '') + ' - ' + isnull(pTo.City, '') as RitInfo,\n    ROW_NUMBER() OVER (PARTITION BY (isnull(d.FirstName, '') + ' ' + isnull(d.LastName, '')),\n                                    t.securysatnr,  -- maybe you don't need all of these, or they're derivable from columns in the tables (e.g. d.UserId)\n                                    convert(date, p.PlanningDate),\n                                    p.StartTime,\n                                    r.LotNr,\n                                    isnull(pFrom.City, '') + ' - ' + isnull(pTo.City, '')\n                        ORDER BY isnull(d.FirstName, '') + ' ' + isnull(d.LastName, ''),\n                                convert(date, p.PlanningDate),\n                                p.StartTime) AS SortOrder\n    from   tblPlanning p\n    left outer join vwRit r on p.RitID = r.RitID\n    left outer join tblPlace pFrom on r.VertrekID = pFrom.PlaceID\n    left outer join tblPlace pTo on r.BestemmingID = pTo.PlaceID\n    inner join tblDriver d on p.DriverID = d.DriverID\n    inner join tblTruck t on p.TruckID = t.TruckID\n    where  convert(date, p.PlanningDate) &gt;= convert(date, getdate())\n    order by Chauffeur, convert(date, p.PlanningDate), p.StartTime)\nSELECT  CASE cte.SortOrder\n            WHEN 1\n                THEN cte.Chauffeur\n            ELSE ''     -- or NULL\n        END AS Chauffeur,\n        CASE cte.SortOrder\n            WHEN 1\n                THEN cte.securysatnr\n            ELSE ''\n        END AS securysatnr,\n        cte.Datum,\n        cte.LaadUur,\n        cte.LotNr,\n        cte.RitInfo\nFROM    cte\nORDER BY SortOrder;\n</code></pre>\n", "tags": ["sql", "sql-server", "t-sql"]}
{"id": "d6feb1cb-3172-4476-9bb3-5296657e9e44", "text": "Q: How to extract contours for each stacked bag (web sling) in a depth image using OpenCV? A: <p>@<a href=\"/users/31375776/thorsten-gudera\">Thorsten Gudera</a> Thank you for the detailed explanation and images. Your illumination/flattening is just what I mentioned by the name of division normalization. I have posted many solutions using that on this forum.  Thanks for the explanation. That allowed me to know that it is the same as what I called division normalization.</p>\n", "tags": ["python", "opencv", "image-processing"]}
