{"id": "088858d2-a175-4b06-b445-ad165c59f58d", "text": "Q: Hosting external web app in Microsoft Teams tab and sharing with all meeting participants A: <p>Thank you @sayali-msft, if you'd like to post a response I'll mark it as the answer.</p>\n", "tags": ["microsoft-teams", "teams-toolkit"]}
{"id": "71d4fd06-741c-4f03-a24c-c8063fc532f0", "text": "Q: multiple dongles for bluetooth A: <p>The short answer - no, it is not possible.</p>\n", "tags": ["bluetooth"]}
{"id": "dcc9df37-6160-4215-b49a-c70c618b91f5", "text": "Q: calling sync functions from async function A: <p>With Python version 3.9 and later, you can use <code>asyncio.to_thread</code> to offload blocking task to a separate thread, that is usually performing I/O operations or is CPU intensive task.</p>\n<p>Based on your example</p>\n<pre><code>import asyncio  # I added this\n\n\ndef long_running_task(task):\n    result = some_synchronous_function(task)\n    return result\n\n@app.route('/&lt;task&gt;', methods=['GET'])\nasync def do_task(task):\n    ok = await asyncio.to_thread(long_running_task(task))  # I changes this\n    if ok:\n        return (ok.result)\n    else:\n        return ('Something went wrong')\n\n</code></pre>\n<p>This solution boils down to what @J. Taylor wrote!</p>\n", "tags": ["python", "python-asyncio", "quart"]}
{"id": "377da081-0ae9-4d2f-b4a3-3acd5cf82e09", "text": "Q: What are terminal and nonterminal symbols? A: <p>Think of it this way.</p>\n<p>A <strong>digit</strong> can be any number from <strong>1 to 9</strong>.</p>\n<p>Now imagine I ask you to write <strong>a digit</strong> on a piece of paper.</p>\n<p>You know that means you can write:</p>\n<pre><code>1, 2, 3, 4, 5, 6, 7, 8, or 9\n</code></pre>\n<p>In this situation:</p>\n<ul>\n<li><p><strong>digit</strong> is a <strong>nonterminal symbol</strong></p>\n</li>\n<li><p><strong>1\u20139</strong> are <strong>terminal symbols</strong></p>\n</li>\n</ul>\n<p>When I ask you to write a digit, you do <strong>not</strong> write the word <code>&quot;digit&quot;</code>.<br />\nInstead, you write one of the symbols it represents: <code>1</code>, <code>2</code>, <code>3</code>, etc.</p>\n<p>Only <strong>terminal symbols</strong> ever appear on the page.</p>\n<hr />\n<h3>Creating our own rules</h3>\n<p>Let\u2019s define our own nonterminal symbol called <strong>Olaf</strong>.</p>\n<p>We define the following rules:</p>\n<ul>\n<li><p><strong>Olaf can be <code>dog</code></strong> (dog is a terminal)</p>\n</li>\n<li><p><strong>Olaf can be <code>cat</code></strong> (cat is a terminal)</p>\n</li>\n<li><p><strong>Olaf can be <code>digit</code></strong> (digit is a nonterminal)</p>\n</li>\n</ul>\n<p>Now, if I tell you to write an <strong>Olaf</strong> on the page, you have several valid choices:</p>\n<ul>\n<li><p>You can write <code>dog</code></p>\n</li>\n<li><p>You can write <code>cat</code></p>\n</li>\n<li><p>You can write a digit, which means you write <code>1</code>, <code>2</code>, <code>3</code>, etc.</p>\n</li>\n</ul>\n<p>Again, since <strong>digit</strong> is a nonterminal, you don\u2019t write the word <code>&quot;digit&quot;</code>.<br />\nYou write one of the terminal symbols that <strong>digit</strong> refers to.</p>\n<p>In the end, <strong>only terminal symbols appear on the page</strong>.</p>\n<hr />\n<h3>Production rules</h3>\n<p>When we say <em>\u201ca nonterminal can be something\u201d</em>, there is a formal term for this:<br />\nit is called a <strong>production rule</strong> (or simply a <strong>production</strong>).</p>\n<p>For example, these are production rules:</p>\n<pre><code>Olaf \u2192 dog\nOlaf \u2192 cat\nOlaf \u2192 &lt;digit&gt;\n</code></pre>\n<p>Here, we have <strong>three productions</strong>, which means we have <strong>three definitions</strong> of <code>Olaf</code>.</p>\n<hr />\n<h3>Root (start symbol)</h3>\n<p>A context-free grammar is not complete unless we specify a <strong>root</strong> (also called the <strong>start symbol</strong>).</p>\n<p>Formally, the start symbol is <strong>usually a nonterminal</strong>, but in theory it <strong>does not have to be</strong>. You <em>could</em> choose a terminal symbol as the start symbol.</p>\n<p>However, if the start symbol is a terminal, the grammar becomes trivial and essentially useless: the language would contain exactly that one terminal symbol, and no derivation or structure would be involved.</p>\n<p>In practice, we choose a <strong>nonterminal</strong> as the start symbol because it allows derivations to take place. Every valid string in the language must be <strong>derived from this start symbol</strong>, and the derivation continues until only terminal symbols remain.</p>\n<p>In this example, the chosen start symbol is:</p>\n<pre><code>Olaf\n</code></pre>\n<hr />\n<h3>Why this matters</h3>\n<p>These ideas are used extensively in <strong>programming language specifications</strong>.<br />\nGrammars define the <strong>syntax</strong> of a language using:</p>\n<ul>\n<li><p><strong>Nonterminal symbols</strong></p>\n</li>\n<li><p><strong>Terminal symbols</strong></p>\n</li>\n<li><p><strong>Production rules</strong></p>\n</li>\n</ul>\n<p>This is the foundation of how programming languages are formally described.</p>\n<hr />\n<h3>Simple programming language example (context-free grammar)</h3>\n<p>Programming languages are defined using the exact same idea.</p>\n<p>Here is a very small grammar for a toy programming language that supports numbers and addition.</p>\n<p>The <strong>root symbol</strong>(aka <strong>start symbol</strong>) is <code>&lt;program&gt;</code>.</p>\n<pre><code>&lt;program&gt;    \u2192 &lt;expression&gt;\n&lt;expression&gt; \u2192 &lt;number&gt; | &lt;number&gt; &quot;+&quot; &lt;number&gt;\n&lt;number&gt;     \u2192 &lt;digit&gt; | &lt;digit&gt; &lt;number&gt;\n&lt;digit&gt;      \u2192 &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;\n</code></pre>\n<p>This grammar allows programs such as:</p>\n<pre><code>3\n42\n7+9\n12+34\n</code></pre>\n", "tags": ["grammar", "context-free-grammar", "rebol", "red-lang"]}
{"id": "961d927f-9131-4878-a81d-30273c04f8bd", "text": "Q: Output PIN from a MAC address using char A: <p>Is this what you need?</p>\n\n<pre><code>unsigned char pin[6];   // Unsigned ...\npin[0] = 0x61;\npin[1] = 0xC7;\npin[2] = 0x5E;\npin[3] = 0x00;\npin[4] = 0x9E;\npin[5] = 0xCC;\n\nprintf(\"%02x:%02x:%02x:%02x:%02x:%02x\\n\",pin[0],pin[1],pin[2],pin[3],pin[4],pin[5]);\n</code></pre>\n\n<p>will print</p>\n\n<pre><code>61:c7:5e:00:9e:cc\n</code></pre>\n\n<p>Explanation:</p>\n\n<pre><code>%x   // Print a number in hexadecimal format using lower case (%X for upper case)\n%2x  // Print at least 2 characters (prepend with space)\n%02x // Print at least 2 characters and prepend with 0\n</code></pre>\n\n<p>Use <code>unsigned char pin[6]</code> to avoid sign extention during print. If you use <code>char pin[6]</code> you'll get</p>\n\n<pre><code>61:ffffffc7:5e:00:ffffff9e:ffffffcc\n</code></pre>\n\n<p>which is probably not what you want.</p>\n\n<p>If you for some reason need to use <code>char</code>, you can do:</p>\n\n<pre><code>char pin[6];\npin[0] = 0x61;\npin[1] = 0xC7;\npin[2] = 0x5E;\npin[3] = 0x00;\npin[4] = 0x9E;\npin[5] = 0xCC;\n\nprintf(\"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\\n\",pin[0],pin[1],pin[2],pin[3],pin[4],pin[5]);\n           ^^\n           Force type to char\n</code></pre>\n", "tags": ["c", "char", "mac-address", "wiimote"]}
{"id": "8d8f05c5-823c-4b16-a683-5effb738d495", "text": "Q: API response is in stream. How should I convert that in dart so I can show it in the UI? A: <p>Use LineSplitter it handles the buffering:</p>\n<pre class=\"lang-dart prettyprint-override\"><code>final stream = streamedResponse.stream\n    .transform(utf8.decoder)\n    .transform(const LineSplitter());\n\nawait for (final line in stream) {\n  if (line.startsWith(&quot;agent-stream-start:&quot;)) {\n    yield line.replaceFirst(&quot;agent-stream-start:&quot;, &quot;&quot;).trim();\n  }\n}\n</code></pre>\n<p>No need manually acumulate chunks.</p>\n", "tags": ["flutter", "stream", "fastapi"]}
{"id": "b163000c-307d-4de6-b7db-483475aa7364", "text": "Q: Managing async Tasks when shutdown occurs in .Net apps A: <p>You would need to wait for any write operation to complete before shutting down. One way to do this would be for any users of <code>MessageSaver</code> to implement <code>IAsyncDisposable</code> where they await any save operations that are currently being processed.</p>\n<p>Another option would be to save a list of all currently processed save tasks so they can be awaited before shutting down. One fairly straightforward way to do this is to use a blockingQueue:</p>\n<pre><code>public class MessageSaver : IAsyncDisposable\n{\n    private record SaveTask(TaskCompletionSource Tcs, string FilePath, string Content);\n    private BlockingCollection&lt;SaveTask&gt; queue = new();\n    private readonly Task processTask;\n\n    public MessageSaver() =&gt; processTask = Task.Run(ProcessQueue);\n\n    public Task SaveMessageAsync(string filePath, string content)\n    {\n        var tcs = new TaskCompletionSource();\n        queue.Add(new SaveTask(tcs, filePath, content));\n        return tcs.Task;\n    }\n    private async Task ProcessQueue()\n    {\n        foreach (var (tcs, filePath, content) in queue.GetConsumingEnumerable())\n        {\n            try\n            {\n                await using FileStream stream = File.OpenWrite(filePath);\n                await using StreamWriter sw = new StreamWriter(stream);\n                await sw.WriteLineAsync(content);\n                tcs.SetResult();\n            }\n            catch (Exception e)\n            {\n                tcs.SetException(e);\n            }\n        }\n    }\n\n    public async ValueTask DisposeAsync()\n    {\n        queue.CompleteAdding();\n        await processTask;\n    }\n}\n</code></pre>\n<p>Once you have called <code>DisposeAsync</code>, <code>SaveMessageAsync</code> will throw if you try to add any more things to save, but any queued items will be processed before <code>DisposeAsync </code>completes. You can optionally use a cancellation token to complete writing of the current item, but skip any in the queue. You might also want to add some kind of timeout or cancellation mechanism in case the saving of an item is unacceptably slow. Do note that this will serialize all the writing, this may be a good thing if you are using a spinning disk, but may slightly affect throughput for an SSD.</p>\n", "tags": ["c#", "asynchronous", "task", "application-shutdown"]}
