{"id": "c294578f-912d-48ba-ba7d-5992a200ced1", "text": "Q: Easy Localization: Localization key [...] not found A: <p>The error:</p>\n<blockquote>\n<p><code>&quot;Easy Localization: Localization key [...] not found&quot;</code></p>\n</blockquote>\n<p>usually happens because <strong>the key is not loaded correctly</strong> from your CSV file, or the structure of the CSV is not what <code>CsvAssetLoader</code> expects.</p>\n<h3>Things to check</h3>\n<ol>\n<li><strong>CSV format</strong><br />\n<code>CsvAssetLoader</code> expects a CSV where the <strong>first row is the keys</strong> and the following rows are the translations for each locale. For example:</li>\n</ol>\n<pre><code>key,en,it,es,de,fr,pt\nmenu,Menu,Menu,Men\u00fa,Men\u00fc,Menu,Menu\nsettings,Settings,Impostazioni,Ajustes,Einstellungen,Param\u00e8tres,Configura\u00e7\u00f5es\n</code></pre>\n<p>Make sure your CSV matches this structure. If your keys are in the first column and translations in the following columns, Easy Localization will not find them.</p>\n<hr />\n<ol start=\"2\">\n<li><strong>Path correctness</strong><br />\nYour path is <code>'resources/langs/langs.csv'</code>. Make sure it matches <strong>exactly</strong> the folder structure, and that the file is listed in <code>pubspec.yaml</code> under <code>assets</code>:</li>\n</ol>\n<pre><code>flutter:\n  assets:\n    - resources/langs/langs.csv\n</code></pre>\n<hr />\n<ol start=\"3\">\n<li><strong>Locale codes</strong><br />\nYou are using <code>Locale('en', '')</code> and <code>useOnlyLangCode: true</code>. Make sure the CSV header matches exactly (<code>en</code>, <code>it</code>, <code>es</code>, etc.), otherwise the loader won\u2019t find the translation.</li>\n</ol>\n<hr />\n<ol start=\"4\">\n<li><strong>Debugging</strong><br />\nYou can print the loaded map to verify the keys:</li>\n</ol>\n<pre><code>print(context.localizationLoader.load('en'));\n</code></pre>\n<hr />\n<h3>Alternative approach for easier scaling</h3>\n<p>Managing CSV files for multiple languages can become messy fast. For larger apps or SaaS, using a localization platform like <strong><a href=\"https://azbox.io\" rel=\"nofollow noreferrer\">AZbox</a></strong> can simplify everything: centralized translations, multi-language support, AI suggestions, and updates without redeploying your app.</p>\n", "tags": ["android-studio", "flutter", "localization"]}
{"id": "121b06fc-9542-441c-bc3e-476966abea49", "text": "Q: How can I make the animation revert back smoothly in CSS A: <p>Use transition instead of <code>@keyframes</code> animation. This will solve both problems:</p>\n<ol>\n<li>Transition dont play when page is loading</li>\n<li>When you stop hover in the middle, animation will start from current position, not from beginning</li>\n</ol>\n<pre class=\"lang-css prettyprint-override\"><code>.text {\n    font-weight: 300;\n    transform: translateX(0px);\n    transition: font-weight 0.8s cubic-bezier(0, .29, .22, .99),\n                transform 0.8s cubic-bezier(0, .29, .22, .99);\n    cursor: pointer;\n    margin-top: 1rem;\n}\n\n.text:hover {\n    font-weight: 900;\n    transform: translateX(20px);\n}\n</code></pre>\n<p>Problem with keyframes is that they always played from 0 to 100. So if user moves cursor away in middle, the reverse animation start from its own 0 and you get a jump. Transitions automatically know where element currently is and animate from there.</p>\n", "tags": ["html", "css", "css-animations"]}
{"id": "46f61be3-cbbe-4355-be50-5306ea63de04", "text": "Q: ASIC chip change A: <p>No, you can't. That's why projects will use <a href=\"https://www.youtube.com/watch?v=m-8G1Yixb34\" rel=\"nofollow noreferrer\">an FPGA</a> instead of an ASIC when they're still iterating on the design.</p>\n<p>...though <em>subcomponents</em> of an ASIC might involve microcode loaded into reprogrammable ROM, which could be erased and re-programmed, though obviously this isn't the same thing as changing the circuit design.</p>\n", "tags": ["cryptocurrency"]}
{"id": "87a569b3-a6c6-463a-af91-731f5df4a60d", "text": "Q: How to assign a std::string from std::put_time in C++? A: <p>You can use <a href=\"http://en.cppreference.com/w/cpp/io/basic_stringstream.html\" rel=\"nofollow noreferrer\"><code>std::stringstream</code></a> to stream <code>std::put_time</code> into,<br />\nand then use <a href=\"http://en.cppreference.com/w/cpp/io/basic_stringstream/str.html\" rel=\"nofollow noreferrer\"><code>std::stringstream::str()</code></a> to convert to a <code>std::string</code>:</p>\n<pre><code>#include &lt;ctime&gt;    // for std::time, std::localtime\n#include &lt;iostream&gt; // for std::cout\n#include &lt;iomanip&gt;  // for std::put_time\n#include &lt;sstream&gt;  // for std::stringstream\n\nint main() {\n    auto t = std::time(nullptr);\n    auto tm = *std::localtime(&amp;t);\n    std::stringstream ss;\n    ss &lt;&lt; std::put_time(&amp;tm, &quot;%d-%m-%Y %H-%M-%S&quot;);\n    std::string s = ss.str();\n    std::cout &lt;&lt; s &lt;&lt; &quot;\\n&quot;;\n}\n</code></pre>\n<p>Possible output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>13-12-2025 17-07-16\n</code></pre>\n<p><a href=\"https://godbolt.org/z/9K73d3Mb6\" rel=\"nofollow noreferrer\">Live demo 1</a></p>\n<hr />\n<p><strong>Update:</strong><br />\nAs @RemyLebeau <a href=\"https://stackoverflow.com/questions/79846630/how-to-assign-a-stdstring-from-stdput-time-in-c/79846636#comment140902268_79846636\">commented</a>, since we use the string stream for streaming <em>into it only</em>, it's better to use <a href=\"https://en.cppreference.com/w/cpp/io/basic_ostringstream.html\" rel=\"nofollow noreferrer\"><code>std::ostringstream</code></a> (instead of <code>std::stringstream</code>).</p>\n<p><a href=\"https://godbolt.org/z/47PxbW5r1\" rel=\"nofollow noreferrer\">Live demo 2</a></p>\n", "tags": ["c++", "time", "casting", "stdstring"]}
{"id": "575ce1df-085c-489a-9379-8d63061b83a2", "text": "Q: Flutter change Localization programatically A: <p>Yes, it\u2019s absolutely possible to change the <code>Locale</code> at runtime when the user taps a button.</p>\n<p>Flutter just doesn\u2019t do it automatically \u2014 you need to <strong>store the selected locale in state</strong> and rebuild <code>MaterialApp</code> when it changes.</p>\n<h3>Basic approach</h3>\n<p>Wrap your <code>MaterialApp</code> in a <code>StatefulWidget</code> and control the <code>locale</code> property:</p>\n<pre><code>class MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =&gt; _MyAppState();\n}\n\nclass _MyAppState extends State&lt;MyApp&gt; {\n  Locale _locale = const Locale('en');\n\n  void setLocale(Locale locale) {\n    setState(() {\n      _locale = locale;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      locale: _locale,\n      supportedLocales: AppLocalizations.supportedLocales,\n      localizationsDelegates: AppLocalizations.localizationsDelegates,\n      home: MyHomePage(onLocaleChange: setLocale),\n    );\n  }\n}\n</code></pre>\n<p>Then, from your button:</p>\n<pre><code>ElevatedButton(\n  onPressed: () {\n    widget.onLocaleChange(const Locale('es'));\n  },\n  child: Text('Spanish'),\n);\n</code></pre>\n<p>This triggers a rebuild and updates all localized strings instantly.</p>\n<hr />\n<h3>Persisting the language</h3>\n<p>If you want the selected language to persist across app restarts, store it using <code>SharedPreferences</code> and restore it on startup.</p>\n<hr />\n<h3>Alternative (scales better)</h3>\n<p>For larger apps, managing locales via a state management solution (Provider, Riverpod, Bloc) keeps things cleaner and avoids passing callbacks around.</p>\n<hr />\n<h3>Bonus: simplifying localization</h3>\n<p>If you\u2019re frequently adding languages or updating translations, managing ARB files manually can get painful. Tools like <strong>AZbox (<a href=\"https://azbox.io\" rel=\"nofollow noreferrer\">https://azbox.io</a>)</strong> help centralize translations, sync them automatically, and even update texts without redeploying the app.</p>\n<p>Hope that helps \ud83d\udc4d</p>\n", "tags": ["flutter", "localization"]}
{"id": "9ff93be1-eaf6-4108-8e9f-6dfee30f0645", "text": "Q: Flutter localization A: <p>The error:</p>\n<blockquote>\n<p><code>The method 'translate' was called on null</code></p>\n</blockquote>\n<p>means that <strong><code>AppLocalizations.of(context)</code> is returning null</strong>, so you\u2019re calling <code>translate()</code> on a null object.</p>\n<p>This usually happens because the <code>BuildContext</code> you\u2019re using is <strong>above the <code>MaterialApp</code></strong>, so the localization delegates are not yet available.</p>\n<h3>What\u2019s going wrong</h3>\n<p>In your code, <code>MaterialApp</code> is created <strong>inside</strong> the <code>build()</code> method of <code>forside</code>, and then you try to access <code>AppLocalizations.of(context)</code> <strong>inside the same widget tree</strong>.<br />\nAt that point, the <code>context</code> does not yet contain the localization data.</p>\n<h3>How to fix it</h3>\n<p>You need to access localized strings <strong>below</strong> <code>MaterialApp</code>.</p>\n<h4>Option 1 (recommended): Move <code>MaterialApp</code> up</h4>\n<p>Make <code>MaterialApp</code> the root widget (usually in <code>main.dart</code>) and move your UI into a separate widget:</p>\n<pre><code>void main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      supportedLocales: [\n        Locale('en', 'US'),\n        Locale('da', 'DK'),\n      ],\n      localizationsDelegates: [\n        AppLocalizations.delegate,\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n      ],\n      home: Forside(),\n    );\n  }\n}\n\nclass Forside extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Text(\n        AppLocalizations.of(context).translate('menu'),\n      ),\n    );\n  }\n}\n</code></pre>\n<p>Now <code>context</code> is inside <code>MaterialApp</code>, so <code>AppLocalizations.of(context)</code> won\u2019t be null.</p>\n<hr />\n<h4>Option 2: Use a <code>Builder</code></h4>\n<p>If you really want to keep <code>MaterialApp</code> where it is, wrap the widget using localization in a <code>Builder</code>:</p>\n<pre><code>Builder(\n  builder: (context) {\n    return Text(\n      AppLocalizations.of(context).translate('menu'),\n    );\n  },\n)\n</code></pre>\n<p>This creates a new <code>BuildContext</code> that <em>does</em> have access to localization.</p>\n<hr />\n<h3>Extra tips</h3>\n<ul>\n<li><p>Make sure your JSON files exist (<code>lang/en.json</code>, <code>lang/da.json</code>)</p>\n</li>\n<li><p>Add them to <code>pubspec.yaml</code> under <code>assets</code></p>\n</li>\n<li><p>Consider returning a fallback if a key is missing:</p>\n<pre><code>String translate(String key) =&gt; _localizedStrings[key] ?? key;\n\n</code></pre>\n</li>\n</ul>\n<hr />\n<h3>If you want a simpler approach</h3>\n<p>If you don\u2019t want to deal with manual JSON files, delegates, context issues, and syncing translations, using a localization platform like <strong><a href=\"https://azbox.io\" rel=\"nofollow noreferrer\">https://azbox.io</a></strong> can make this much easier. You manage all strings in one place and just consume them in Flutter without this boilerplate.</p>\n<p>Hope this helps \ud83d\udc4d</p>\n", "tags": ["flutter", "localization"]}
{"id": "e6ec8a37-3f96-42b6-ba14-2ee8eabff3d3", "text": "Q: Can storage be allocated and deallocated by different allocator types? A: <blockquote>\n<p>The <a href=\"https://en.cppreference.com/w/cpp/named_req/Allocator.html\" rel=\"nofollow noreferrer\">Allocator</a> concept seems to suggest that as long as two allocators compare equal, one can deallocate storage allocated by the other.</p>\n</blockquote>\n<p>It does not matter what is suggested. What matters is what is said. The Allocator concept says that as long as two allocators <em><strong>of the same type</strong></em> compare equal, one can deallocate storage allocated by the other. While cppreference.com currently lacks an explanation of what <code>a1</code> and <code>a2</code> are in the expression <code>a1 == a2</code> (probably an oversight), the <a href=\"https://timsong-cpp.github.io/cppwp/n4950/allocator.requirements#general-2.6\" rel=\"nofollow noreferrer\">language standard</a> does state that they denote lvalues of the same type.</p>\n<p>I can understand a desire to relax this type restriction and allow <code>a1</code> and <code>a2</code> to have different types. I would even go as far as saying it sounds reasonable, since someone would have to go through the trouble of defining an equality operator. However, the standard library supports only the standard concept (where <code>a1</code> and <code>a2</code> have the same type as each other in this requirement).</p>\n", "tags": ["c++", "allocator"]}
{"id": "ec009741-12fb-42bb-9da9-c85a91aece7a", "text": "Q: How to compile a program with static libcurl? A: <ol>\n<li><p>For proper export declaration of crucial curl functions you need a <code>defined(CURL_STATICLIB)</code>, while by default shared linkage is set for these functions (e.g. under MINGW the project won't link at all, then).</p>\n</li>\n<li><p>When your curl package provides both shared and static version of <code>libcurl</code>, the linker needs option <code>-Wl,-Bstatic</code>before <code>-lcurl</code> to know which one you want to attract, see <a href=\"https://stackoverflow.com/a/6578558/9437799\">https://stackoverflow.com/a/6578558/9437799</a></p>\n</li>\n<li><p>Also there are a lot of additional dependencies, see <a href=\"https://stackoverflow.com/a/6578558/9437799\">GitHub: libcurl static linking instructions</a></p>\n</li>\n</ol>\n", "tags": ["c", "linux", "gcc", "curl"]}
{"id": "e58c0a1c-217b-41a2-9e7f-0d63288fcf32", "text": "Q: How to optimize a BigQuery query that uses multiple JOINs A: <p>I am unable to answer the questions with the level of detail you requested.</p>\n<p>However, filtering early is a great plan, and you already take only the fields you require, which reduces the costs.</p>\n<p>The query appears to be referencing tableA 4 times</p>\n<ul>\n<li><p>once for the initial query and filtering on the <code>WHERE</code> condition</p>\n</li>\n<li><p>once to match the tableB content</p>\n</li>\n<li><p>once to match the tableC content</p>\n</li>\n<li><p>once to match the tableD content</p>\n</li>\n</ul>\n<p>I am not familiar with how BigQuery optimizes and processes tables, whether it runs the tableA selection and filtering, stores that in memory once and then reuses it for the subsequent queries, or repeats the same initial query for each of the subsequent queries. I leave that others more knowledgeable than me for that.</p>\n<p>However, as a heavy user of BigQuery, I would select the data into a CTE using as little data as possible (as few fields as necessary, and using <code>WHERE</code> to limit the output) and then reuse that reduced dataset, rather than reselecting from the original source (<code>tableA</code>) multiple times, e.g. for tableB, C and D:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>WITH\n    --Get as little as possible from tableA, We can reuse this output multiple times\n    tableA_tmp AS (\n        SELECT DISTINCT\n            user_id,\n            event_timestamp,\n            session_id,\n            campaign_id\n        FROM\n            tableA\n        WHERE\n            event_timestamp &gt;= &quot;2024_01-01&quot;\n    ),\n\n    /*\n    Get the data from tableB using the subset in tableA_tmp.\n    In case there are dupes in tableA_tmp, DISTINCT the tableA_tmp selection and tableB_tmp outputs\n    */\n    tableB_tmp AS (\n        SELECT DISTINCT\n            user_id,\n            session_id,\n            country\n        FROM\n            tableB\n        WHERE\n            user_id IN (SELECT DISTINCT user_id FROM tableA_tmp)\n    ),\n\n    /*\n    Get the data from tableC only where the data exists in tableA_tmp.\n    In case there are dupes in tableA_tmp for the session_id, DISTINCT the tableA_tmp selection and tableC_tmp outputs\n    */\n    tableC_tmp AS (\n        SELECT DISTINCT\n            session_id,\n            device_type\n        FROM\n            tableC\n        WHERE\n            session_id IN (SELECT DISTINCT session_id FROM tableA_tmp)\n    ),\n\n    /*\n    Get the data from tableD only where the data exists in tableA_tmp.\n    In case there are dupes in tableA_tmp for the session_id, DISTINCT the tableA_tmp selection and tableD_tmp outputs\n    */\n    tableD_tmp AS (\n        SELECT DISTINCT\n            campaign_id,\n            campaign_name\n        FROM\n            tableD\n        WHERE\n            campaign_id IN (SELECT DISTINCT campaign_id FROM tableA_tmp)\n    )\n\n--Assemble the cut-down datasets together\nSELECT\n    a.user_id,\n    a.event_timestamp,\n    b.country,\n    c.device_type,\n    d.campaign_name\nFROM\n    tableA_tmp AS a\n    LEFT JOIN tableB_tmp AS b\n        ON a.user_id = b.user_id\n\n    LEFT JOIN tableC_tmp AS c\n        ON a.session_id = c.session_id\n\n    LEFT JOIN tableD_tmp AS d\n        ON a.campaign_id = d.campaign_id;\n</code></pre>\n<p><strong>USING PARTITIONS</strong></p>\n<p>When you initially select the data from tableA, if there is no partition on the <code>event_timestamp</code> field, all rows are scanned, whether or not they are in the data range, and then filtered to output only the required dates that match the condition. This incurs time and cost.</p>\n<p>If there is a timestamp-level partition on the <code>event_timestamp</code> field, the query knowns to only go to the section of the table where the events are a match on the date range condition, i.e. it can skip everything before 2024-01-01 and jump straight to the data in 2024 onwards, thus saving processing and actual cost, and time as the older data is ignored entirely.</p>\n<blockquote>\n<p>Partition management is key to fully maximizing BigQuery performance and cost when querying over a specific range\u2014it results in scanning less data per query, and pruning is determined before query start time. While partitioning reduces cost and improves performance, it also prevents cost explosion due to user accidentally querying really large tables in entirety.</p>\n<p>Source: <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/bigquery-explained-storage-overview\" rel=\"nofollow noreferrer\">Bigquery partition guide</a></p>\n</blockquote>\n<p><strong>JOINS: ORDER AND OPTMIZATION</strong></p>\n<blockquote>\n<p>Even though the SQL query optimizer can determine which table should be on which side of the join, it is recommended to order joined tables appropriately. The best practice is to place the largest table first, followed by the smallest, and then by decreasing size.<br />\nSource: <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/bigquery-explained-working-joins-nested-repeated-data\" rel=\"nofollow noreferrer\">BigQuery joins optimization advice</a></p>\n</blockquote>\n<p>In practice, this means <code>tableA</code> or the cut-down instance <code>tableA_tmp</code>, being the largest dataset, on the left side of the <code>JOIN</code>, which is what you did, with the second-largest table as the right side of the first <code>JOIN</code>.</p>\n<p>Then the next largest table as the right side of the second JOIN.</p>\n<p>Then the next largest table as the right side of the third JOIN.</p>\n<pre class=\"lang-sql prettyprint-override\"><code>Example:\n...\nbiggest_table LEFT JOIN second_biggest_table ON ...\n              LEFT JOIN third_largest_table  ON ...\n              LEFT JOIN fourth_largest_table ON ...\n...\n</code></pre>\n", "tags": ["google-bigquery"]}
