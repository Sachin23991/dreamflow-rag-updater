{"id": "0c0622c9-1a6d-4d8f-a768-c686fb6255ec", "text": "Q: C++ how to check if the std::cin buffer is empty A: <p>New too to C++. I also tried to get rid of the prompt &gt; as per first question of Spicypumpkin.</p>\n<p>Didn't find nothing on the web, so I made the following modification to calculator code of section 7.8.3 of Bjarne's PP book. It seems working but I still have plenty of doubt:</p>\n<ul>\n<li><p>is it the best way to do that (with getline and sstream)?</p>\n</li>\n<li><p>why am I foced to use eof() to esc from while loop when eating ;?<br />\nIf I don't use it, when I input 1;; I will never esc, and I don't know why.</p>\n</li>\n<li><p>How can I alternatively detect the end of the string other than \\0?<br />\nFurthermore, if I well understood, strings in C++ don't have any terminator.</p>\n</li>\n</ul>\n<p>I would appreciate any comments or explanations to better understand.</p>\n<p>Anyway enclosed my solution, that gives:</p>\n<p>\\&gt; 1+2;3*7;8-2;</p>\n<p>= 3</p>\n<p>= 21</p>\n<p>= 6</p>\n<p>\\&gt;</p>\n<pre><code>// This is example code from Chapter 7.8.3 &quot;Predefined names&quot; of\n// &quot;Programming -- Principles and Practice Using C++&quot; by Bjarne Stroustrup,\n// modified to avoid &gt;= prompt when we input multiple expressions on a \n// line (see end of paragraph 7.2) \n\n// rev0: getline() introduced and stringstream's object ss passed to functions \n//       as argument.\n// rev1: solved issue 1;; and issue w-;1+2;\n\n#include &quot;std_lib_facilities.h&quot;\n#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n//#include &lt;cstring&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n//------------------------------------------------------------------------------\n\nconst char number = '8';    // t.kind==number means that t is a number Token\nconst char quit   = 'q';    // t.kind==quit means that t is a quit Token\nconst char print  = ';';    // t.kind==print means that t is a print Token\nconst char name   = 'a';    // name token\nconst char let    = 'L';    // declaration token\nconst string declkey = &quot;let&quot;;// declaration keyword \nconst string prompt  = &quot;&gt; &quot;;\nconst string result  = &quot;= &quot;; // used to indicate that what follows is a result\n//const char prompt = &quot;&gt; &quot;; // Prompt used at the beginning of every line\n//------------------------------------------------------------------------------\n\nclass Token {\npublic:\n    char kind;        // what kind of token\n    double value;     // for numbers: a value \n    string name;      // for names: name itself\n    Token(char ch)             : kind(ch), value(0)   {}\n    Token(char ch, double val) : kind(ch), value(val) {}\n    Token(char ch, string n)   : kind(ch), name(n)    {}\n};\n\n//------------------------------------------------------------------------------\n\nclass Token_stream {\npublic: \n    Token_stream();   // make a Token_stream that reads from cin\n    Token get(istringstream&amp;);      // get a Token (get() is defined elsewhere)\n    void putback(Token t);    // put a Token back\n    void ignore(char c,istringstream&amp;);      // discard tokens up to an including a c\nprivate:\n    bool full;        // is there a Token in the buffer?\n    Token buffer;     // here is where we keep a Token put back using putback()\n};\n\n//------------------------------------------------------------------------------\n\n// The constructor just sets full to indicate that the buffer is empty:\nToken_stream::Token_stream()\n:full(false), buffer(0)    // no Token in buffer\n{\n}\n\n//------------------------------------------------------------------------------\n\n// The putback() member function puts its argument back into the Token_stream's buffer:\nvoid Token_stream::putback(Token t)\n{\n    if (full) error(&quot;putback() into a full buffer&quot;);\n    buffer = t;       // copy t to buffer\n    full = true;      // buffer is now full\n}\n\n//------------------------------------------------------------------------------\nToken_stream ts;\nToken Token_stream::get(istringstream&amp; f) // read characters from cin and compose a Token\n{\n    if (full) {         // check if we already have a Token ready\n        full=false;\n        return buffer;\n    }  \n\n    char ch;\n    //cin &gt;&gt; ch;          // note that &gt;&gt; skips whitespace (space, newline, tab, etc.)\n    f &gt;&gt; ch;\n    switch (ch) {\n    case '\\0':\n        return Token(ch);\n    case print:\n      \n    case quit:\n    \n    case '(':\n    case ')':\n    case '+':\n    case '-':\n    case '*':\n    case '/': \n    case '%':\n    case '=':\n        return Token(ch); // let each character represent itself\n    case '.':             // a floating-point literal can start with a dot\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':    // numeric literal\n    {\n        f.putback(ch);// put digit back into the ss stream\n        double val;\n        f &gt;&gt; val;     // read a floating-point number\n        return Token(number,val);\n    }\n    default:\n        if (isalpha(ch)) {\n            string s;\n            s += ch;\n            while (f.get(ch) &amp;&amp; (isalpha(ch) || isdigit(ch))) s+=ch;\n            f.putback(ch);\n            if (s == declkey) return Token(let); // keyword &quot;let&quot;\n            return Token(name,s);\n        }\n        error(&quot;Bad token&quot;);\n    }\n    return 0;\n}\n\n//------------------------------------------------------------------------------\n\nvoid Token_stream::ignore(char c, istringstream&amp;ss)\n    // c represents the kind of a Token\n{\n    // first look in buffer:\n    if (full &amp;&amp; c==buffer.kind) {\n        full = false;\n        return;\n    }\n    full = false;\n// now search input:\n    char ch = 0;\n    while (ss&gt;&gt;ch)\n        if (ch==c) return;\n    \n}\n\n//------------------------------------------------------------------------------\n\n//Token_stream ts;        // provides get() and putback() \n\n//------------------------------------------------------------------------------\n\nclass Variable {\npublic:\n    string name;\n    double value;\n    Variable (string n, double v) :name(n), value(v) { }\n};\n\n//------------------------------------------------------------------------------\n\nvector&lt;Variable&gt; var_table;\n\n//------------------------------------------------------------------------------\n\ndouble get_value(string s,istringstream&amp;ss)\n    // return the value of the Variable names s\n{\n    for (int i = 0; i&lt;var_table.size(); ++i)\n        if (var_table[i].name == s) return var_table[i].value;\n    ts.ignore(print,ss);\n    error(&quot;get: undefined variable &quot;, s);\n    return 0;\n}\n\n//------------------------------------------------------------------------------\n\nvoid set_value(string s, double d)\n    // set the Variable named s to d\n{\n    for (int i = 0; i&lt;var_table.size(); ++i)\n        if (var_table[i].name == s) {\n            var_table[i].value = d;\n            return;\n        }\n    error(&quot;set: undefined variable &quot;, s);\n}\n\n//------------------------------------------------------------------------------\n\nbool is_declared(string var)\n    // is var already in var_table?\n{\n    for (int i = 0; i&lt;var_table.size(); ++i)\n        if (var_table[i].name == var) return true;\n    return false;\n}\n\n//------------------------------------------------------------------------------\n\ndouble define_name(string var, double val)\n    // add (var,val) to var_table\n{\n    if (is_declared(var)) error(var,&quot; declared twice&quot;);\n    var_table.push_back(Variable(var,val));\n    return val;\n}\n\n//------------------------------------------------------------------------------\n\ndouble expression(istringstream&amp;);    // declaration so that primary() can call expression()\n\n//------------------------------------------------------------------------------\n\n// deal with numbers and parentheses\ndouble primary(istringstream&amp; ss)\n{\n    Token t = ts.get(ss);\n    switch (t.kind) {\n    case '(':           // handle '(' expression ')'\n        {\n            double d = expression(ss);\n            t = ts.get(ss);\n            if (t.kind != ')') error(&quot;')' expected&quot;);\n            return d;\n        }\n    case number:    \n        return t.value;    // return the number's value\n    case name:\n        return get_value(t.name,ss); // return the variable's value\n    case '-':\n        return - primary(ss);\n    case '+':\n        return primary(ss);\n    default:\n        error(&quot;primary expected&quot;);\n    }\n    return 0;\n}\n\n//------------------------------------------------------------------------------\n\n// deal with *, /, and %\ndouble term(istringstream&amp; ss)\n{\n    double left = primary(ss);\n    Token t = ts.get(ss); // get the next token from token stream\n\n    while(true) {\n        switch (t.kind) {\n        case '*':\n            left *= primary(ss);\n            t = ts.get(ss);\n            break;\n        case '/':\n            {    \n                double d = primary(ss);\n                if (d == 0) error(&quot;divide by zero&quot;);\n                left /= d; \n                t = ts.get(ss);\n                break;\n            }\n        case '%':\n            {    \n                int i1 = narrow_cast&lt;int&gt;(left);\n                int i2 = narrow_cast&lt;int&gt;(term(ss));\n                if (i2 == 0) error(&quot;%: divide by zero&quot;);\n                left = i1%i2; \n                t = ts.get(ss);\n                break;\n            }\n        default: \n            ts.putback(t);        // put t back into the token stream\n            return left;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n\n// deal with + and -\ndouble expression(istringstream&amp; ss)\n{\n    double left = term(ss);      // read and evaluate a Term\n    Token t = ts.get(ss);        // get the next token from token stream\n\n    while(true) {    \n        switch(t.kind) {\n        case '+':\n            left += term(ss);    // evaluate Term and add\n            t = ts.get(ss);\n            break;\n        case '-':\n            left -= term(ss);    // evaluate Term and subtract\n            t = ts.get(ss);\n            break;\n        default: \n            ts.putback(t);     // put t back into the token stream\n            return left;       // finally: no more + or -: return the answer\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n\ndouble declaration(istringstream&amp; ss)\n    // handle: name = expression\n    // declare a variable called &quot;name&quot; with the initial value &quot;expression&quot;\n{\n    Token t = ts.get(ss);\n    if (t.kind != name) error (&quot;name expected in declaration&quot;);\n    string var_name = t.name;\n\n    Token t2 = ts.get(ss);\n    if (t2.kind != '=') error(&quot;= missing in declaration of &quot;, var_name);\n\n    double d = expression(ss);\n    define_name(var_name,d);\n    return d;\n}\n\n//------------------------------------------------------------------------------\n\ndouble statement(istringstream&amp; ss)\n{\n    Token t = ts.get(ss);\n    switch (t.kind) {\n    case let:\n        return declaration(ss);\n    default:\n        ts.putback(t);\n        return expression(ss);\n    }\n}\n\n//------------------------------------------------------------------------------\n\n/*void clean_up_mess()\n{ \n    ts.ignore(print);\n}*/\n\n//------------------------------------------------------------------------------\n\nvoid calculate()\n{\n    cout &lt;&lt; prompt;\n    string input;   \n    while (getline(cin,input)){\n       // try {\n        istringstream ss{input};                     // create a stringstream object        \n        while(ss)                                    // initialized with 'input'\n        try\n        {                                \n            Token t = ts.get(ss);\n            while (t.kind == print){\n               if (ss.eof()) {t.kind='\\0';break;}             \n               t=ts.get(ss);                        // first discard all &quot;prints&quot;                         \n            }\n            if (t.kind == quit) return;             // quit\n            if(t.kind=='\\0'){                       // printing prompt when string                      \n            //    cout&lt;&lt;prompt;                     // terminator character '/0' found\n                break;}\n            ts.putback(t);\n            cout &lt;&lt; result &lt;&lt; statement(ss) &lt;&lt; endl;\n        }                                          \n                                                  \n        catch (exception&amp; e) {\n        cerr &lt;&lt; e.what() &lt;&lt; endl;        // write error message\n        //clean_up_mess();               // it can't be used because I can't pass ss parameter?\n                                         // so I put ignore (...) where needed.\n        }                                // end of while(ss)\n        cout&lt;&lt;prompt;\n    }                                    // end of while(getline(...))\n}\n\n//------------------------------------------------------------------------------\n\nint main()\ntry {\n    // predefine names:\n    define_name(&quot;pi&quot;,3.1415926535);\n    define_name(&quot;e&quot;,2.7182818284);\n    calculate();\n    keep_window_open();    // cope with Windows console mode\n    return 0;\n}\ncatch (runtime_error&amp; e) {\n    cerr &lt;&lt; e.what() &lt;&lt; endl;\n    keep_window_open(&quot;~~&quot;);\n    return 1;\n}\ncatch (...) {\n    cerr &lt;&lt; &quot;exception \\n&quot;;\n    keep_window_open(&quot;~~&quot;);\n    return 2;\n}\n\n//------------------------------------------------------------------------------\n</code></pre>\n<p>I guess it also should be put in a section with different subject, such as &quot;calculator Bjarne&quot; or so.</p>\n<p>Thanks for any kind reply.</p>\n<p>Regards</p>\n", "tags": ["c++", "cin"]}
{"id": "7941983c-e13a-4a46-b7cb-6b0cede564e5", "text": "Q: How to optimize SELECT * queries on wide tables? A: <p>Using <code>SELECT *</code> on wide tables is generally inefficient and should be avoided in production queries. Here\u2019s why\u2014and how to optimize such queries.</p>\n<hr />\n<h3>Why <code>SELECT *</code> causes performance issues</h3>\n<ul>\n<li><p>Fetches <strong>all columns</strong>, even when only a few are needed</p>\n</li>\n<li><p>Increases <strong>disk I/O, memory usage, and network transfer</strong></p>\n</li>\n<li><p>Prevents the database from using <strong>covering indexes</strong></p>\n</li>\n<li><p>Slows down serialization/deserialization at the application layer</p>\n</li>\n</ul>\n<hr />\n<h2>Best Practices to Optimize Queries</h2>\n<h3><strong>Select only required columns</strong></h3>\n<pre><code>SELECT id, name, created_at\nFROM users\nWHERE status = 'active';\n</code></pre>\n<p>Reduces I/O and improves cache efficiency</p>\n<p>Enables better index usage</p>\n<hr />\n<h3><strong>Use covering indexes</strong></h3>\n<p>Create indexes that include all selected columns:</p>\n<pre><code>CREATE INDEX idx_users_status\nON users(status, id, name, created_at);\n</code></pre>\n<p>Allows the database to satisfy the query <strong>using only the index</strong></p>\n<hr />\n<h3><strong>Split large or rarely-used columns</strong></h3>\n<p>Move large fields (<code>TEXT</code>, <code>JSON</code>, <code>BLOB</code>) to a separate table:</p>\n<pre><code>users (id, name, email)\nuser_details (user_id, bio, preferences)\n</code></pre>\n<p>Keeps frequently queried tables narrow and fast</p>\n<hr />\n<h3><strong>Use LIMIT and proper pagination</strong></h3>\n<pre><code>SELECT id, name\nFROM users\nORDER BY created_at DESC\nLIMIT 50;\n</code></pre>\n<p>Prevents scanning and returning unnecessary rows</p>\n<hr />\n<h3><strong>Analyze execution plans</strong></h3>\n<pre><code>EXPLAIN ANALYZE\nSELECT id, name\nFROM users\nWHERE status = 'active';\n</code></pre>\n<p>Helps detect full table scans, missing indexes, or inefficient joins</p>\n<hr />\n<h3><strong>Avoid <code>SELECT *</code> in JOINs</strong></h3>\n<pre><code>-- Bad\nSELECT *\nFROM orders o\nJOIN users u ON o.user_id = u.id;\n\n-- Good\nSELECT o.id, o.amount, u.name\nFROM orders o\nJOIN users u ON o.user_id = u.id;\n</code></pre>\n<p>Prevents fetching unused columns from multiple tables</p>\n<hr />\n<h3><strong>Cache frequent read queries</strong></h3>\n<p>For dashboards or repeated reads:</p>\n<ul>\n<li><p>Use <strong>application-level caching</strong> (e.g., Redis)</p>\n</li>\n<li><p>Reduces database load significantly</p>\n</li>\n</ul>\n<hr />\n<h2>When <code>SELECT *</code> is acceptable</h2>\n<ul>\n<li><p>Ad-hoc debugging or exploration</p>\n</li>\n<li><p>Small tables with very few columns</p>\n</li>\n<li><p>One-time admin or migration scripts</p>\n<p><code>SELECT *</code> is convenient but inefficient for wide tables.<br />\nAlways select required columns, use covering indexes, split large fields, and analyze query plans for optimal performance.</p>\n</li>\n</ul>\n", "tags": ["sql", "polardb"]}
{"id": "37c91d6b-9ccd-4dfe-a012-cba7bd85e61a", "text": "Q: How to change the background color of an ant.design InputNumber? A: <p>Use</p>\n\n<pre><code>style={{backgroundColor: this.props.colorTheme.text7Color}}\n</code></pre>\n", "tags": ["reactjs", "antd"]}
{"id": "2c803bcf-22c7-4b19-a7e9-4c30f2d8b9fb", "text": "Q: Linux shell script not found, but it does exist A: <p># Source - <a href=\"https://stackoverflow.com/q/27275118\">Linux shell script not found, but it does exist</a></p>\n<p># Posted by demonguy, modified by community. See post 'Timeline' for change history</p>\n<p># Retrieved 2025-12-27, License - CC BY-SA 4.0</p>\n<pre><code>#!/bin/sh\n\necho &quot;Hello World!&quot;\n</code></pre>\n", "tags": ["linux", "shell", "openwrt"]}
{"id": "eb808e33-a2b4-43c7-8cf2-c7096a2e768b", "text": "Q: Version control for video editing work A: <p>From your description, it sounds like you would do pretty well with some basic backup software such as <a href=\"https://www.retrospect.com\" rel=\"nofollow noreferrer\">Retrospect</a>. Using daily backups of workstations, only changed data would be backed up and it would be easy to roll back to an earlier version of a file if needed.</p>\n<p>What you don't get from such a setup is the ability to check out / check in files and get warnings about conflicts.</p>\n", "tags": ["version-control", "video", "image"]}
{"id": "434a225d-0d22-4960-8b57-a5f332bc6556", "text": "Q: just hangs ddev-ddev-dbserver-mariadb-10.11-v1.24.10 A: <p>Sometimes you just get stuck - and you cant dig yourself out of a hole!</p>\n<p>It was a the docker socket needed a restart</p>\n", "tags": ["drupal", "ddev"]}
{"id": "5560b1bf-8180-4a11-948e-5373b55e2199", "text": "Q: How to calculate total of values based on if other variables are similar? A: <p>If you want to have a summary of all the data, you can use the GROUPBY function in the new Excel:</p>\n<pre><code>=GROUPBY($A:.$A,$B:.$B,SUM,3,0)\n</code></pre>\n<p>I assume that columns <code>A</code> and <code>B</code> contain only these data.</p>\n<p><img src=\"https://i.sstatic.net/M2glwgpB.png\" alt=\"Group-by\" />\n(<a href=\"https://i.sstatic.net/M2glwgpB.png\" rel=\"nofollow noreferrer\">https://i.sstatic.net/M2glwgpB.png</a>)</p>\n<p>In earlier versions of Excel, you can use a <code>Consolidate</code> procedure or an equivalent macro:</p>\n<pre><code>Sub Consolidate()\n    Dim src As Range\n    Set src = Range(&quot;A1&quot;).CurrentRegion\n    Range(&quot;D1&quot;).Consolidate Sources:=src.Address(ReferenceStyle:=xlR1C1, External:=True), _\n        Function:=xlSum, TopRow:=True, LeftColumn:=True\n    Range(&quot;D1&quot;).Value = Range(&quot;A1&quot;).Value\nEnd Sub\n\n</code></pre>\n", "tags": ["excel", "vba", "function", "macros"]}
{"id": "e73381b1-51b3-4b25-aaf6-f18f4ecc5f36", "text": "Q: How to align multiple objects in Unity (with or without code)? A: <p>I know its late but aligning objects in unity is not about positions only, its also about meshes boundaries. For example if two cubes are in the same position but there meshes have not the same size, then they will not be considered as aligned.\nSo you have to calculate the boundaries of the meshes of all the objects to be aligned.</p>\n<pre><code>private Bounds GetPrefabBounds(GameObject prefabInstance)\n    {\n\n        Bounds prefabBounds = new Bounds(Vector3.zero, Vector3.zero);\n        Renderer[] renderers = prefabInstance.GetComponentsInChildren&lt;Renderer&gt;();\n\n        if (renderers.Length &gt; 0)\n        {\n            prefabBounds = renderers[0].bounds;\n\n            for (int i = 1; i &lt; renderers.Length; i++)\n            {\n                prefabBounds.Encapsulate(renderers[i].bounds);\n            }\n        }\n        else\n        {\n            Debug.LogWarning(&quot;Prefab does not contain any Renderer components.&quot;);\n        }\n\n        return prefabBounds;\n    }\n</code></pre>\n<p>If you don't have time for all that you can use this tool : <a href=\"https://u3d.as/364X\" rel=\"nofollow noreferrer\">Align, Array and Path Tools</a> from the unity asset store. But you have to use Unity 2022.2.19f1 or later.</p>\n", "tags": ["c#", "unity-game-engine"]}
