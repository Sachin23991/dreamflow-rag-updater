{"id": "d1d84df4-e325-4bf0-9e44-bc49f2375daf", "text": "Q: esp home builder fails on unpacking step of install A: <p>Laptop sat</p>\n<p>Laptop alan yerler</p>\n<p>Laptopumu satmak istiyorum</p>\n<p>Bilgisayar alan yerler</p>\n<p>Bilgisayar\u00a0 satmak istiyorum</p>\n<p><a href=\"https://mbilgisayar.com.tr/\" rel=\"nofollow noreferrer\">https://mbilgisayar.com.tr/</a></p>\n", "tags": ["esp32", "home-assistant"]}
{"id": "c75d9b8c-298f-45b5-9a5a-62bba5764d1a", "text": "Q: Unable to read the File from Network share using apache camel SMB A: <p>I'm using Camel 4.16.0 and Spring boot 3.5.8.</p>\n<p>This is my SMB share (tow folder under the main folder)</p>\n<p><a href=\"https://i.sstatic.net/QSEeS0Tn.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/QSEeS0Tn.png\" alt=\"enter image description here\" /></a></p>\n<p>listed with this command</p>\n<pre><code>smbclient //hostname/Data -U samba\n</code></pre>\n<p>This is my Camel flow</p>\n<pre class=\"lang-java prettyprint-override\"><code>from(smb(&quot;hostname:445/Data/inbound&quot;)\n  .username(&quot;*****&quot;)\n  .password(&quot;*****&quot;)\n  .delete(true)\n  .includeExt(&quot;txt&quot;))\n  .log(&quot;File received from SMB: ${header.CamelFileName}&quot;);\n</code></pre>\n<p>Only file under <strong>inbound</strong> subfolder with <strong>txt</strong> extension are fetched by the Camel poller</p>\n<p><a href=\"https://i.sstatic.net/7B5Q1yeK.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/7B5Q1yeK.png\" alt=\"enter image description here\" /></a></p>\n", "tags": ["spring-boot", "file", "apache-camel", "smb", "camel-routes"]}
{"id": "94c0f7ee-fecf-4632-ac61-18d364667ace", "text": "Q: Why doesn&#39;t C++ allow virtual function overrides to be constrained by a concept/requires clause? A: <blockquote>\n<p>Why?</p>\n</blockquote>\n<p>As standard say so :)</p>\n<p>I would say that the rational is to avoid to decide if different <code>requires</code> hide or override base one.</p>\n<p>Imagine valid code:</p>\n<pre><code>\ntemplate &lt;int I&gt;\nconcept isEven = ((I % 2) == 0);\n\ntemplate &lt;int I&gt;\nstruct Base {\n\n    void f() requires (isEven&lt;I&gt;) { std::cout &lt;&lt; &quot;even\\n&quot;; }\n    void f() requires (isEven&lt;I&gt; &amp;&amp; I == 0) { std::cout &lt;&lt; &quot;0\\n&quot;; }\n    void f() requires (I == 1) { std::cout &lt;&lt; &quot;1\\n&quot;; }\n};\n</code></pre>\n<p><a href=\"https://godbolt.org/z/3xWafxqvW\" rel=\"nofollow noreferrer\">Demo</a></p>\n<p><code>Base&lt;0&gt;</code> has actually 2 overloads <code>f</code>, one more specialized that the other (subsumption).</p>\n<p>If you add <code>virtual</code>, would <code>void f() override</code> allowed for derived class?\nShould the override has same <code>requires</code> clause than base class?</p>\n<p>Forbid it now allows to decide latter (if required).</p>\n", "tags": ["c++", "constraints", "overriding", "require", "virtual"]}
{"id": "f8011c56-e15c-4ac1-acec-012004196ba3", "text": "Q: Why would one reset local variables at the end of a C function? A: <p>Deleting (wiping) local data is done for security reasons, as you have also been told.</p>\n<p>But you need also to be told that, as those variables are not observable output of the routine, you will need special compilation options (concretely, don\u2019t optimize the code generator) for the compiler not to evict completely that code.  So always compile that compilation unit with <code>-O0</code> preferably.</p>\n", "tags": ["c", "hash", "cryptography", "hmacsha1"]}
{"id": "2e46c579-0856-4243-9580-f61fd2988e57", "text": "Q: What are your favorite C++ STL alternatives? A: <p>By &quot;STL&quot; you probably mean <strong>the standard library</strong>.<br />\n(See some more info here: <a href=\"https://stackoverflow.com/questions/5205491/whats-the-difference-between-stl-and-c-standard-library\">What's the difference between &quot;STL&quot; and &quot;C++ Standard Library&quot;?</a>).</p>\n<p>My advice is to <strong>use it whenever you can</strong> (<code>std::string</code> for dynamic strings, <code>std::vector</code> for dynamic arrays, <code>std::thread</code> for threads etc.).</p>\n<p>It might have a learning curve but IMHO it absolutely worth it to get to know as many parts as possible from the standard library.</p>\n<p>If the standard library offers some class or API, it is usually available as-is on most systems. It is usually well debugged, and [at least reasonably] optimized.</p>\n<p>You need to have a really good reason to prefer an OS-specific API over the standard library.</p>\n<p>If you need some API/class that does not exist in the standard library, it's worth it to have a look at <a href=\"https://www.boost.org/\" rel=\"nofollow noreferrer\"><strong>Boost C++ Libraries</strong></a>.</p>\n", "tags": ["c++", "stl"]}
{"id": "79ae11ba-fa1d-4455-a729-207260ef9600", "text": "Q: Spring Boot Prometheus Push Gateway: Metrics missing label A: <p>I suspect that the custom labels are getting exported to the empty instance label because the <a href=\"https://github.com/prometheus/pushgateway\" rel=\"nofollow noreferrer\">documentation </a>says:</p>\n<blockquote>\n<p>The Prometheus server will attach an <code>instance</code> label if no <code>instance</code> label has been set in the first place. Therefore, if a metric is pushed to the Pushgateway without an instance label (and without an instance label in the grouping key, see below), the Pushgateway will export it with an empty instance label (<code>{instance=&quot;&quot;}</code>), which is equivalent to having no <code>instance</code> label at all, but prevents the server from attaching one.</p>\n</blockquote>\n<p>I guess you need to configure <code>instance</code> property present in the <code>grouping-key</code> property to see those labels.</p>\n<p>Example:</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>management:\n  prometheus:\n    metrics:\n      export:\n        pushgateway:\n          enabled: ${PROM_PUSH_ENABLED:true}\n          address: ${PROM_PUSH_GATEWAY_ADDRESS:prometheus-pushgateway-cogito-pushgateway.telemetry.svc.cluster.local:9091}\n          scheme: http\n          grouping-key: \n            instance: http://localhost:9000    \n            namespace: ${PROM_PUSH_NAMESPACE_FOR_EXPORT:TBD}\n          shutdown-operation: POST\n          push-rate: ${PROM_PUSH_RATE:5s}\n          job: signal-offload-reconciler\n          format: ${PROM_PUSH_FORMAT:TEXT}\n</code></pre>\n", "tags": ["java", "spring", "spring-boot", "spring-boot-actuator", "prometheus-pushgateway"]}
{"id": "3a45d870-cfe2-40ad-9e00-58c87f46d00f", "text": "Q: process.env.&lt;variable&gt; not accessible A: <p>(i am guessing this is nodeJs application that is either  running in your local enviroment or on the server)</p>\n<p>Dont give the path in the dotenv loading line(under the import)<br />\nkeep your .env file in the root of the project and it should load properly in to process.env</p>\n", "tags": ["javascript", "node.js", "dotenv"]}
{"id": "3a63819a-4694-44dc-b4fc-a72dd9b80ac7", "text": "Q: How do I stub out an impl Trait-returning function? A: <p>Use an <code>async</code> block:</p>\n<pre class=\"lang-rust prettyprint-override\"><code>fn foo() -&gt; impl Future {\n    async move {\n        todo!()\n    }\n}\n</code></pre>\n<p>(I personally prefer <code>async move</code>, but the <code>move</code> here is a no-op.)</p>\n", "tags": ["rust", "traits"]}
