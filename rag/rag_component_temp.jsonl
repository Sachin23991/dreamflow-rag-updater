{"id": "efec5174-cc5b-40f4-b9d6-53e4498632cf", "text": "Q: PostgreSQL Connection Error via DBeaver: FATAL: invalid value for parameter &quot;TimeZone&quot;: &quot;Asia/Calcutta&quot; A: <p>The JDBC driver uses the time zone defined in your Java virtual machine to set the PostgreSQL time zone parameter, and it looks like your JVM and PostgreSQL are using different versions of the time zone database. <code>Asia/Calcutta</code> is obsolete and should be <code>Asia/Kolkata</code> these days, but the edition of the time zone database on my Fedora 42 (2025b) still supports the old spelling, so I wonder what your PostgreSQL server is using.</p>\n<p>You can check if your PostgreSQL is using its own copy of the timezone database or the operating system's copy by running the following query as superuser:</p>\n<pre><code>SELECT setting ~ 'with-system-tzdata' AS uses_system_timezone\nFROM pg_config()\nWHERE name = 'CONFIGURE';\n</code></pre>\n<p>Then either look for the version of the time zone database on your undisclosed operating system or figure out the version used by PostgreSQL (which will depend on the undisclosed version of PostgreSQL).</p>\n<p>Anyway, a solution for your problem is probably to set your system time zone to a supported value by setting the environment variable <code>TZ</code> to <code>Asia/Kolkata</code> on your client operating system. The Java virtual machine should pick up that setting, and that should get rid of the error.</p>\n", "tags": ["postgresql", "jdbc"]}
{"id": "8e3b932f-f202-422e-9c7b-469d337d1fe5", "text": "Q: touch-action causes selection A: <p>It is a focus, not a select. I cannot however reproduce it even when I set the focus on load.</p>\n<p>Chrome v143+ Windows 11, Dell Latitude 7450 touch.</p>\n<p>I suggested to remove the focus from the button to stop browser from moving the focus to another button, but as I said I cannot reproduce on a touch screen with Chrome</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\" data-babel-preset-react=\"false\" data-babel-preset-ts=\"false\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>document.addEventListener('DOMContentLoaded', () =&gt; {\n  const btn1 = document.getElementById('btn1');\n  btn1.focus();\n  btn1.addEventListener('click', function(e) {\n    this.focus();\n    this.remove();\n  });\n});</code></pre>\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>body {\n  user-select: none;\n  touch-action: none;\n}\n\nbutton img {\n  height: 100px;\n}\n\n.button:active {\n  background: blue;\n}</code></pre>\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;button id=\"btn1\"&gt;&lt;img src=\"https://placehold.co/50x50?text=Btn1\" alt=\"Btn1\"&gt;&lt;/button&gt;\n&lt;button id=\"btn2\"&gt;&lt;img src=\"https://placehold.co/50x50?text=Btn2\" alt=\"Btn2\"&gt;&lt;/button&gt;\n&lt;button&gt;&lt;img src=\"https://placehold.co/50x50?text=Btn3\" alt=\"Btn3\"&gt;&lt;/button&gt;\n&lt;button&gt;&lt;img src=\"https://placehold.co/50x50?text=Btn4\" alt=\"Btn4\"&gt;&lt;/button&gt;\n&lt;button&gt;&lt;img src=\"https://placehold.co/50x50?text=Btn5\" alt=\"Btn5\"&gt;&lt;/button&gt;</code></pre>\n</div>\n</div>\n</p>\n", "tags": ["javascript", "css"]}
{"id": "cc495c9f-e6c2-4846-abca-01795175fe4e", "text": "Q: Difference between @bind and @bind-value A: <p>@bind-value automatically provides value for the 'ValueExpression' parameter for InputText and other input components and @bind does not.</p>\n<p>To use some extra functionality use @bind-value</p>\n", "tags": ["c#", "asp.net-core", "blazor"]}
{"id": "ff5fb2e2-87f1-4951-85b7-c6e7a624568b", "text": "Q: Macro to return a value and with goto inside A: <p>As an aside, do you know why people commonly wrap statement macros in <code>do {...} while (0)</code> rather than just using a block for them?  It's so they can terminate them with semicolon <code>;</code> and have that semicolon be a part of the statement, rather than a new, null statement.  But in your case, you included the semicolon in the macro itself, utterly defeating the purpose of the <code>do {...} while(0)</code> wrapper.  In the places where you use it, by adding a second semicolon, you're actually writing two statements rather than one.  Clearly not what was intended.</p>\n", "tags": ["c"]}
{"id": "2105ff46-e155-47c9-b195-e500fc61f146", "text": "Q: How to upload large files in Next.js using a dynamic form without hitting API size limits? A: <p>Upload directly to cloud storage and submit only metadata to your backend.</p>\n<h3>The general pattern</h3>\n<ol>\n<li><p>User selects files \u2192 upload each directly to cloud storage (client-side)</p>\n</li>\n<li><p>Get back URLs for each uploaded file</p>\n</li>\n<li><p>Submit form with folder names + file URLs (not the files themselves)</p>\n</li>\n</ol>\n<pre><code>&quot;use client&quot;;\n\nimport { useState } from &quot;react&quot;;\n\ntype FolderEntry = {\n  folderName: string;\n  files: File[];\n  uploadedUrls: string[]; // tracks completed uploads\n};\n\nexport default function AddForm() {\n  const [folders, setFolders] = useState&lt;FolderEntry[]&gt;([\n    { folderName: &quot;&quot;, files: [], uploadedUrls: [] },\n  ]);\n  const [isUploading, setIsUploading] = useState(false);\n\n  const addFolder = () =&gt; {\n    setFolders([...folders, { folderName: &quot;&quot;, files: [], uploadedUrls: [] }]);\n  };\n\n  const updateFolder = (index: number, updates: Partial&lt;FolderEntry&gt;) =&gt; {\n    setFolders(folders.map((f, i) =&gt; (i === index ? { ...f, ...updates } : f)));\n  };\n\n  const uploadFile = async (file: File): Promise&lt;string&gt; =&gt; {\n    // Option 1: Get a presigned URL from your API, then upload directly\n    const { uploadUrl, fileUrl } = await fetch(&quot;/api/get-upload-url&quot;, {\n      method: &quot;POST&quot;,\n      body: JSON.stringify({ filename: file.name, contentType: file.type }),\n    }).then((r) =&gt; r.json());\n\n    await fetch(uploadUrl, {\n      method: &quot;PUT&quot;,\n      body: file,\n      headers: { &quot;Content-Type&quot;: file.type },\n    });\n\n    return fileUrl;\n  };\n\n  const handleSubmit = async (e: React.FormEvent) =&gt; {\n    e.preventDefault();\n    setIsUploading(true);\n\n    try {\n      // Upload all files and collect URLs\n      const foldersWithUrls = await Promise.all(\n        folders.map(async (folder) =&gt; {\n          const urls = await Promise.all(folder.files.map(uploadFile));\n          return {\n            folderName: folder.folderName,\n            fileUrls: urls,\n          };\n        })\n      );\n\n      // Now submit just the metadata\n      await fetch(&quot;/api/save-form&quot;, {\n        method: &quot;POST&quot;,\n        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },\n        body: JSON.stringify({ folders: foldersWithUrls }),\n      });\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      {folders.map((folder, index) =&gt; (\n        &lt;div key={index}&gt;\n          &lt;input\n            type=&quot;text&quot;\n            value={folder.folderName}\n            onChange={(e) =&gt; updateFolder(index, { folderName: e.target.value })}\n            placeholder=&quot;Folder Name&quot;\n            required\n          /&gt;\n          &lt;input\n            type=&quot;file&quot;\n            multiple\n            onChange={(e) =&gt;\n              updateFolder(index, { files: Array.from(e.target.files || []) })\n            }\n          /&gt;\n        &lt;/div&gt;\n      ))}\n\n      &lt;button type=&quot;button&quot; onClick={addFolder}&gt;\n        Add Folder\n      &lt;/button&gt;\n      &lt;button type=&quot;submit&quot; disabled={isUploading}&gt;\n        {isUploading ? &quot;Uploading...&quot; : &quot;Submit&quot;}\n      &lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre>\n<h3>The presigned URL API route (S3 example)</h3>\n<pre><code>// app/api/get-upload-url/route.ts\nimport { S3Client, PutObjectCommand } from &quot;@aws-sdk/client-s3&quot;;\nimport { getSignedUrl } from &quot;@aws-sdk/s3-request-presigner&quot;;\n\nconst s3 = new S3Client({ region: process.env.AWS_REGION });\n\nexport async function POST(req: Request) {\n  const { filename, contentType } = await req.json();\n  const key = `uploads/${Date.now()}-${filename}`;\n\n  const command = new PutObjectCommand({\n    Bucket: process.env.S3_BUCKET,\n    Key: key,\n    ContentType: contentType,\n  });\n\n  const uploadUrl = await getSignedUrl(s3, command, { expiresIn: 600 });\n  const fileUrl = `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${key}`;\n\n  return Response.json({ uploadUrl, fileUrl });\n}\n</code></pre>\n<h3>To answer your questions directly</h3>\n<ol>\n<li><p><strong>Best practice:</strong> Presigned URLs (S3) or direct upload endpoints (Cloudinary, UploadThing). Files never touch your server.</p>\n</li>\n<li><p><strong>Cloudinary/UploadThing:</strong> Both have client-side SDKs that handle this. For Cloudinary, use their <a href=\"https://cloudinary.com/documentation/upload_widget\" rel=\"nofollow noreferrer\">upload widget</a> or unsigned uploads. UploadThing has a React hook that handles everything.</p>\n</li>\n<li><p><strong>Associating files with folders:</strong> Store files in React state (not just the DOM), keyed by folder index. Upload them in the submit handler and keep the folder association in your loop.</p>\n</li>\n<li><p><strong>Metadata only:</strong> Yes\u2014submit <code>{ folderName: string, fileUrls: string[] }[]</code> after uploads complete. Your API route stays small and fast.</p>\n</li>\n<li></li>\n</ol>\n", "tags": ["reactjs", "next.js", "web", "mern", "cloudinary"]}
