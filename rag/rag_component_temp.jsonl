{"id": "301d6bf1-7ac7-41c0-9cf7-997e062c6c20", "text": "Q: ActiveMQ Artemis: FirstElementConnectionLoadBalancingPolicy fails to connect when first initial connector is down A: <p>The behavior you're seeing is indeed expected based on the load-balancing policy you've chosen. The difference in the behavior between the topology vs initial-connectors use-case is due to the fact that topology is <em>dynamic</em> whereas the initial-connectors are <em>static</em>.</p>\n<p>When a node leaves the cluster (for whatever reason) that node is removed from the topology. Therefore, when using <code>FirstElementConnectionLoadBalancingPolicy</code> to get a connector from the topology the &quot;first element&quot; will be different than it was before. This is why client is able to connect to another node in the cluster.</p>\n<p>However, the &quot;first element&quot; in the initial-connectors never changes so if that node is down initially you have to wait for it to come up.</p>\n<p>To be clear, the explicit design of the <code>FirstElementConnectionLoadBalancingPolicy</code> is to always choose the first element. In your case, this behavior appears like a <em>bug</em>, but in other use-cases it is a <em>feature</em>. If the client switched to some kind of round-robin method that would invalidate the behavior of the <code>FirstElementConnectionLoadBalancingPolicy</code>.</p>\n", "tags": ["activemq-artemis"]}
{"id": "d314ee8c-80fe-4561-81c5-08ad2c50f26d", "text": "Q: unlink a file from dataframe A: <p>another way of saying &quot;unlink&quot;: the file handle is still in use, so how can i ensure it gets closed? nowadays  when reading/writing files in Python it's always recommended use a context manager aka &quot;with&quot; statement, e.g. to handle file closing upon completion of reading/writing.</p>\n<p>for example:</p>\n<pre><code>with open(file_path, 'rb') as f:\n    df = pd.read_excel(f)\n</code></pre>\n<p>when your code executes the <code>with</code> block you'll have the data in <code>df</code>, and the file will have been closed.</p>\n", "tags": ["python", "dataframe", "file", "unlink"]}
{"id": "9d825ac9-3d92-47e3-9fbe-1fd4d75a8b8e", "text": "Q: Set the range of the y axis in Plotly A: <p>Building on the accepted answer, you can use <code>None</code> to set only one limit and leave the other to the automatic default (<a href=\"https://plotly.com/python-api-reference/generated/plotly.graph_objects.Layout.html#plotly.graph_objects.layout.YAxis.range\" rel=\"nofollow noreferrer\">Docs</a>).</p>\n<p>For instance, setting the Y-axis to [0, auto]:</p>\n<pre class=\"lang-py prettyprint-override\"><code>fig.update_layout(yaxis={&quot;range&quot;: [0, None]})\n</code></pre>\n", "tags": ["python", "plotly"]}
{"id": "75c575a1-9e81-4971-bd4f-2da270435237", "text": "Q: Sorting behaviour difference running bash script in a console session vs cron job A: <p>I ran the above commands and directed all output to a text file:</p>\n<ol>\n<li><p>From a console session (as root)</p>\n</li>\n<li><p>The command directly from a cron job</p>\n</li>\n<li><p>The command in a bash script launched from a cron job</p>\n</li>\n</ol>\n<p>All three outputs, aside from some small changes in the \u2019used\u2019 and \u2018avail\u2019  values are exactly the same (as in they are in the exact same order)</p>\n", "tags": ["bash"]}
{"id": "5a22da50-1356-47dc-ada7-3dd9eeab18bc", "text": "Q: Good ways to keep certain rows in case there are multiple unique rows A: <p><code>ROW_NUMBER</code> can be used:</p>\n<pre><code>SELECT NAME, STATUS\nFROM (\n  SELECT NAME, STATUS,\n   ROW_NUMBER() OVER(PARTITION BY NAME \n                   ORDER BY CASE STATUS WHEN 'NEW' THEN 1 ELSE 2 END) AS rn\n  FROM MyTable\n  WHERE STATUS IN ('NEW', 'CURRENT'))\nWHERE rn = 1;\n</code></pre>\n<p><strong><a href=\"https://dbfiddle.uk/Zc9TQihN\" rel=\"nofollow noreferrer\">db&lt;&gt;fiddle demo</a></strong></p>\n<p>If version 26ai then <strong>QUALIFY</strong> is the way to go:</p>\n<pre><code>SELECT NAME, STATUS\nFROM MyTable\nWHERE STATUS IN ('NEW', 'CURRENT')\nQUALIFY ROW_NUMBER() OVER(PARTITION BY NAME \n                          ORDER BY CASE STATUS WHEN 'NEW' THEN 1 ELSE 2 END) = 1\n</code></pre>\n", "tags": ["sql", "oracle-database", "plsql"]}
{"id": "750d47c8-a8b7-40d6-b45d-bb04527c4b61", "text": "Q: Recursively print diamond in python A: <pre><code>def diam_rec(w,i=None):\n    if i == None: # 1st time\n       w+=(1-w%2) # make it next odd\n       i = w - 1  # i goes from w to -w by 2\n    if i &lt; (-w + 1): return\n    print(f&quot;{'*' * (w - abs(i))}&quot;.center(w))\n    diam_rec(w,i-2)  \n</code></pre>\n<p>Output: for diam_rec(12):</p>\n<pre class=\"lang-none prettyprint-override\"><code>      *      \n     ***     \n    *****    \n   *******   \n  *********  \n *********** \n*************\n *********** \n  *********  \n   *******   \n    *****    \n     ***     \n      *      \n</code></pre>\n", "tags": ["python", "printing", "recursion", "python-3.x"]}
{"id": "af9f96ea-145f-4cdc-962f-0eface3b5ac5", "text": "Q: How to sort a text file by lines? A: <p>If you really want to do it in C, you may want to read the whole file using the <code>getline (3)</code> function, and put the result in a linked list in case you do not know the number of lines of the file.</p>\n\n<p>Once done, you could simply use <code>strcmp (3)</code> with the sorting algorithm of your choice (bubble sort, insertion sort, etc...).</p>\n\n<p>You'd then be able to re-open the file for writing and insert your sorted linked list.</p>\n\n<hr>\n\n<p><strong>Edit</strong>:</p>\n\n<p>As asked in the comments by @alk, I think it'd be better for your programs to use linked lists instead of regular array in case you do not know the size of your file.</p>\n\n<p><strong>Pro</strong>:\nYou do not know the size of your file, using an array would force you to use <code>realloc (3)</code> which would be costly in resources over time as the realloc function actually creates a new pointer, copy the whole content of the date pointed by your old pointer, and free the old pointer. If the file is relatively short, it shouldn't be a problem, but when you'll begin to have large files, it could potentially be an issue regarding the performances.</p>\n\n<p><strong>Con</strong>:\nLinked list effectively complexifies your work. A way around that would be to create your very own general liked list lib, and use it in the projects you need so you only have to do it once.</p>\n", "tags": ["c", "arrays", "sorting"]}
