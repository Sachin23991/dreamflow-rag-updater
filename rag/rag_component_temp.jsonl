{"id": "b1d657e2-e0d2-4245-a190-df2be7b462c8", "text": "Q: How to pass a conditionally pass a vector to dplyr::select using quosures? A: <p>Perhaps <code>{{ }}</code> would be simpler here. See <a href=\"https://dplyr.tidyverse.org/articles/programming.html#indirection-1\" rel=\"nofollow noreferrer\">https://dplyr.tidyverse.org/articles/programming.html#indirection-1</a></p>\n<pre><code>fill_temp_c &lt;- function(df,drop.col = NULL) {\n    df |&gt; select(-{{drop.col}}) \n}\n\nfill_temp_c(df=mtcars)\n#                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n#Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n#Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n\nfill_temp_c(df=mtcars, drop.col=c(cyl:hp,gear))\n#                     mpg drat    wt  qsec vs am carb\n#Mazda RX4           21.0 3.90 2.620 16.46  0  1    4\n#Mazda RX4 Wag       21.0 3.90 2.875 17.02  0  1    4\n#Datsun 710          22.8 3.85 2.320 18.61  1  1    1\n</code></pre>\n", "tags": ["r", "if-statement", "dplyr", "conditional-formatting", "quosure"]}
{"id": "447a77ee-1c19-4540-a126-703d86b31406", "text": "Q: Cannot run my PHP Apache PHP-FPM website locally on MacOS because of weird ObjectiveC error: objc[1495]: +[NSPlaceholderString initialize] A: <p>Here's the answer: <code>/System/Library/LaunchDaemons/org.apache.httpd.plist</code> is a file that is used by the internal, built in MacOS Apache httpd. It goes without saying, don't use built-in apache on MacOS.</p>\n<p>I disabled built-in apache when I installed homebrew apache but it started back up again with an update and since MacOS apache is greedy with it's connections I was connecting to that version instead.</p>\n<p>When built-in MacOS apache started up again was just debugging the errors I was seeing. That's how this question showed up. Stopping MacOS apache was the solution.</p>\n", "tags": ["php", "apache", "memcached", "macos-tahoe", "postgresql-18"]}
{"id": "2ee90cd9-fd96-4fc8-a5c3-4fc8ec65a35a", "text": "Q: How to apply Liquid Glass effect to Widget background in iOS 26? A: <p>Try <code>.glassEffect(.regular)</code><br />\nIt works for Text and Image at least.</p>\n<pre><code>            ResultView(count: viewModel.listItems.count)\n                .frame(height: 44)\n                .padding(.horizontal, 16)\n                .glassEffect(.regular)\n\n\nfileprivate struct ResultView: View {\n    var count: Int\n    \n    var body: some View {\n        Text(&quot;\\(count) result\\(count == 1 ? &quot;&quot; : &quot;s&quot;)&quot;)\n            .foregroundColor(.label)\n    }\n}\n</code></pre>\n<p>UPDATE for @evan-templeton</p>\n<p>Works well for me - see &quot;4 results&quot;</p>\n<p><a href=\"https://i.sstatic.net/Wz9VihwX.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Wz9VihwX.jpg\" alt=\"enter image description here\" /></a></p>\n", "tags": ["swiftui", "widgetkit", "ios26", "liquid-glass"]}
{"id": "d424a76c-a76e-4d81-94e6-f33913e9d97b", "text": "Q: Does the order of columns in a Postgres table impact performance? A: <p>I agree with <a href=\"https://stackoverflow.com/a/12608013\">Erwin's answer</a>. It is informative and accurate. But what happens when &quot;it's not worth bothering&quot; does not hold true?</p>\n<p>Some databases start out small but undergo a massive jump in workload and the design that started off for smaller data volumes does not suit the new workload.</p>\n<p>Example with column ordinal, types and null-ability from a real life table:</p>\n<pre><code>CREATE TABLE IF NOT EXISTS column_alignment_test (\n    c1      POINT               NULL\n   ,c2      NUMERIC(9,6)    NOT NULL\n   ,c3      NUMERIC(9,6)    NOT NULL\n   ,c4      BIGINT          NOT NULL\n   ,c5      INT             NOT NULL\n   ,c6      BIGINT          NOT NULL\n   ,c7      TIMESTAMP(3)        NULL\n   ,c8      INT             NOT NULL\n   ,c9      TIMESTAMP(3)    NOT NULL\n   ,c10     TIMESTAMP(3)    NOT NULL\n   ,c11     VARCHAR(50)         NULL\n   ,c12     INT             NOT NULL\n   ,c13     INT             NOT NULL\n   ,c14     TEXT                NULL\n   ,c15     TEXT                NULL\n   ,c16     TEXT                NULL\n);\n</code></pre>\n<p>When we start getting into larger data volumes smaller design decisions start to add up to big difference. To inspect the padding based on the column alignment:</p>\n<pre><code>CREATE OR REPLACE FUNCTION check_column_alignment(\n    target_table_name text\n)\nRETURNS TABLE (\n    column_name text\n   ,current_ordinal int\n   ,type_name text\n   ,type_len int\n   ,type_align char\n   ,align_bytes int\n   ,current_padding_bytes int\n   ,is_nullable boolean\n) AS $$\nDECLARE\n    r record;\n    cur_offset int := 0;\n    cur_padding int;\nBEGIN\n    cur_offset := 0; -- Start at 0 relative to data area\n\n    FOR r IN\n        SELECT  a.attname\n               ,a.attnum\n               ,t.typname\n               ,t.typlen\n               ,t.typalign\n               ,NOT a.attnotnull AS is_nullable\n               ,CASE t.typalign WHEN 'c' THEN 1 \n                                WHEN 's' THEN 2 \n                                WHEN 'i' THEN 4 \n                                WHEN 'd' THEN 8 \n                                ELSE 1\n                END AS align_bytes\n               ,CASE WHEN t.typlen = -1 \n                     THEN 0 \n                     ELSE t.typlen \n                 END AS nominal_len\n        FROM    pg_attribute a\n                INNER JOIN pg_type t ON a.atttypid = t.oid\n                INNER JOIN pg_class c ON a.attrelid = c.oid\n                INNER JOIN pg_namespace n ON c.relnamespace = n.oid\n        WHERE   c.relname = target_table_name\n                AND a.attnum &gt; 0 AND NOT a.attisdropped\n        ORDER BY a.attnum\n    LOOP\n        -- Calculate Padding for Current Order\n        IF cur_offset % r.align_bytes = 0 THEN\n            cur_padding := 0;\n        ELSE\n            cur_padding := r.align_bytes - (cur_offset % r.align_bytes);\n        END IF;\n\n        column_name := r.attname;\n        current_ordinal := r.attnum;\n        type_name := r.typname;\n        type_len := r.typlen;\n        type_align := r.typalign;\n        align_bytes := r.align_bytes;\n        current_padding_bytes := cur_padding;\n        is_nullable := r.is_nullable;\n\n        -- Update offset (simulate data write)\n        cur_offset := cur_offset + cur_padding + CASE WHEN r.nominal_len = 0 THEN 4 ELSE r.nominal_len END;\n\n        RETURN NEXT;\n    END LOOP;\nEND;\n$$ LANGUAGE plpgsql;\n</code></pre>\n<pre><code>select * from check_column_alignment('column_alignment_test');\n\n column_name | current_ordinal | type_name | type_len | type_align | align_bytes | current_padding_bytes | is_nullable\n-------------+-----------------+-----------+----------+------------+-------------+-----------------------+-------------\n c1          |               1 | int4      |        4 | i          |           4 |                     0 | f\n c2          |               2 | point     |       16 | d          |           8 |                     4 | t\n c3          |               3 | numeric   |       -1 | i          |           4 |                     0 | f\n c4          |               4 | numeric   |       -1 | i          |           4 |                     0 | f\n c5          |               5 | int8      |        8 | d          |           8 |                     0 | f\n c6          |               6 | int8      |        8 | d          |           8 |                     0 | f\n c7          |               7 | timestamp |        8 | d          |           8 |                     0 | t\n c8          |               8 | int4      |        4 | i          |           4 |                     0 | f\n c9          |               9 | timestamp |        8 | d          |           8 |                     4 | f\n c10         |              10 | timestamp |        8 | d          |           8 |                     0 | f\n c11         |              11 | varchar   |       -1 | i          |           4 |                     0 | t\n c12         |              12 | int4      |        4 | i          |           4 |                     0 | f\n c13         |              13 | int4      |        4 | i          |           4 |                     0 | f\n c14         |              14 | text      |       -1 | i          |           4 |                     0 | t\n c15         |              15 | text      |       -1 | i          |           4 |                     0 | t\n c16         |              16 | text      |       -1 | i          |           4 |                     0 | t\n</code></pre>\n<p>There are two columns where current_padding_bytes is not zero. This represents wasted space. On small tables this is not so bad but once we get into the millions and hundreds of millions of rows plus this starts to add up. On a 100 million row table this equates to 800 million bytes or 0.8GB. This is all wasted space on each 8kb page and can start to eat into performance.</p>\n<p>It is not so simple to optimize our design and the optimal design for a table really depends a lot on the workload. There are two main ways one can view the physical design. One is to prioritize reads (CPU) and the other to prioritize storage (IO).</p>\n<p>As <a href=\"https://stackoverflow.com/users/939860/erwin-brandstetter\">Erwin Brandstetter</a> stated in 2012, reading column values can incur more CPU cycles if the columns are ordered in a certain way. To reduce CPU overhead when reading the optimal approach is to ensure that fixed length, non-null columns appear before variable length or nullable columns. This allows PostgreSQL to <a href=\"https://github.com/postgres/postgres/blob/master/src/backend/access/common/heaptuple.c#L583\" rel=\"nofollow noreferrer\">cache the column offset</a> and greatly improve retrieval times. Otherwise, it must take the slow path which may incur anything up to ~20 CPU cycles for each column after the last fixed value non-nullable one that is not preceded by a variable length or nullable column. This happens for every row on every read.</p>\n<p>To figure out what design my be more beneficial I have another utility function to assess the desired column alignment to optimize for CPU. This may sometimes sacrifice space with zero padding being introduced.</p>\n<pre><code>CREATE OR REPLACE FUNCTION suggest_column_alignment( \n    target_table_name text\n   ,optimization_mode text DEFAULT 'cpu' \n)\nRETURNS TABLE (\n    column_name text\n   ,type_name text\n   ,is_nullable boolean\n   ,current_ordinal int\n   ,suggested_ordinal bigint\n   ,old_padding_bytes int\n   ,new_padding_bytes int\n   ,status text\n   ,reason text\n) AS $$\nBEGIN\n    IF optimization_mode NOT IN ('cpu', 'io') THEN\n        RAISE EXCEPTION 'Invalid optimization_mode. Use ''cpu'' or ''io''.';\n    END IF;\n\n    RETURN QUERY \n    WITH RECURSIVE current_state AS (\n        SELECT * FROM check_column_alignment(target_table_name)\n    ), optimized_state AS (\n        SELECT  cs.column_name\n               ,cs.type_name\n               ,cs.is_nullable\n               ,cs.current_ordinal\n               ,cs.type_len\n               ,cs.type_align\n               ,cs.align_bytes\n               ,cs.current_padding_bytes\n\n               -- Rank for final sorting\n               ,ROW_NUMBER() OVER (ORDER BY base.sort_group \n                                           ,base.align_rank \n                                           ,cs.is_nullable -- &lt;--- NEW: Free CPU optimization (False/NotNull comes first)\n                                           ,cs.type_name   \n                                           ,cs.column_name) as new_rank\n\n                -- Generate Reason Text\n               ,CASE WHEN optimization_mode = 'cpu' \n                     THEN CASE base.sort_group\n                               WHEN 1 THEN 'CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access)'\n                               WHEN 2 THEN 'CPU Priority: Fixed-width &amp; NULL'\n                               WHEN 3 THEN 'Variable-width (moved to end)'\n                               ELSE 'Variable-width'\n                          END\n                     ELSE CASE base.sort_group\n                               WHEN 1 THEN 'IO Priority: Fixed-width (Packed by alignment)'\n                               ELSE 'IO Priority: Variable-width (Moved to end)'\n                          END\n                END \n                || \n                CASE WHEN cs.type_align = 'd' THEN ' + 8-byte align'\n                     WHEN cs.type_align = 'i' THEN ' + 4-byte align'\n                     ELSE ''\n                END \n                || \n                CASE WHEN optimization_mode = 'io' AND NOT cs.is_nullable THEN ' + Not Null (Cached Offset)'\n                     ELSE ''\n                END as reason_text\n        FROM    current_state cs\n        CROSS JOIN LATERAL (\n            SELECT \n                -- PRIORITY 1: MACRO GROUPING\n                CASE \n                    WHEN optimization_mode = 'cpu'\n                    THEN CASE WHEN cs.type_len &gt; 0 AND NOT cs.is_nullable THEN 1 \n                              WHEN cs.type_len &gt; 0 AND cs.is_nullable THEN 2     \n                              ELSE 3\n                         END\n                    ELSE CASE WHEN cs.type_len &gt; 0 THEN 1 \n                              ELSE 2\n                         END\n                END as sort_group,\n                \n                -- PRIORITY 2: ALIGNMENT STRICTNESS\n                CASE cs.type_align \n                    WHEN 'd' THEN 1 -- 8 bytes \n                    WHEN 'i' THEN 2 -- 4 bytes \n                    WHEN 's' THEN 3 -- 2 bytes \n                    ELSE 4          -- 1 byte  \n                END as align_rank\n        ) base\n    ),sim_offset AS (\n        SELECT  os.column_name\n               ,os.new_rank\n               ,os.align_bytes\n               ,os.type_len\n               ,0 as start_offset\n               ,0 as padding_added\n        FROM    optimized_state os \n        WHERE   os.new_rank = 1\n\n        UNION ALL\n\n        SELECT  os.column_name\n               ,os.new_rank\n               ,os.align_bytes\n               ,os.type_len\n               ,(s.start_offset + s.padding_added + CASE WHEN s.type_len = -1 THEN 4 ELSE s.type_len END) as start_offset\n               ,(os.align_bytes - ((s.start_offset + s.padding_added + CASE WHEN s.type_len = -1 THEN 4 ELSE s.type_len END) % os.align_bytes)) % os.align_bytes as padding_added\n        FROM    optimized_state os\n                INNER JOIN sim_offset s ON os.new_rank = s.new_rank + 1\n    )\n    SELECT  c.column_name\n           ,c.type_name\n           ,c.is_nullable\n           ,c.current_ordinal\n           ,o.new_rank as suggested_ordinal\n           ,c.current_padding_bytes as old_padding_bytes\n           ,s.padding_added as new_padding_bytes\n           ,CASE WHEN c.current_padding_bytes &gt; s.padding_added THEN 'SAVED SPACE'\n                 WHEN c.current_padding_bytes &lt; s.padding_added THEN 'LOST SPACE'\n                 ELSE 'Neutral'\n            END as status\n           ,o.reason_text::text as reason\n    FROM  current_state c\n          INNER JOIN optimized_state o ON c.column_name = o.column_name\n          INNER JOIN sim_offset s ON c.column_name = s.column_name\n    ORDER BY o.new_rank;\nEND;\n$$ LANGUAGE plpgsql;\n</code></pre>\n<pre><code>select * from suggest_column_alignment('column_alignment_test', 'cpu');\n\n column_name | type_name | is_nullable | current_ordinal | suggested_ordinal | old_padding_bytes | new_padding_bytes |   status    |                                reason\n-------------+-----------+-------------+-----------------+-------------------+-------------------+-------------------+-------------+----------------------------------------------------------------------\n c5          | int8      | f           |               5 |                 1 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 8-byte align\n c6          | int8      | f           |               6 |                 2 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 8-byte align\n c10         | timestamp | f           |              10 |                 3 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 8-byte align\n c9          | timestamp | f           |               9 |                 4 |                 4 |                 0 | SAVED SPACE | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 8-byte align\n c1          | int4      | f           |               1 |                 5 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 4-byte align\n c12         | int4      | f           |              12 |                 6 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 4-byte align\n c13         | int4      | f           |              13 |                 7 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 4-byte align\n c8          | int4      | f           |               8 |                 8 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NOT NULL (Fastest Access) + 4-byte align\n c2          | point     | t           |               2 |                 9 |                 4 |                 0 | SAVED SPACE | CPU Priority: Fixed-width &amp; NULL + 8-byte align\n c7          | timestamp | t           |               7 |                10 |                 0 |                 0 | Neutral     | CPU Priority: Fixed-width &amp; NULL + 8-byte align\n c3          | numeric   | f           |               3 |                11 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n c4          | numeric   | f           |               4 |                12 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n c14         | text      | t           |              14 |                13 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n c15         | text      | t           |              15 |                14 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n c16         | text      | t           |              16 |                15 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n c11         | varchar   | t           |              11 |                16 |                 0 |                 0 | Neutral     | Variable-width (moved to end) + 4-byte align\n</code></pre>\n<p>In this scenario the CPU bias also coincides with being optimal for storage too. But there is an option to run it for <code>'io'</code> and see how that column alignment will look. This may be a better option for large tables that are not accessed excessively.</p>\n", "tags": ["postgresql", "performance", "database-design", "storage", "postgresql-performance"]}
{"id": "a72f2ddc-0f31-437a-bf0c-2aa8ef7611ef", "text": "Q: How to check backfill property of materialized view after its creation in database? A: <p>Here is my query</p>\n<p>.create async materialized-view with (backfill=true, effectiveDateTime=datetime(1970-01-01), \u00a0Lookback=&quot;30.00:00:00&quot;) &lt;viewName&gt; on table &lt;tableName&gt;</p>\n<p>{</p>\n<p>&lt;tableName&gt;</p>\n<p>| summarize hint.strategy=shuffle arg_max(DateTime, c1, c2, c3) by Id</p>\n<p>}</p>\n<p>it just backfills only for a day instead of 30 days data present in the table in kusto. I assume this is because of arg_max operation. tried changing the value of effectiveDateTime and Lookback but it didnot help</p>\n", "tags": ["azure", "azure-data-explorer", "kusto-explorer", "adx"]}
{"id": "2dd5caf2-8f32-4944-921e-52d33adfb8c9", "text": "Q: what is the best practice to get the right compare of byte array? A: <pre><code>The core issue is conceptual: you are trying to detect \u201cencoding\u201d from a\nsingle character\u2019s byte pattern. That is not how encodings work.\n\nA `char` in .NET is already a Unicode code point (UTF-16). Calling\n`Encoding.Unicode.GetBytes()` will always give you UTF-16 bytes, so you\nare not detecting different encodings at all \u2014 you are only inspecting\nUnicode ranges.\n\nIf your goal is to detect which script/range a character belongs to\n(Latin, Greek, Cyrillic, etc.), you should NOT compare raw byte arrays.\nInstead, compare Unicode code points or use Unicode categories.\n\nBetter approach 1: compare Unicode ranges directly\n\n```csharp\nprivate static string GetName(char c)\n{\n    int code = c;\n\n    if (code &gt;= 0x0000 &amp;&amp; code &lt;= 0x00FF)\n        return &quot;Latin&quot;;\n    if (code &gt;= 0x0370 &amp;&amp; code &lt;= 0x03FF)\n        return &quot;Greek&quot;;\n    if (code &gt;= 0x0400 &amp;&amp; code &lt;= 0x04FF)\n        return &quot;Cyrillic&quot;;\n\n    return &quot;Unknown&quot;;\n}\n</code></pre>\n<pre><code></code></pre>\n", "tags": ["c#", ".net", "unicode", "encoding"]}
