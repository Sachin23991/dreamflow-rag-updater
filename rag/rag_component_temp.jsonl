{"id": "855c149a-c07b-4b3e-846b-909f1622b555", "text": "Q: How to enable Razor/Blazor LSP support in Neovim using lazy.nvim? A: <p>Thank you so much! This was really helpful I got this working</p>\n", "tags": ["c#", "razor", "neovim"]}
{"id": "538b590e-efad-4ce3-83b2-9266a27bbea8", "text": "Q: Why can&#39;t the for loop get the value from the list? A: <p>I don't think that a for loop is what you really want to use to get a value from your myList.\nI gather from your code that you are trying to print lines from your myList on the canvas when the button is clicked.\nI had to change the font since you are trying to print both latin and chinese characters in the strings present in myList.</p>\n<p>Running the following code, clicking on the button will display random strings from myList.</p>\n<pre><code>import pygame\nimport random\n\npygame.mixer.init()\npygame.init()\nsize = (1280, 580)\nscreen = pygame.display.set_mode(size)\npygame.display.set_caption(&quot;1&quot;)\nbg = pygame.image.load(&quot;b&quot;)\nwhite = (0, 0, 0)\nblack = (230, 0, 100)\nlight_grey = (224, 224, 224)\ndark_grey = (200, 200, 200)\ntext = pygame.font.SysFont(&quot;Agency FB&quot;, 20)\nmyList = [&quot;a5\u4e00\u4e2a5\u02c8ei&quot;, &quot;am5\u662f5\u00e6m&quot;, &quot;are5\u662f5a:r&quot;]\n\nfont = pygame.font.SysFont(&quot;Microsoft YaHei&quot;, 25)\nbutton_text = font.render(&quot;\u6309\u94ae&quot;, True, black)\n\nbutton_rect = pygame.Rect(70, 350, 200, 200)\nbFont = None\nvar = True\nwhile var:\n    mouse = pygame.mouse.get_pos()\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            var = False\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            if button_rect.collidepoint(event.pos):\n                rb = random.choice(myList)\n                bFont = font.render(rb, True, white)\n                rb = random.choice(myList)\n                bFont1 = font.render(rb, True, white)\n    screen.blit(bg, (0, 0))\n    if button_rect.collidepoint(mouse):\n        pygame.draw.rect(screen, dark_grey, (70, 350, 200, 200), 0)\n    else:\n        pygame.draw.rect(screen, light_grey, (70, 350, 200, 200), 0)\n    screen.blit(button_text, (90, 450))\n    if bFont:\n        screen.blit(bFont, (70, 100))\n        screen.blit(bFont1, (70, 220))\n    pygame.display.update()\n\n</code></pre>\n", "tags": ["python", "for-loop"]}
{"id": "4be7d9b6-6cf8-4a5b-b319-15e6c6e228a2", "text": "Q: Why is list[list[str]] not equal to list[HashableList[Hashable]] A: <p>Even though <code>str</code> is a subtype of <code>Hashable</code>, a <code>list[str]</code> is <strong>not</strong> a subtype of <code>list[Hashable]</code>. If a function expects a <code>list[Hashable]</code>, it expects a list that it can potentially add <em>any</em> hashable item to (like an integer).</p>\n<p>If you pass it a <code>list[str]</code>, and the function tries to append an <code>int</code>, it would violate your list's type safety.</p>\n<p>You can cast the variables when calling the function, though this is less &quot;clean&quot;:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from typing import cast, Any\n\nmosaic, kw = create_mosaic(3)\nplt.subplot_mosaic(\n    cast(Any, mosaic), \n    per_subplot_kw=cast(Any, kw)\n)\n</code></pre>\n", "tags": ["python-3.x", "matplotlib", "typing"]}
