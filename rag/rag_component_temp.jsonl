{"id": "40c0d4ed-9906-4678-ba8a-ba9b91905f15", "text": "Q: How to add prefix and suffix to every element in array in Jinja2? A: <p>It can be done with only basic Jinja2 filters. Suppose <strong>arr</strong> holds the list, <strong>pre</strong> holds the prefix and <strong>post</strong> holds the postfix. Then we have oneliner Jinja2 transformation:</p>\n<pre class=\"lang-none prettyprint-override\"><code>{{ arr | map('reverse') | slice(arr|length, pre|reverse) | map('join') | map('reverse') | slice(arr|length, post) | map('join') | list }}\n</code></pre>\n<p>The key operation is that we can use <code>slice(arr|length, post) | map('join')</code> to concatenate the postfix and with <code>reverse</code> to do the prefix conatenation.</p>\n", "tags": ["ansible", "jinja2"]}
{"id": "97f0c076-02a1-4393-8a9c-4f2e7aefd800", "text": "Q: Azure Container Apps - How to import trusted 3rd party certificate A: <p>I had the same question. We solved in our Dockerfile.</p>\n<p>Here is the code that we used in the Dockerfile:</p>\n<pre><code># This stage is used when running from VS in fast mode (Default for Debug configuration)\nFROM mcr.microsoft.com/dotnet/aspnet:10.0 AS base\n\n# We need root to modify system certs\nUSER root\n\n# Copy the third-party root CA (public cert only, no private key!)\n# Place this file in your repo at: certs/my-cert.crt\nCOPY /certs/my-cert.crt /usr/local/share/ca-certificates/my-cert.crt\n\n# Register the CA so it's trusted by OpenSSL/.NET\nRUN chmod 644 /usr/local/share/ca-certificates/my-cert.crt\nRUN update-ca-certificates\n</code></pre>\n", "tags": ["azure", "ssl", "azure-container-apps"]}
{"id": "dec6a22a-3398-4bd3-833d-9febb3294aa2", "text": "Q: Is it safe to use public functions in C++? A: <p>As others already wrote, <code>public</code>/<code>private</code> have nothing to do with being &quot;safe&quot; when it comes to obfuscating code for security reasons.</p>\n<p>A few words about what they <em>actually are</em>:</p>\n<p><code>public</code>/<code>protected</code>/<code>private</code> are <a href=\"http://en.cppreference.com/w/cpp/language/access.html\" rel=\"nofollow noreferrer\"><strong>Access specifiers</strong></a> for the methods.<br />\nThey determine which parts of the code can call them.<br />\nE.g. - <code>public</code> means you can call them anywhere. <code>private</code> means only methods of the same class (or <code>friend</code>s) can call them. etc.<br />\nIf you attempt to call e.g. a <code>private</code> method where you are not supposed to, you will get a compilation error.</p>\n<p>More info is available in the link above, and also in numerous posts on SO, e.g.: <a href=\"https://stackoverflow.com/questions/14399929/should-i-use-public-or-private-variables\">Should I use public or private variables?</a>.</p>\n", "tags": ["c++", "function", "class", "private", "public"]}
{"id": "08e9f03a-7fff-4feb-b7ef-a2fb7763a2c2", "text": "Q: Can AbortController be used with Fetch Post requests without automatically triggering a close event? A: <p><strong>No.</strong> Aborting a <code>fetch()</code> request with <code>AbortController</code> always terminates the underlying HTTP connection, regardless of whether the request is GET or POST. This behavior is by design.</p>\n<p>When <code>controller.abort()</code> is called, the browser closes the TCP socket. On the server (Node/Express), this appears as the request stream ending, which is why connection-related events are triggered.</p>\n<p>The confusion comes from this line:</p>\n<pre><code>req.on('close', ...)\n</code></pre>\n<p>The <code>'close'</code> event does <strong>not</strong> mean \u201cclient aborted\u201d. It fires when:</p>\n<ul>\n<li><p>the socket closes, <strong>or</strong></p>\n</li>\n<li><p>the request/response lifecycle completes, <strong>or</strong></p>\n</li>\n<li><p>middleware (such as <code>body-parser</code>) finishes reading the request body</p>\n</li>\n</ul>\n<p>Because <code>bodyParser.json()</code> eagerly consumes the POST body, <code>'close'</code> may fire even when the client did not abort.</p>\n<p>The <code>'aborted'</code> event only fires if the client disconnects <strong>before the request body has been fully received</strong>. In your case, the body is already read by the time <code>AbortController.abort()</code> is called, so <code>'aborted'</code> will not fire.</p>\n<p>There is no HTTP-level mechanism to cancel a request without closing the connection. If server-side cancellation is required, it must be implemented at the application level (for example, by using a job ID and a separate cancellation endpoint).</p>\n", "tags": ["javascript", "node.js", "express", "fetch-api", "abortcontroller"]}
