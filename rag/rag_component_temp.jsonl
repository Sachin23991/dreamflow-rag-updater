{"id": "8dc0d6e1-945c-4d76-97ce-4716b697a8b5", "text": "Q: Thread safe initialisation of function-scoped static variables in C11 A: <p>How portable does your code need to be?</p>\n<p>This is really hard to do using C11-standard features.  AFAICT none of the C11 standard synchronization objects such as <code>mtx_t</code> mutexes provide any memory barriers that ensure visibility and atomicity of any object, and the C11 standard memory fences only apply to explicit atomic variables.</p>\n<p>Using POSIX, it's simple, and there's no need to use atomic variables under POSIX as POSIX mutexes provide full memory barriers.</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;pthread.h&gt;\n\n// note that *_t identifiers are reserved under POSIX...\nsome_t *func( void )\n{\n    static some_t thing;\n    static int thingInitialized = 0;\n\n    // C11 standard mtx_t also does not have a static initializer\n    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n    if ( !thingInitialized )\n    {\n        pthread_mutex_lock( &amp;mutex );\n\n        if ( !thingInitialized )\n        {\n            initThing( &amp;thing );\n            thingInitialized = 1;\n        }\n\n        pthread_mutex_unlock( &amp;mutex );\n    }\n\n    return( &amp;thing );\n}\n</code></pre>\n<p>The first thread to make the <code>func()</code> call will enter with <code>thingInitialized</code> set to <code>0</code>.  It will lock the mutex, recheck if <code>thingInitialized</code> is still zero, and if so it will initialize <code>thing</code> and set <code>thingInitialized</code> to <code>1</code> and then unlock the mutex.  If any other thread calls <code>func()</code> while <code>thingInitialized</code> is still zero, it will block waiting to lock the mutex.  Once the first thread initializes <code>thing</code> and sets <code>thingInitialized</code> to <code>1</code>, any subsequent thread that obtains the mutex lock will simply unlock the mutex without reinitializing <code>thing</code>.</p>\n<p>And any thread that calls <code>func()</code> <em>after</em> the first thread initializes <code>thing</code>, sets <code>thingInitialized</code> to <code>1</code> and then unlocks the mutex will skip locking the mutex entirely.</p>\n<p>And no complex code involving atomic values and threads spinning is needed.</p>\n", "tags": ["c", "linux", "multithreading", "c11"]}
{"id": "24810b57-b8b1-4fd5-868c-fd730d36a6a0", "text": "Q: x-modelable not working inside React component A: <p>I have successfully reproduced the issue where <code>count</code> gets incremented but <code>number</code> does not.</p>\n<p>The easiest fix is to remove &lt;StrictMode&gt; from <code>main.tsx</code>:</p>\n<pre class=\"lang-js prettyprint-override\"><code>import ReactDOM from &quot;react-dom/client&quot;;\nimport App from &quot;./App&quot;;\n\nReactDOM.createRoot(document.getElementById(&quot;root&quot;)!).render(\n    &lt;App /&gt;\n);\n</code></pre>\n<p>If, however, you want &lt;StrictMode&gt;, this worked for me:</p>\n<pre class=\"lang-js prettyprint-override\"><code>useLayoutEffect(() =&gt; {\n    const el = containerRef.current;\n    const Alpine = (window as any).Alpine;\n\n    if (el &amp;&amp; Alpine) {\n        console.log('\ud83d\udfe2 Initializing Alpine tree', el);\n        Alpine.initTree(el);\n        console.log('\u2705 Alpine tree initialized');\n    }\n\n    return () =&gt; {\n        if (el &amp;&amp; Alpine) {\n            console.log('\ud83d\udd34 Destroying Alpine tree', el);\n            Alpine.destroyTree(el);\n            console.log('\u2705 Alpine tree destroyed');\n        }\n    };\n}, [html]);\n</code></pre>\n<p>In StrictMode, React runs effects twice. Your original code called <code>Alpine.destroyTree(el)</code> during the first cleanup, which broke Alpine's <code>x-modelable</code> binding between the parent and child <code>x-data</code> scopes. When the effect ran again, <code>initTree</code> recreated the components but the two-way binding was permanently broken.</p>\n<p>By removing the cleanup (no <code>destroyTree</code> call), Alpine never gets destroyed during the double-run, so the <code>x-modelable</code> binding stays intact throughout both effect executions.</p>\n<p><code>useLayoutEffect</code> ensures Alpine initializes immediately and synchronously, eliminating timing issues between React's render cycle and Alpine's initialization.</p>\n<p><strong>EDIT:</strong> using <code>useEffect</code> also works in the code provided, but in your Alpine case, using <code>useLayoutEffect</code> guarantees Alpine initializes before any <code>useEffect</code> hooks that might depend on the Alpine instance being ready (e.g. using the <code>count</code> or <code>number</code> variables in your other <code>useEffects</code>).</p>\n<p><strong>EDIT 2:</strong> Full AlpinePreview component that logs active listeners, you can use it to check whether or not the listener was destroyed correctly:</p>\n<pre><code>import { useLayoutEffect, useRef } from 'react';\n\nexport function AlpinePreview({ html }: { html: string }) {\n    const containerRef = useRef&lt;HTMLDivElement&gt;(null);\n\n    useLayoutEffect(() =&gt; {\n        const el = containerRef.current;\n        const Alpine = (window as any).Alpine;\n        if (!el || !Alpine) return;\n\n        let listenerCount = 0;\n        const originalAdd = EventTarget.prototype.addEventListener;\n        const originalRemove = EventTarget.prototype.removeEventListener;\n        \n        // Track all listeners added to ANY element in the tree\n        EventTarget.prototype.addEventListener = function(type: string, listener: any, options?: any) {\n            // Only count if it's within our container\n            if (el.contains(this as Node) || this === el) {\n                listenerCount++;\n                console.log(`\u2795 [${type}] added to`, this, `\u2192 Total: ${listenerCount}`);\n            }\n            return originalAdd.call(this, type, listener, options);\n        };\n        \n        EventTarget.prototype.removeEventListener = function(type: string, listener: any, options?: any) {\n            if (el.contains(this as Node) || this === el) {\n                listenerCount--;\n                console.log(`\u2796 [${type}] removed from`, this, `\u2192 Total: ${listenerCount}`);\n            }\n            return originalRemove.call(this, type, listener, options);\n        };\n\n        console.log('\ud83d\udfe2 Initializing Alpine');\n        Alpine.initTree(el);\n        console.log(`\u2705 Mount complete \u2192 Active listeners: ${listenerCount}`);\n\n        return () =&gt; {\n            console.log('\ud83d\udd34 Starting cleanup');\n            Alpine.destroyTree(el);\n            console.log(`\u2705 Cleanup complete \u2192 Remaining listeners: ${listenerCount}`);\n            \n            // Restore original methods\n            EventTarget.prototype.addEventListener = originalAdd;\n            EventTarget.prototype.removeEventListener = originalRemove;\n        };\n    }, [html]);\n\n    return (\n        &lt;div\n            className=&quot;component-preview&quot;\n            ref={containerRef}\n            key={html.length}\n            dangerouslySetInnerHTML={{ __html: html }}\n        /&gt;\n    );\n}\n</code></pre>\n", "tags": ["reactjs", "alpine.js"]}
{"id": "764ca887-6a17-424e-be63-76e76f9c7386", "text": "Q: What is the best way to migrate Angular application from v 13 to 21 A: <p>Update version by version an follow the update guide: <a href=\"https://angular.dev/update-guide\" rel=\"nofollow noreferrer\">https://angular.dev/update-guide</a></p>\n", "tags": ["angular", "typescript", "unit-testing", "frontend", "angular-fullstack"]}
{"id": "7aade5a2-0916-4a6e-8b71-2eb32ccc512e", "text": "Q: Difference between Request (Facade) and Illuminate\\Http\\Request A: <p>Here's my approach:</p>\n<ol>\n<li><p>I don't usually use <code>Illuminate\\Http\\Request</code> directly. For testing and debugging, I prefer the <code>Request</code> facade to check visible variables quickly. I use the <code>php artisan make:request</code> command to handle mass assignment and validation rules separately from controllers. This makes development faster and more organized.</p>\n</li>\n<li><p>The <code>Request</code> facade helps access form data sent via POST or PUT, while CSRF protects against malicious form submissions.</p>\n</li>\n<li><p>I use both methods depending on the situation. For quick data checks (e.g., in Tinker or when dumping data from a controller), I use the <code>request()</code> function. Once I'm confident in the data, I switch to request controllers for clean, DRY code with clear separation of concerns.</p>\n</li>\n</ol>\n<p>Feel free to correct me if anything seems unclear or misleading.</p>\n", "tags": ["php", "laravel", "laravel-5", "laravel-request"]}
{"id": "b5189aa9-4d7b-4d35-8551-14f815a50a25", "text": "Q: Angular route cannot match path(NG04002) A: <p>I found the issue and it was not related to Angular routing itself.</p>\n<p>Angular I found the issue and it was not related to Angular routing itself.</p>\n<p>Angular does not match routes including the <code>baseHref</code>. It always strips <code>/</code><strong><code>myapp</code></strong> and expects the route to be <code>/hello</code>.</p>\n<p>Locally this works because <code>ng serve</code> automatically rewrites requests, but on my test environment the server was forwarding <code>/myapp/hello</code> directly to Angular without rewriting it to <code>index.html</code>. Because of that, Angular tried to match the route <code>myapp/hello</code> and threw <code>NG04002</code>.</p>\n<h3>Fix</h3>\n<p>I fixed it by adding a server-side rewrite so that all routes under <code>/myapp/</code> are redirected to <code>/myapp/index.html</code>.</p>\n<p>Example (Nginx):</p>\n<pre><code>location /myapp/ {\n  try_files $uri $uri/ /myapp/index.html;\n}\n</code></pre>\n<p>After this change, navigating to:</p>\n<pre><code>https://test-env/myapp/hello\n</code></pre>\n<p>works correctly.<strong><code>baseHref</code></strong>. It always strips <code>/myapp</code> and expects the route to be <code>/hello</code>.</p>\n<p>Locally this works because <code>ng serve</code> automatically rewrites requests, but on my test environment the server was forwarding <code>/myapp/hello</code> directly to Angular without rewriting it to <code>index.html</code>. Because of that, Angular tried to match the route <code>myapp/hello</code> and threw <code>NG04002</code>.</p>\n<h3>Fix</h3>\n<p>I fixed it by adding a server-side rewrite so that all routes under <code>/myapp/</code> are redirected to <code>/myapp/index.html</code>.</p>\n<p>Example (Nginx):</p>\n<pre><code>location /myapp/ {\n  try_files $uri $uri/ /myapp/index.html;\n}\n</code></pre>\n<p>After this change, navigating to:</p>\n<pre><code>https://test-env/myapp/hello\n</code></pre>\n", "tags": ["angular", "angular-router"]}
{"id": "bfbacebb-0a97-4275-8175-61fb0983e217", "text": "Q: Inner join performance issue A: <p>You don't care about the values inside your <code>EmployeeDepartmentHistory</code> table, only whether there is at least a history entry for this employee, so if you have many many actions by employees, your query will load them all and then group by to aggregate. You need to check for its existence instead:</p>\n<pre><code>SELECT\n    e.EmployeeName,\n    e.EmployeeSurname,\n    d.CompanyID,\n    e.DepartmentID,\n    e.JobTitle,\n    o.OfficeName,\n    o.OfficeCity\nFROM dbo.Employees e\nJOIN dbo.Departments d\n    ON d.DepartmentID = e.DepartmentID\nJOIN dbo.Companies c\n    ON c.CompanyID = d.CompanyID\nJOIN dbo.Offices o\n    ON o.OfficeID = e.OfficeID\nWHERE c.ItsOk = 'Y' and EXISTS (\n    SELECT 1\n    FROM dbo.EmployeeDepartmentHistory edh\n    WHERE edh.CompanyID = d.CompanyID AND\n          edh.EmployeeCode = e.EmployeeCode\n)\nGROUP BY\n    e.EmployeeName,\n    e.EmployeeSurname,\n    d.CompanyID,\n    e.DepartmentID,\n    e.JobTitle,\n    o.OfficeName,\n    o.OfficeCity;\n</code></pre>\n<p>This will have the search for the history as a subselect and will stop doing the subquery when the first match is found. Next, you may need an index for (<code>CompanyID</code>, <code>EmployeeCode</code>) for your <code>EmployeeDepartmentHistory</code> table to make the RDBMS look for the index rather than looking for each individual record. The index, after all will have a main structure for distinct company identifiers and will quickly realize whether the CompanyID has no match as well as if there is such a match the current employee will be easy to find by the inner index.</p>\n", "tags": ["sql", "sql-server", "database-performance"]}
{"id": "0bd92ec4-102f-4231-b158-f7323e913898", "text": "Q: UITextView Representable in SwiftUI not respecting bounds for width in ScrollView A: <p>This worked for me. I had to override <a href=\"https://developer.apple.com/documentation/swiftui/uiviewrepresentable/sizethatfits(_:uiview:context:)-5tdxh?changes=_3\" rel=\"nofollow noreferrer\">sizeThatFits</a> to make it work.</p>\n<pre class=\"lang-swift prettyprint-override\"><code>struct DataDetectionText: UIViewRepresentable {\n    init(\n        _ text: String,\n        font: UIFont = UIFont.preferredFont(forTextStyle: .body),\n        fontColor: UIColor = .label,\n        isDataDetectionEnabled: Bool = true\n    ) {\n        self.text = text\n        self.font = font\n        self.fontColor = fontColor\n        self.isDataDetectionEnabled = isDataDetectionEnabled\n    }\n\n    private let text: String\n    private let font: UIFont\n    private let fontColor: UIColor\n    private let isDataDetectionEnabled: Bool\n\n    func makeUIView(context: Context) -&gt; UITextView {\n        let textView = UITextView()\n\n        textView.isSelectable = true\n        textView.isEditable = false\n        textView.isScrollEnabled = false\n\n        textView.backgroundColor = UIColor.clear\n        textView.setContentHuggingPriority(.defaultHigh, for: .vertical)\n        textView.setContentHuggingPriority(.defaultHigh, for: .horizontal)\n        textView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n        textView.setContentCompressionResistancePriority(.required, for: .vertical)\n\n        textView.dataDetectorTypes = isDataDetectionEnabled ? [.link, .phoneNumber] : []\n\n        textView.contentInset = .zero\n        textView.textContainerInset = .zero\n        textView.textContainer.lineFragmentPadding = 0\n\n        return textView\n    }\n\n    func updateUIView(_ uiView: UITextView, context: Context) {\n        uiView.font = font\n        uiView.text = text\n        uiView.textColor = fontColor\n    }\n\n    func sizeThatFits(_ proposal: ProposedViewSize, uiView: UITextView, context: Context) -&gt; CGSize? {\n        guard let width = proposal.width else { return nil }\n\n        let dimensions = text.boundingRect(\n            with: CGSize(width: width, height: CGFloat.greatestFiniteMagnitude),\n            options: [.usesLineFragmentOrigin, .usesFontLeading],\n            attributes: [.font: font],\n            context: nil\n        )\n        return .init(width: width, height: ceil(dimensions.height))\n    }\n}\n</code></pre>\n", "tags": ["swift", "xcode", "swiftui", "uitextview"]}
