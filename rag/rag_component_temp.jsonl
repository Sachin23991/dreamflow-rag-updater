{"id": "dee5c6c1-d862-43e3-a41b-a5e58305b8d7", "text": "Q: What are some simple / practical ways to reduce memory usage in a React Native app? A: <h3>1. Unmount screens you don\u2019t need anymore</h3>\n<p>Screens that stay mounted keep state, listeners, and refs alive.</p>\n<p>In React Navigation, this alone can save noticeable memory:</p>\n<pre><code>options={{ unmountOnBlur: true }}\n</code></pre>\n<p>I usually enable this for detail screens, modals, and forms where restoring state isn\u2019t important.</p>\n<hr />\n<h3>2. Always clean up effects</h3>\n<p>This is probably the most common source of leaks.</p>\n<p>Anything that subscribes to something should unsubscribe:</p>\n<pre><code>useEffect(() =&gt; {\n  const sub = AppState.addEventListener('change', handler)\n\n  return () =&gt; {\n    sub.remove()\n  }\n}, [])\n</code></pre>\n<p>Same rule for:</p>\n<ul>\n<li><p>timers</p>\n</li>\n<li><p>sockets</p>\n</li>\n<li><p>event emitters</p>\n</li>\n<li><p>location / sensors</p>\n</li>\n</ul>\n<p>If it starts something \u2192 it should stop it.</p>\n<hr />\n<h3>3. Don\u2019t use <code>ScrollView</code> for large lists</h3>\n<p>This one hurts memory badly on Android.</p>\n<p>If the list can grow, always use <code>FlatList</code> and keep it simple:</p>\n<pre><code>&lt;FlatList\n  data={data}\n  renderItem={renderItem}\n  keyExtractor={item =&gt; item.id}\n  initialNumToRender={10}\n  removeClippedSubviews\n/&gt;\n</code></pre>\n<p>Also avoid putting heavy logic inside <code>renderItem</code>.</p>\n<hr />\n<h3>4. Be careful what you put in state</h3>\n<p>State lives longer than you think.</p>\n<p>Instead of storing full API responses, store only what the screen needs.</p>\n<p>Bad:</p>\n<pre><code>setUser(response)\n</code></pre>\n<p>Better:</p>\n<pre><code>setUser({ id: response.id, name: response.name })\n</code></pre>\n<p>Large nested objects increase memory and re-render cost.</p>\n<hr />\n<h3>5. Images: small changes, big impact</h3>\n<p>Images are one of the biggest memory consumers.</p>\n<p>A few easy wins:</p>\n<ul>\n<li><p>Don\u2019t load full-resolution images</p>\n</li>\n<li><p>Always give <code>width</code> and <code>height</code></p>\n</li>\n<li><p>Resize images on the backend if possible</p>\n</li>\n</ul>\n<p>If the app is image-heavy, switching to <code>expo-image</code> or <code>FastImage</code> usually helps.</p>\n<hr />\n<h3>6. Avoid unnecessary re-renders in lists</h3>\n<p>Creating new functions on every render adds pressure to the JS heap, especially in lists.</p>\n<p>Instead of:</p>\n<pre><code>onPress={() =&gt; onItemPress(item)}\n</code></pre>\n<p>Use:</p>\n<pre><code>const onItemPress = useCallback(() =&gt; {\n  ...\n}, [])\n</code></pre>\n<p>This isn\u2019t huge by itself, but it adds up.</p>\n<hr />\n<h3>7. Keep global state small</h3>\n<p>Redux / Context sticks around for the whole app lifetime.</p>\n<p>Things I avoid storing globally:</p>\n<ul>\n<li><p>full API responses</p>\n</li>\n<li><p>large arrays</p>\n</li>\n<li><p>temporary UI state</p>\n</li>\n</ul>\n<p>Global state should be <strong>minimal and long-lived</strong>, not a cache.</p>\n<hr />\n<h3>8. Remove things you don\u2019t use</h3>\n<p>Unused libraries still add native memory overhead.</p>\n<p>If a package is used in one place or for one helper function, it\u2019s often not worth it.</p>\n", "tags": ["android", "react-native", "memory", "memory-leaks", "expo"]}
{"id": "0f63cd92-4701-48ed-9109-6fb22af5e42b", "text": "Q: Google Play Games Leaderboard not updating for new Android players (Flutter + Flame) A: <p>I found that the issue was caused by relying on this check in `submitScore()`:</p>\n<p>`if (onlinePlayerScore == null || score &gt; onlinePlayerScore)`</p>\n<p>On Android, for new players, `getPlayerScore()` can return `null` even after sign-in and even after a successful score submission, because the Google Play Games backend has not finished provisioning/indexing the player yet.</p>\n<p>As a result, submitting the score immediately after sign-in could be silently ignored by Play Games Services, with no error returned. Since the app relied on `getPlayerScore()` to decide whether to submit again, the score was never retried and never appeared on the leaderboard.</p>\n<p>After removing this check and always submitting the score, scores from new Android users started appearing correctly. Final version:</p>\n<pre><code>Future&lt;void&gt; submitScore(int score) async {\n  if (!_signedIn) return;\n\n  try {\n    // Always submit improved scores\n    await GamesServices.submitScore(\n      score: Score(\n        iOSLeaderboardID: iosLeaderboardId,\n        androidLeaderboardID: androidLeaderboardId,\n        value: score,\n      ),\n    );\n\n    debugPrint('Score submitted: $score');\n\n  } on Exception catch (e) {\n    debugPrint('Failed to submit score online: $e');\n  }\n}\n</code></pre>\n<p>iOS was unaffected because Game Center provisions players synchronously.</p>\n", "tags": ["android", "flutter", "google-play-games", "leaderboard", "flame"]}
{"id": "206d76a1-4bf6-4ec6-a7e3-0ad6d4ebdca2", "text": "Q: Problems with RabbitMQ and web-stomp A: <p>Solved it, the exchange name needs to be \"amq.topic\"</p>\n", "tags": ["javascript", "rabbitmq", "stomp", "web-stomp"]}
{"id": "c2e2d77e-a3eb-4e32-922b-766c9ec3d3d0", "text": "Q: Prevent flex items from overflowing a container A: <p>For the complex hierarchy of the flex boxes, instead of trying to specify <code>min-width: 0</code> or <code>flex-basis: 0</code> etc. for each parent to force all of them to shrink (that might not always be a desired behaviour if having a complex UI with React or VUE framework), use the grid layout. Grid forces itself to shrink to the specified &quot;outer&quot; available width without trying to expand. Just make sure all cells that might grow too much have min-width specified.</p>\n", "tags": ["css", "flexbox"]}
{"id": "95203e18-8c3a-4c53-82c9-4ee880a8df75", "text": "Q: Laravel not sending email and not giving errors A: <p>In my case, the issue was caused by missing or incorrectly configured <strong>SPF</strong>, <strong>DKIM</strong>, and <strong>DMARC</strong> records on my Bluehost hosting account.</p>\n<p>I had to contact their support team to correct the DNS records, and after that, email sending from my Laravel application worked as expected.</p>\n<ul>\n<li><strong>SPF</strong> lists allowed senders</li>\n<li><strong>DKIM</strong> adds a digital signature</li>\n<li><strong>DMARC</strong> tells receivers what to do with failing emails.</li>\n</ul>\n<p>SPF, DKIM, and DMARC are\u00a0essential email authentication standards (DNS records) that verify legitimate emails from your domain, preventing spoofing and improving deliverability in Gmail and elsewhere.</p>\n<p>Major email providers like\u00a0Google,\u00a0Yahoo, and\u00a0Microsoft (Outlook/Hotmail)\u00a0are very strict and now require SPF, DKIM, and DMARC for bulk senders to combat spam, making these authentication protocols essential for good deliverability.</p>\n<p>You can check your email score from here: <a href=\"https://www.mail-tester.com/\" rel=\"nofollow noreferrer\">https://www.mail-tester.com/</a></p>\n<ul>\n<li>Mail-tester is a free online tool that analyzes your emails to check their spam score and deliverability.</li>\n<li>It gives your email a score (out of 10) and a detailed report on why your message might land in spam or the inbox.</li>\n<li>You send a test email to a unique address it provides, and it checks your server, IP, authentication (SPF, DKIM, DMARC), content, links, and blacklists to help you optimize your emails before sending them to real customers.</li>\n</ul>\n", "tags": ["php", "laravel", "laravel-4"]}
