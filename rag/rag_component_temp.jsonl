{"id": "79f5ed76-7043-43a4-ac1c-e8996fa4ed81", "text": "Q: ArgoCD Manifest generation error (cached): the URL scheme &#39;secrets&#39; is not allowed error A: <p>This is intentional as there was a CVE specific to this (cant remember specific CVE or which release mitigated it). If you are trying to use a helm custom scheme, you can allow a different scheme by modifying the <code>argocd-cm</code> configmap</p>\n<p><a href=\"https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml#L230\" rel=\"nofollow noreferrer\">https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml#L230</a></p>\n", "tags": ["kubernetes", "kubernetes-helm", "argocd"]}
{"id": "84502870-9d02-4108-a9b0-f14d65a8f35f", "text": "Q: LeafletJS &amp; Protomaps: Read a PMTiles file generated with tippecanoe latest (v2.11.0) A: <p>try define paint_rules inside the function, and try to use simple simbolizer using <code>new protomapsL.PolygonSymbolizer</code> based on your data, I think it's not about tippecanoe, my version <code>tippecanoe v2.80.0</code> more latest installing on linux working well</p>\n", "tags": ["leaflet", "tippecanoe"]}
{"id": "020572ff-5fb4-487d-973d-de675329d9d8", "text": "Q: How to turn off SSL from the Windows client library mariadb connector-c 3.4.8 win64 A: <p>Beside the previous answer, you can also set environment variable MARIADB_TLS_DISABLE_PEER_VERIFICATION:</p>\n<pre><code>set MARIADB_TLS_DISABLE_PEER_VERIFICATION=1\n</code></pre>\n<p>If you prefer to change the c code, you need to set only MYSQL_OPT_SSL_VERIFY_SERVER_CERT to off (but use one byte variable, not 4 byte int):</p>\n<pre><code>uint8_t verify = 0;\nrc= mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, &amp;verify);\n</code></pre>\n", "tags": ["mariadb", "mariadb-connector-c"]}
{"id": "2688be73-17fc-4b0f-a1c1-7200f96c8ff8", "text": "Q: How do I call javascript code on RangeValidator error in ASP.NET C#? A: <p>It's possible to update &quot;<code>MaximumValue&quot; via </code>JavaScript.</p>\n<p>To change the validator's maximum value in JavaScript, set the &quot;<code>MaximumValue&quot;</code> property directly:</p>\n<pre><code>var rvalid = document.getElementById('&lt;%= RangeValidator1.ClientID %&gt;');\nrvalid.maximumvalue = 10;\n</code></pre>\n<p>or</p>\n<p>in server property of validator, set ClientIDMode=&quot;Static&quot; and via javascript:</p>\n<pre><code>var rvalid = document.getElementById('RangeValidatorID');\nrvalid.maximumvalue = 10;\n</code></pre>\n", "tags": ["javascript", "c#", "asp.net"]}
{"id": "8d28cc16-465f-48f4-8059-80f63edb842c", "text": "Q: Pure Type Punning In C A: <p>There is no undefined behavior in the code shown if we read the C standard literally.</p>\n<p>We consider each of the types used to access the mapped memory: character types, <code>int</code>, and <code>short</code>.</p>\n<p>The accesses with character types do not violate the aliasing rules of the C standard since they universally permit accessing any object with a character type.</p>\n<p>In <code>memcpy(page, &amp;char_size, 4);</code>, the four bytes at <code>page</code> are given effective type <code>int</code>. This is because the data is copied from an <code>char_size</code>, and <code>char_size</code> is declared as an <code>int</code>, and C 2024 6.5 says:</p>\n<blockquote>\n<p>If a value is copied into an object having no declared type using <code>memcpy</code> or <code>memmove</code>\u2026, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one.</p>\n</blockquote>\n<p>Once that memory has been given effective type <code>int</code>, it is not accessed with any type other than <code>int</code> or a character type, both of which are permitted by the aliasing rules.</p>\n<p>In <code>short data = *(short*)(page+6);</code>, the two bytes at <code>page+6</code> are accessed as a <code>short</code>. If this memory had an effective type other than <code>short</code> or <code>unsigned short</code>, the behavior would be undefined. However, this memory has no effective type. It was previously written using <code>memcpy(page+4, literal, 5);</code>. As we saw above, if this copied data from memory with effective type, then it would give the bytes at <code>page+4</code> that type. The source bytes are those of the string literal <code>&quot;hello&quot;</code>.</p>\n<p>We know from C 2024 6.4.6 that the string literal induces an array of <code>char</code>:</p>\n<blockquote>\n<p>The multibyte character sequence is then used to initialize an array of static storage duration and length just sufficient to contain the sequence. For character string literals, the array elements have type <code>char</code>,\u2026</p>\n</blockquote>\n<p>However, while this type is specified in the C standard, <strong>it is not declared in the program.</strong> There is no declaration of the type of this memory. Therefore, it does not trigger this sentence in 6.5:</p>\n<blockquote>\n<p>The <em>effective type</em> of an object for an access to its stored value is the declared type of the object, if any.</p>\n</blockquote>\n<p>This leaves the memory of a string literal with no effective type.</p>\n", "tags": ["c", "pointers", "gcc"]}
