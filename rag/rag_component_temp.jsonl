{"id": "c95598af-ad0e-4575-baff-bb8111f94e36", "text": "Q: Why does Milvus return a generic RPC error when json_contains_all uses mixed types in an ARRAY? A: <p>Make sure all elements in your query literal match the <code>element_type</code> exactly:</p>\n<p>Incorrect:</p>\n<pre class=\"lang-py prettyprint-override\"><code># '2' is interpreted as an integer literal\nexpr = &quot;json_contains_all(float_array, [2, 4.0])&quot;\n</code></pre>\n<p>Correct:</p>\n<pre class=\"lang-py prettyprint-override\"><code># Both are explicitly floats\nexpr = &quot;json_contains_all(float_array, [2.0, 4.0])&quot;\n</code></pre>\n<p>If you are generating these queries programmatically, make sure you cast your variables to <code>float</code> before interpolating them into the filter string.</p>\n", "tags": ["python", "json", "database", "vector-database", "milvus"]}
{"id": "a49b51a1-2663-450d-ab8a-dbebe261c0e4", "text": "Q: How can you return different types from a function template depending on a condition? A: <p>Types in C++ are determined at <em>compile time</em>. That means that a runtime condition cannot be used to infer the type of an object.</p>\n<p>Seeing how you tried to use templates suggest to me that there's a little misunderstanding here. Template code is instantiated by the compiler. Code in templates is not really code until instantiated. If we were to do, by hand, the instantiation of you code using the type <code>A</code>, it would look close to something like this <strong>(not actual code)</strong>:</p>\n<pre><code>template &lt;&gt;\nauto getObject&lt;A&gt;() -&gt; C&lt;A&gt; {\n    if(/* something at runtime */) {\n        return C&lt;A&gt;{};\n    } else {\n        return C&lt;B&gt;{};\n    }\n}\n\n// auto\nC&lt;A&gt; obj = getObject&lt;A&gt;();\n</code></pre>\n<p>As you can see, the code in the else doesn't make sense. You cannot return a value of type <code>C&lt;B&gt;</code> inside a function that must return <code>C&lt;A&gt;</code>. As a side effect of compile time instantiation of code, <code>C&lt;A&gt;</code> and <code>C&lt;B&gt;</code> are unrelated and are completely different types.</p>\n<p>Also, you can see that <code>auto</code> has been replaced by <code>C&lt;A&gt;</code>. This is because <code>auto</code> is also inferred at compile time.</p>\n<hr />\n<p>Now... What can you do to make your code work?</p>\n<p>There are multiple solution and abstraction to have a variable that has a runtime defined type. I'll cover some of the options you can use.</p>\n<h2>Using a variant</h2>\n<p>A variant is a class that can hold a single instance of a variable that can be of different types, specified in a finite list of types. For instance, a <code>std::variant&lt;int, std::string&gt;</code> is a variable that can either be a integer or a string.</p>\n<p>In your code, it would be a variant of <code>C&lt;A&gt;</code> and <code>C&lt;B&gt;</code>:</p>\n<pre><code>auto getObject() -&gt; std::variant&lt;C&lt;A&gt;, C&lt;B&gt;&gt; {\n    if (/* something at runtime */) {\n        return C&lt;A&gt;{};\n    } else {\n        return C&lt;B&gt;{};\n    }\n}\n\nauto obj = getObject();\n\n// The type of obj is std::variant&lt;C&lt;A&gt;, C&lt;B&gt;&gt;\n</code></pre>\n<p>If you don't have access to C++17, you can always use <code>boost::variant</code>.</p>\n<p>The downside of this solutions is that you have to know every types the variant can take. If you have a indefinite amount of types, you cannot use variant. It is however, extremely fast and promote regularity ( value semantics ).</p>\n<h2>virtual polymorphism</h2>\n<p>Virtual polymorphism is the most common way to get variables of different types decided at runtime. It looks nice but comes with the price of pointer and dynamic allocation, and is rather intrusive. It would look like this:</p>\n<pre><code>struct CC {\n    virtual ~CC() = default;\n};\n\ntemplate&lt;typename T&gt;\nstruct C : CC {\n    T barcode;\n};\n\nauto getObject() -&gt; std::unique_ptr&lt;CC&gt; {\n    if (/* something at runtime */) {\n        return std::make_unique&lt;C&lt;A&gt;&gt;();\n    } else {\n        return std::make_unique&lt;C&lt;B&gt;&gt;();\n    }\n}\n\nauto obj = getObject();\n\n// The type of obj is std::unique_ptr&lt;CC&gt;\n</code></pre>\n<p>Note that if this is what you want to do, you have to define some common interface in <code>CC</code>. The rest of the code will use that common interface in order to do operations on <code>C</code> and it's barcode.</p>\n<p>Please note that <code>std::make_unique</code> is part of C++14. It can be replaced by <code>std::unique_ptr&lt;C&lt;A&gt;&gt;{new C&lt;A&gt;}</code> and <code>std::unique_ptr&lt;C&lt;B&gt;&gt;{new C&lt;B&gt;}</code> respectively.</p>\n<hr />\n<p>There is also <code>std::any</code> and other form of type erasure technique available. This answer is already quite long. There is plenty of documentation you can find online for free that describes all of this in depth.</p>\n", "tags": ["c++", "c++11", "templates", "polymorphism", "function-templates"]}
{"id": "880c1f53-8229-40a9-a58f-6908be1e0682", "text": "Q: Node.js backend not auto-starting on IIS localhost (React frontend works) A: <p>The solution since 2015 is to use <a href=\"https://docs.lextudio.com/blog/running-nodejs-web-apps-on-iis-with-httpplatformhandler/\" rel=\"nofollow noreferrer\">HttpPlatformHandler on IIS</a>.</p>\n", "tags": ["javascript", "reactjs", "node.js", "iis", "pm2"]}
{"id": "49501c81-1455-49fc-9c6b-842171ab8dac", "text": "Q: expand_template with make variables A: <p>The bazel-skylib implementation of this rule does not support replacing vars in the substitutions, in the same way it doesn't support expanding locations etc (at the time of writing this). It's a very light wrapper around <a href=\"https://bazel.build/rules/lib/actions#expand_template\" rel=\"nofollow noreferrer\"><code>ctx.actions.expand_template</code></a>.</p>\n<p>However, the <a href=\"https://github.com/aspect-build/bazel-lib\" rel=\"nofollow noreferrer\">aspect-build/bazel-lib</a> implementation of <code>expand_template</code> does support these substitutions. See <a href=\"https://registry.bazel.build/docs/bazel_lib#function-expand_template\" rel=\"nofollow noreferrer\">the docs</a> for further info.</p>\n", "tags": ["bazel"]}
{"id": "99eb2363-e5aa-4dc4-8931-ebbd53ee4799", "text": "Q: MongoSocketOpenException on startup with new project A: <p>The problem is clear from the logs. Look at the <code>clusterSettings</code></p>\n<pre><code>clusterSettings={hosts=[localhost:27017], srvServiceName=mongodb, mode=SINGLE, ...}\n</code></pre>\n<p>Your <code>mongodb+srv://</code> URI is being completely ignored. It's falling back to the default <code>localhost:27017</code>.</p>\n<p>You may check if your <em><strong>application.properties</strong></em> is on the right path <code>src/main/resources/</code></p>\n<p>You can also check the path if you have <em><strong>application.yml</strong></em></p>\n<pre class=\"lang-yaml prettyprint-override\"><code>spring:\n     data:\n       mongodb:\n         uri: mongodb+srv://MYUSERNAME:MYPW@MYPROJECTclu.zgsjafi.mongodb.net/?appName=MYCLUSTER\n</code></pre>\n<p>or check if you have a <code>@Bean</code> for <code>MongoClient</code> or <code>MongoClientSettings</code> somewhere that ignores the property.</p>\n", "tags": ["mongodb", "spring-boot"]}
{"id": "516afe5c-2d78-401b-8eaa-f6b2b5344281", "text": "Q: Coturn and Kurento in Docker Compose configuration A: <p>Here's my suggestion:</p>\n<ol>\n<li><p>IP vs domain \u2014 <strong>Realm = domain, everything else = public IP</strong></p>\n</li>\n<li><p>TURN authentication \u2014 <strong>Use HMAC (--use-auth-secret), remove static users</strong></p>\n</li>\n<li><p>network_mode: host \u2014 <strong>Required for coturn on a VPS</strong></p>\n</li>\n<li><p>UDP port range \u2014 <strong>49152\u201365535</strong></p>\n</li>\n<li><p>TCP vs UDP in KMS_TURN_URL \u2014 <strong>Use UDP primarily, TCP fallback only</strong></p>\n</li>\n<li><p>KMS_EXTERNAL_IPV4 \u2014 <strong>Must be the VPS public IP</strong></p>\n</li>\n<li><p>Kurento client connection \u2014 <strong>ws://kurento:8888/kurento inside Docker</strong></p>\n</li>\n<li><p>Future Nginx proxy \u2014 <strong>No, keep KMS internal, proxy only Spring Boot</strong></p>\n</li>\n</ol>\n", "tags": ["spring-boot", "docker-compose", "kurento", "coturn"]}
