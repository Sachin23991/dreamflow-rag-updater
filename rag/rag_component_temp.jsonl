{"id": "300e75f4-c27c-4d74-b889-87667d40bb8e", "text": "Q: Dyalog APL: What are the miracles? Trouble with + and range A: <p>There are no miracles, only \u043a\u043e\u0448\u043c\u0430\u0440.  Like they say on the Metro, \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e, \u0443\u0436\u0430\u0441 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u0442\u0441\u044f  But I digress.</p>\n<p>Suppose we try your example, but only use <code>+/</code> instead of <code>-/</code>.</p>\n<pre><code>      +/ 692.4 88 6.45 39.08 20 53\n</code></pre>\n<p>We get the answer <code>898.93</code>.  No matter how we regroup the expression, we get the same answer.</p>\n<pre><code>      692.4 + 88 + 6.45 + 39.08 + 20 + 53\n</code></pre>\n<p>or</p>\n<pre class=\"lang-none prettyprint-override\"><code>      692.4 + 88 + (6.45 + 39.08) + 20 + 53\n</code></pre>\n<p>or</p>\n<pre class=\"lang-none prettyprint-override\"><code>      692.4 + (88 + (6.45 + (39.08 + (20 + 53))\n</code></pre>\n<p>As a practical matter, you can replace <code>+/</code> (and <code>x/</code>) with a simple running sum or product function and get the same answer.  But for <code>-/</code>, you would loop through the numbers backwards.</p>\n<pre class=\"lang-none prettyprint-override\"><code>      692.4 - (88 - (6.45 - (39.08 - (20 - 53))\n</code></pre>\n<p>Another thing to think about, the <code>scan</code> operator will show you the intermediate result of reduction.</p>\n<p><code>      -\\ 692.4 88 6.45 39.08 20 53</code></p>\n<p>Returning</p>\n<p><code>692.4 604.4 610.85 571.77 591.77 538.77</code></p>\n<p>The last element would be the result of the reduction.</p>\n<p>Last and certainly least, while it is not a problem for this example, floating point operations are not necessarily associative, simply put, if you add up a series of floating point numbers, the result would not necessarily be <strong>exactly</strong> equal to adding up the same numbers rearranged (e.g. sorted)</p>\n", "tags": ["apl", "dyalog"]}
{"id": "5c26fb89-a8a6-4ba2-977b-1a6f233a6260", "text": "Q: Rider keeps rebuilding the game every time I maximize the window or switch back to it A: <p>There is &quot;Build Automatically&quot; setting on the Godot tab in the Rider settings.</p>\n", "tags": ["ide", "jetbrains-ide", "godot", "rider"]}
{"id": "cb020ce8-7e69-48b3-9619-ea1d08345759", "text": "Q: Conflict on generic TryFrom impl but not on generic From impl A: <p>It doesn't work for <code>TryFrom</code> because there is already a blanket <a href=\"https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html#impl-TryFrom%3CU%3E-for-T\" rel=\"nofollow noreferrer\"><code>impl TryFrom&lt;U: Into&lt;T&gt;&gt; for T</code></a>, so your <code>impl TryFrom&lt;U: Into&lt;u8&gt;&gt; for MyType</code> conflicts with a potential future <code>impl Into&lt;MyType&gt; for u8</code>.</p>\n<p>It works for <code>From</code> because there is no <code>impl From&lt;U: Into&lt;T&gt;&gt; for T</code> (<a href=\"https://doc.rust-lang.org/stable/std/convert/trait.Into.html#impl-Into%3CU%3E-for-T\" rel=\"nofollow noreferrer\">the blanket implementation is the other way around</a>).</p>\n", "tags": ["generics", "rust"]}
{"id": "8ebb1550-913f-4f7e-9bc7-b41e95c8e581", "text": "Q: Can complex UPDATE statements leverage columnstore indexes in PolarDB? A: <p>Absolutely - convert UPDATE to INSERT ... ON DUPLICATE KEY UPDATE. This let us leverage columnstore indexes through the ETL path for the SELECT portion:</p>\n<pre><code>INSERT INTO sales_transactions (id, performance_category)\nSELECT t.id, 'high_value'\nFROM sales_transactions t\nJOIN (\nSELECT product_id, SUM(amount) as total_sales\nFROM sales_analytics\nWHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31'\nGROUP BY product_id\n) a ON t.product_id = a.product_id\nWHERE t.last_review_date \\&lt; '2023-01-01'\nON DUPLICATE KEY UPDATE performance_category = VALUES(performance_category);\n</code></pre>\n<p>Just make sure table has a PRIMARY KEY (like id here).</p>\n", "tags": ["polardb"]}
