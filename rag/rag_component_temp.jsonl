{"id": "e62845fb-a5ac-4384-8df1-d8eff7f6335e", "text": "Q: Adjust vertical line based on maximum value in graph plotly A: <blockquote>\n<p>Now I want to have the vertical be the maximum height of the max bar shown in the plot</p>\n</blockquote>\n<p>You can add a vertical line <code>vline</code> that scales to the plot's y-range automatically like shown <a href=\"https://plotly.com/r/horizontal-vertical-shapes/\" rel=\"nofollow noreferrer\">here</a></p>\n<pre><code>library(plotly)\nlibrary(purrr)\n\nset.seed(7)\ndf &lt;- data.frame(\n  group = rep(LETTERS[1:4], each = 4),\n  subgroup = letters[1:16],\n  value = sample.int(16)\n)\n\ndf_mtcars &lt;- mtcars |&gt;\n  transform(gear = as.factor(gear),\n         carb = as.factor(carb))\n\np &lt;- plotly::plot_ly()\n\npurrr::walk(unique(mtcars$carb), function(carb) {\n  p &lt;&lt;- p |&gt;\n    add_trace(data = df_mtcars[df_mtcars$carb == carb,],\n              x = ~gear, \n              y = ~mpg, \n              color = ~carb, type = &quot;bar&quot;,\n              visible = if (carb == 3) {TRUE} else {&quot;legendonly&quot;}) \n})\n\n\np |&gt;\n  layout(shapes = list(\n    list(\n      type = &quot;line&quot;,\n      y0 = 0,\n      y1 = 0.95, # will always scale to the max because 95% of the \n                 # y-scale is always the max value\n      yref = &quot;paper&quot;,\n      x0 = 0,\n      x1 = 0,\n      line = list(color = &quot;red&quot;, dash = &quot;dot&quot;)\n    )\n  ))\n</code></pre>\n<p><a href=\"https://i.sstatic.net/l2sfRO9F.gif\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/l2sfRO9F.gif\" alt=\"res\" /></a></p>\n", "tags": ["r", "plotly"]}
{"id": "5ab8483e-c0a1-4392-8a86-0eca846451bc", "text": "Q: Why does deduction guide detect template arguments as an empty set? A: <p>Based on the cppinsights answer, a possible workaround would be to remove type deduction in the constructor itself, <a href=\"https://godbolt.org/z/Ksarv1Knd\" rel=\"nofollow noreferrer\">https://godbolt.org/z/Ksarv1Knd</a></p>\n<pre><code>#include &lt;tuple&gt;\n\ntemplate &lt;typename... T&gt;\nclass Test {\n   public:\n    Test(T&amp;&amp;... args) : tuple_{std::move(args)...} {}\n    Test(T const&amp;... args) : tuple_{args...} {}\n\n   private:\n    std::tuple&lt;T...&gt; tuple_;\n};\n\ntemplate &lt;typename... Ts&gt;\nTest(Ts...) -&gt; Test&lt;Ts...&gt;;\n\nint main() { Test t{1, 2}; }\n</code></pre>\n<p>Although I am now not entirelly sure if you need the const and non-const version, or if it makes any difference.</p>\n<p>UPDATE: <a href=\"https://godbolt.org/z/36qzT6sfz\" rel=\"nofollow noreferrer\">https://godbolt.org/z/36qzT6sfz</a></p>\n", "tags": ["c++", "c++23"]}
{"id": "bc52f73b-e758-44ad-a2e7-5730404a95db", "text": "Q: How to copy an array in Bash? A: <p>Isaac's solution (with <code>declare -p</code>) is quite good, but it has an unnecessary subshell. We can use an obscure bash feature to avoid that:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>declare -A arr=([this]=hello [\\'that\\']=world [theother]='and &quot;goodbye&quot;!')\ntemp=&quot;${arr[@]@A}&quot;\neval &quot;${temp/arr=/newarr=}&quot;\n</code></pre>\n<p>If one wanted to avoid <code>eval</code>, it's also possible to do it like this:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>declare -A arr=([this]=hello [\\'that\\']=world [theother]='and &quot;goodbye&quot;!')\ntemp=&quot;${arr[@]@A}&quot;\ndeclare -A newarr=&quot;${temp#*=}&quot;\n</code></pre>\n<p>This has the advantage of making it easier to add more flags to the <code>declare</code>, such as <code>-g</code>.</p>\n<p>If you do not want to hardcode the fact that the array is associative, you can do the following:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>declare -A arr=([this]=hello [\\'that\\']=world [theother]='and &quot;goodbye&quot;!')\ntemp=&quot;${arr[@]@A}&quot;\ndeclare -${arr@a} newarr=&quot;${temp#*=}&quot;\n</code></pre>\n<p>Do note that using <code>declare</code> will create a new variable, possibly shadowing an existing variable in an outer scope. If your variable already exists and has the right type, you need to use the <code>eval</code> variant above. You might be squeamish about using <code>eval</code>, but in my testing it works even for strings containing <code>&quot;</code>, and the documentation does seem to confirm that this generates syntax that's valid for both <code>declare</code> and assignments:</p>\n<blockquote>\n<p>The expansion is a string in the form of an assignment statement or declare command that, if evaluated, recreates parameter with its attributes and value.</p>\n<p>\u2014 Bash Reference Manual, section 3.5.3 Shell Parameter Expansion</p>\n</blockquote>\n", "tags": ["arrays", "bash", "copy"]}
{"id": "9339b99b-8a18-4f93-8e9a-ceb633943f31", "text": "Q: Karate Framework # Unable to read the data from JSON while using JSON Array Data Source using read() and karate.setup() A: <p>You can extract specific fields using the dot notation to access specific fields for the given @setup iteration.</p>\n<pre><code>    * print payloadHeader.document\n    * print payloadHeader.document.id\n    * print payloadHeader.document.name\n</code></pre>\n<p>For clarity if input_json_file.json contains the following</p>\n<pre><code>[\n  {\n    &quot;payloadHeader&quot;: {\n      &quot;document&quot;: {\n        &quot;id&quot;: &quot;id-0&quot;,\n        &quot;name&quot;: &quot;name-0&quot;\n      }\n    }\n  },\n  {\n    &quot;payloadHeader&quot;: {\n      &quot;document&quot;: {\n        &quot;id&quot;: &quot;id-1&quot;,\n        &quot;name&quot;: &quot;name-1&quot;\n      }\n    }\n  }\n]\n</code></pre>\n<p>then</p>\n<pre><code>* print payloadHeader.document\n</code></pre>\n<p>would print the following on the first iteration</p>\n<pre><code>{\n  &quot;id&quot;: &quot;id-0&quot;,\n  &quot;name&quot;: &quot;name-0&quot;\n}\n</code></pre>\n<p>and</p>\n<pre><code>* print payloadHeader.document.id\n* print payloadHeader.document.name\n</code></pre>\n<p>would print the following on the first iteration respectively</p>\n<pre><code>&quot;id-0&quot;\n&quot;name-0&quot;\n</code></pre>\n<p>and then on the second iteration it would print the next element in the array</p>\n<pre><code>* print payloadHeader.document\n\n</code></pre>\n<p>would print the following on the second iteration</p>\n<pre><code>{\n  &quot;id&quot;: &quot;id-1&quot;,\n  &quot;name&quot;: &quot;name-2&quot;\n}\n</code></pre>\n<p>With this, you should be able to filter and structure the specific values from the dynamic setup as needed in your scenarios.</p>\n", "tags": ["json", "rest", "automated-tests", "karate"]}
{"id": "4f55f2e4-1788-4d52-8074-5b1f4d6fbc9b", "text": "Q: LightningChart Python: GaugeChart legend is empty \u2014 how do I add a legend entry? A: <p>You have to add legend entries manually:</p>\n<pre><code>import lightningchart as lc\nchart = lc.GaugeChart(theme=lc.Themes.Dark, title=&quot;Gauge Chart&quot;)\nchart.set_interval(0, 100)\nchart.set_value(64.78)\n# Manually add a legend entry\nlegend_item = chart.legend.add_item(&quot;Temperature Sensor&quot;)\nlegend_item.set_icon_color(lc.Color.rgb(255, 0, 0))\nlegend_item.set_icon_shape(lc.LegendIconShape.CIRCLE)\nchart.legend.set_options(visible=True, position=&quot;TopRight&quot;, title=&quot;Legend&quot;)\nchart.open()\n</code></pre>\n<p>The difference from ChartXY: there's no &quot;series&quot; on a gauge, so there's nothing to auto-register with the legend. You're just displaying one value on a dial.</p>\n", "tags": ["python", "lightningchart", "lightningchart-python"]}
