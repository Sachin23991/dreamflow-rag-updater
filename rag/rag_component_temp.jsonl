{"id": "fe7d3ac1-74d4-4799-b89b-00dddf25ad47", "text": "Q: Access data frame from binary file A: <p>You're indexing the file handle, not the DataFrame. A pickle stores a single object, so you need to load it first, then slice it.</p>\n<p>the simplest approach is <code>to_pickle</code> / <code>read_pickle</code></p>\n<pre class=\"lang-py prettyprint-override\"><code># saving\ndf.to_pickle(saved_path)\n</code></pre>\n<pre><code>df = pd.read_pickle(bin_path)\n\nx = df[col_names[:-1]]\ny = df[col_names[-1]]\n</code></pre>\n", "tags": ["python", "pandas", "dataframe", "machine-learning", "data-preprocessing"]}
{"id": "18dc756d-0697-4e5f-8c46-918cd0959f9d", "text": "Q: TypeScript + Node + Nodemon: Cannot find module when importing TS file using ts-node A: <p>In ESM mode, Node expects import specifiers to end with .js, but you\u2019re trying to run .ts files directly using ts-node + nodemon (especially painful on Windows\ud83d\ude24).</p>\n<p>Do this:</p>\n<pre><code>package.json\n{\n &quot;type&quot;: &quot;module&quot;,\nscripts:{\n    &quot;dev&quot;: &quot;nodemon --watch src --ext ts,js --exec \\&quot;node --loader ts-node/esm ./src/server.ts\\&quot;&quot;\n}\n}\n</code></pre>\n<p>run:</p>\n<pre><code>npm run dev\n</code></pre>\n<p>Note:\nIf you don\u2019t want to deal with Node ESM + ts-node at all, tools like pnpm + tsx can run TypeScript directly with much less configuration.</p>\n", "tags": ["node.js", "typescript", "nodemon"]}
{"id": "ff9366ce-90ba-4e81-bcbd-603a6a0385c4", "text": "Q: CSS nesting has not been configured correctly error after upgrade TailwindCSS version 1 to 3 A: <p>Why not follow the guide, the error point to?</p>\n<p>Import the nesting plugin in <code>postcss.config.js</code>, not in <code>tailwind.config.js</code>.</p>\n<p><a href=\"https://v3.tailwindcss.com/docs/using-with-preprocessors#nesting\" rel=\"nofollow noreferrer\">https://v3.tailwindcss.com/docs/using-with-preprocessors#nesting</a></p>\n", "tags": ["vuejs3", "tailwind-css", "postcss", "tailwind-css-3", "postcss-loader"]}
{"id": "6a406240-9e50-4da8-9ad4-5605b702e041", "text": "Q: What is the idiomatic way to organize shared helper functions in Go projects? A: <pre><code>In Go, the idiomatic way to organize shared helper functions centers on domain/function-based grouping rather than generic \u00a0helpers/\u00a0/\u00a0utils/\u00a0 directories. Here\u2019s the concise breakdown:\n \n1. Generic directories are anti-patterns\n \n\u00a0helpers/\u00a0/\u00a0utils/\u00a0 become unstructured &quot;dumpsters&quot; for unrelated code, violating Go\u2019s &quot;packages as functional units&quot; philosophy. Exceptions only apply to tiny, highly generic utilities (still split by domain in files).\n \n2. Group by domain/purpose\n \n- Logging \u2192 \u00a0log/\u00a0 package\n- Filesystem helpers \u2192 \u00a0fs/\u00a0 package\n- String/parsing utils \u2192 \u00a0strutil/\u00a0/\u00a0parser/\u00a0 packages (split by specific use case)\n \n3. Core project structure\n \nplaintext\n  \nproject/\n\u251c\u2500\u2500 internal/       # Private project helpers\n\u2502   \u251c\u2500\u2500 log/        # Logging tools\n\u2502   \u251c\u2500\u2500 fs/         # Filesystem tools\n\u2502   \u2514\u2500\u2500 strutil/    # String tools\n\u2514\u2500\u2500 pkg/            # Publicly sharable tools (if needed)\n\u00a0\n \n4. Key rules\n \n- One responsibility per package\n- Use \u00a0internal/\u00a0 for private code (enforced by Go)\n- \u00a0pkg/\u00a0 only for external reuse\n \nWould you like a minimal implementation of a Go \u00a0log\u00a0 package to demonstrate this structure?\n</code></pre>\n", "tags": ["go"]}
{"id": "34f3c1a7-311e-4a5e-a49c-3a025d473634", "text": "Q: How do I get groovysh to not print nulls? A: <p>The issue you're facing is that <code>collect</code> method returns a list of the results of each iteration, and since <code>println</code> returns <code>null</code>, you're getting a list of nulls printed at the end. In groovysh, the result of the last expression is printed automatically. To avoid printing the list of nulls, you can use <code>each</code> instead of <code>collect</code>, because <code>each</code> returns the original collection (the list of methods) and not the results of the closure. Alternatively, you can use <code>collect</code> without printing the result, but since you want to print each method, you can do:</p>\n<p>text</p>\n<pre><code>a.getClass().methods.each { println it }\n</code></pre>\n<p>This will print each method and then return the list of methods, but groovysh will print the return value (the list) which you might not want. To avoid printing anything else, you can also run a script that doesn't return anything. In groovysh, you can use <code>:e</code> to execute a script file, or you can just run the command and ignore the output of the list. However, note that groovysh always prints the result of the last expression.</p>\n<p>Another way is to use <code>inspect</code> or just print without returning. Since <code>each</code> returns the original collection, it will be printed. To avoid that, you can do:</p>\n<p>text</p>\n<pre><code>a.getClass().methods.each { println it }; null\n</code></pre>\n<p>By adding <code>; null</code> at the end, the last expression becomes <code>null</code> and groovysh will print <code>null</code> instead of the list. But if you don't want to print anything at the end, you can run in a way that the last expression is not a collection. Alternatively, you can use the <code>:clear</code> command to clear the buffer and then run the code in a way that doesn't return the list.</p>\n<p>However, note that the original code you posted is in groovysh and it's printing the list of nulls because <code>collect</code> returns a list. So changing to <code>each</code> and then adding a null at the end is a common trick.</p>\n<p>Let me summarize:</p>\n<p>If you run:</p>\n<p>text</p>\n<pre><code>a.getClass().methods.collect { println it }\n</code></pre>\n<p>It prints each method and then prints the list of nulls (because <code>println</code> returns null).</p>\n<p>If you run:</p>\n<p>text</p>\n<pre><code>a.getClass().methods.each { println it }\n</code></pre>\n<p>It prints each method and then prints the list of methods (which is long and not useful).</p>\n<p>If you run:</p>\n<p>text</p>\n<pre><code>a.getClass().methods.each { println it }; null\n</code></pre>\n<p>It prints each method and then prints <code>null</code> (which is less annoying than a long list).</p>\n<p>But if you don't want to print anything after the methods, you can try to run the code in a different way, such as using a script. Alternatively, you can use the <code>:</code> commands in groovysh to run the code without printing the result. However, the interactive shell by design prints the result of the last expression.</p>\n<p>So the best solution is to use <code>each</code> and then set the last expression to something you don't mind printing (like <code>null</code>). Alternatively, you can use a variable to capture the list and then not print it, but groovysh will still print the result of the last expression.</p>\n<p>Another idea is to use a for-loop, which doesn't return anything:</p>\n<p>text</p>\n<pre><code>for (method in a.getClass().methods) { println method }\n</code></pre>\n<p>This will print each method and then the last expression is the for-loop, which returns <code>null</code>. So it will print <code>null</code> at the end. But if you don't want the <code>null</code>, you can wrap the code in a method and call it, but that's more complicated.</p>\n<p>In summary, the simplest way to avoid printing the list of nulls is to use <code>each</code> and then add <code>; null</code> to make the last expression <code>null</code>. But note that you'll still see a <code>null</code> printed.</p>\n<p>Alternatively, if you are using a recent version of groovysh, you can use the <code>:silent</code> command to suppress the output of the last expression, but that might not be available.</p>\n<p>Let me check the groovysh documentation: you can use <code>:set show-last-result false</code> to turn off printing the last result. Then you can run:</p>\n<p>text</p>\n<pre><code>:set show-last-result false\na.getClass().methods.each { println it }\n</code></pre>\n<p>This will only print the methods and not the return value of <code>each</code>. Then you can turn it back on with <code>:set show-last-result true</code> if you want.</p>\n<p>So the steps are:</p>\n<ol>\n<li><p>Run <code>:set show-last-result false</code> in groovysh.</p>\n</li>\n<li><p>Run your code: <code>a.getClass().methods.each { println it }</code></p>\n</li>\n<li><p>If you want to see results again, run <code>:set show-last-result true</code></p>\n</li>\n</ol>\n<p>This is the cleanest solution if you are in an interactive session and want to avoid printing the return value.</p>\n<p>I hope this helps!</p>\n", "tags": ["groovyshell", "groovysh"]}
{"id": "86bc4438-0861-450a-a56a-745db4ee367a", "text": "Q: Unable to inspect Android device via Chrome://inspect A: <p>For MacOS. What was happening to me when Chrome showed: Pending authentication: please accept debugging session on the device.</p>\n<p>no, prompt was given on device.</p>\n<p>In short: terminal -&gt; adb devices</p>\n<p>More:</p>\n<ul>\n<li><p>making sure all the developer options are set to USB file transfer.</p>\n</li>\n<li><p>Android File Transfer opened when connecting cable (this confirms proper working usb cable)</p>\n</li>\n<li><p>I closed Android File Transfer via Activity Monitor as some claim this can cause conflict</p>\n<p>in the end that step that made it work was opening up the terminal and typing: adb devices -&gt; this prompted an authorization request on the device.</p>\n</li>\n</ul>\n", "tags": ["android", "google-chrome"]}
