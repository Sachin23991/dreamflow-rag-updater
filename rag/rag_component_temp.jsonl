{"id": "7309bf67-319d-4802-897f-e4d6e8596273", "text": "Q: How to Connect a Bluetooth or Audio device in Windows PowerShell? A: <p>I was searching about the same error and I saw this tool: <a href=\"https://bluetoothinstaller.com/bluetooth-command-line-tools\" rel=\"nofollow noreferrer\">https://bluetoothinstaller.com/bluetooth-command-line-tools</a></p>\n<p>This a Bluetooth command line add-on for windows.</p>\n<p>It's fine and it's easy to use, but it needs admin rights.</p>\n<p>I hope it helps!</p>\n", "tags": ["windows", "powershell", "automation", "admin"]}
{"id": "1317f0b4-2e03-4ad6-a6b3-43280425b50b", "text": "Q: Is GCC right when it accepts a class template having a member with a wrong default member initializer? A: <blockquote>\n<p>Is GCC right when it accepts</p>\n</blockquote>\n<p>No, <strong>GCC is incorrect</strong> in accepting an ill-formed program  since <code>Wrapper w{};</code> is direct initialization and it needs an existing default constructor for <code>Wrapper w{};</code> to be valid but a default constructor will not be synthesized for <code>Wrapper</code> since you've provided your own constructor, as explained below in detail.</p>\n<hr />\n<p>First note that <code> Wrapper w{};</code> is direct initialisation(direct list initialization to be more specific). From <a href=\"https://eel.is/c++draft/dcl.init\" rel=\"nofollow noreferrer\">dcl.init</a>:</p>\n<blockquote>\n<p>The initialization that occurs:</p>\n<ul>\n<li><strong>for an initializer that is a</strong> parenthesized expression-list or a <strong>braced-init-list</strong>,</li>\n</ul>\n<p><strong>is called direct-initialization.</strong></p>\n</blockquote>\n<p>Next we move to the <a href=\"https://eel.is/c++draft/dcl.init#general-16\" rel=\"nofollow noreferrer\">semantics of the initializer</a>.</p>\n<blockquote>\n<ol start=\"16\">\n<li>The semantics of initializers are as follows. The destination type is the cv-unqualified type of the object or reference being initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</li>\n</ol>\n<ul>\n<li><strong>If the initializer is a (non-parenthesized) braced-init-list</strong> or is = braced-init-list, <strong>the object or reference is list-initialized ([dcl.init.list]).</strong>.</li>\n<li></li>\n<li></li>\n</ul>\n</blockquote>\n<p>The above means that, the object is to be <a href=\"https://eel.is/c++draft/dcl.init#list\" rel=\"nofollow noreferrer\">list-initialized</a>.</p>\n<p>From <a href=\"https://eel.is/c++draft/dcl.init#list\" rel=\"nofollow noreferrer\">list initialization</a>:</p>\n<blockquote>\n<p>List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is called an initializer list, and the comma-separated initializer-clauses of the initializer-list or designated-initializer-clauses of the designated-initializer-list are called the elements of the initializer list. An initializer list may be empty. List-initialization can occur in direct-initialization or copy-initialization contexts; <strong>list-initialization in a direct-initialization context is called direct-list-initialization</strong> and list-initialization in a copy-initialization context is called copy-list-initialization. Direct-initialization that is not list-initialization is called direct-non-list-initialization.</p>\n</blockquote>\n<p>The above means that <code>Wrapper w{};</code> is direct-list initiaization. Next we see the <a href=\"https://eel.is/c++draft/dcl.init#list-3\" rel=\"nofollow noreferrer\">effect</a> of list initialization:</p>\n<blockquote>\n<p>List-initialization of an object or reference of type cv T is defined as follows:</p>\n<ul>\n<li>Otherwise, if the initializer list has no elements and T is a class type with a default constructor, the <strong>object is value-initialized.</strong></li>\n</ul>\n</blockquote>\n<p>The above means that the object will be <a href=\"https://eel.is/c++draft/dcl.init#general-9\" rel=\"nofollow noreferrer\">value initialized</a>, so we move on to value-initialization:</p>\n<blockquote>\n<ol start=\"8\">\n<li>To value-initialize an object of type T means:</li>\n</ol>\n<ul>\n<li>If T is a (possibly cv-qualified) class type ([class]), then let C be the constructor selected to default-initialize the object, if any. If C is not user-provided, the object is first zero-initialized. In all cases, the object is then default-initialized.;</li>\n</ul>\n</blockquote>\n<p>This means that the object will be <a href=\"https://eel.is/c++draft/dcl.init#general-7\" rel=\"nofollow noreferrer\">default initialized</a>:</p>\n<blockquote>\n<p>To default-initialize an object of type T means:</p>\n<ul>\n<li>If T is a (possibly cv-qualified) class type ([class]), constructors are considered. The applicable constructors are enumerated ([over.match.ctor]), and the best one for the initializer () is chosen through overload resolution ([over.match]). The constructor thus selected is called, with an empty argument list, to initialize the object.</li>\n</ul>\n</blockquote>\n<p>So we move on to <a href=\"https://eel.is/c++draft/over.match.ctor\" rel=\"nofollow noreferrer\">over.match.ctor</a> to get a list of candidate ctors. Also do note the <code>initializer()</code> part in the above quoted reference as it will be used at the end as an argument.</p>\n<blockquote>\n<p>When objects of class type are direct-initialized, copy-initialized from an expression of the same or a derived class type ([dcl.init]), or default-initialized, overload resolution selects the constructor. <strong>For direct-initialization or default-initialization</strong> (including default-initialization in the context of copy-list-initialization), the <strong>candidate functions are all the constructors of the class of the object being initialized.</strong> Otherwise, the candidate functions are all the non-explicit constructors ([class.conv.ctor]) of that class. The argument list is the expression-list or assignment-expression of the initializer. For default-initialization in the context of copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>But note that there is no default constructor for <code>Wrapper</code>. As you've provided your own parameterized ctor, the compiler won't synthesize a default ctor for <code>Wrapper</code>. Thus, the condition for <code>Wrapper w{};</code> to be valid(which requires a default ctor) is not fulfilled and clang is correct in rejecting the program.</p>\n<h3>Important Note</h3>\n<p>Note that this is <strong>not IFNDR</strong>(aka ill-formed no diagnostic required) as the conditions in <a href=\"https://eel.is/c++draft/temp#res.general-6.sentence-3\" rel=\"nofollow noreferrer\">temp#res.general-6</a> aren't satisfied. This means that the compiler is <strong>required to</strong> emit a diagnostic which is why gcc is wrong since it doesn't emit any diagnostic for this ill-formed program.</p>\n", "tags": ["c++", "templates", "language-lawyer", "compiler-bug"]}
{"id": "906b1e56-c824-4b40-913a-57dc162f832d", "text": "Q: Draw border on top of another application window A: <p>This will draw an outline on a panel that can be placed over another window. It avoids using WS_EX_LAYERED because that style causes problems; instead, it uses a hollow region to allow full access to the window below. This is tested and works identically on W98 and Windows 7, so it probably works on Windows 10 (but is not tested there).</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;windows.h&gt;\n\nHWND H_panel; LRESULT CALLBACK PanelPrc(); void EdgeDraw();\nint WINAPI WinMain(HINSTANCE H_inst,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow){\n  DWORD N=sizeof(WNDCLASSEX); WNDCLASSEX P; memset(&amp;P,0,N);\n  P.lpszClassName=&quot;PANEL&quot;; P.lpfnWndProc=PanelPrc; P.hInstance=H_inst;\n  P.hCursor=LoadCursor(NULL,IDC_ARROW); P.cbSize=N;\n  P.hbrBackground=GetStockObject(NULL_BRUSH);\n\n  RECT R; GetWindowRect(GetDesktopWindow(),&amp;R); N=WS_EX_TOOLWINDOW|WS_EX_TOPMOST;\n  H_panel=CreateWindowEx(N,P.lpszClassName,&quot;&quot;,WS_POPUP,0,0,0,0,NULL,NULL,H_inst,NULL);\n\n  HRGN O=CreateRectRgnIndirect(&amp;R),I=CreateRectRgn(R.left+2,R.top+2,R.right-2,R.bottom-2);\n  CombineRgn(O,O,I,RGN_DIFF); SetWindowRgn(H_panel,O,1);\n\n  HWND H=GetForegroundWindow();\n  SetWindowPos(H_panel,0,0,0,R.right,R.bottom,SWP_SHOWWINDOW); SetForegroundWindow(H);\n\n\n  MSG M; while(GetMessage(&amp;M,NULL,0,0)&gt;0){TranslateMessage(&amp;M); DispatchMessage(&amp;M);}\n  return M.wParam;\n}\n\nLRESULT CALLBACK PanelPrc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam){\n  switch(msg){\n    case WM_PAINT:{EdgeDraw(H_panel); return 0;} break;\n    case WM_DESTROY:{PostQuitMessage(0);} break;\n    default: return DefWindowProc(hwnd,msg,wParam,lParam);\n  }\n  return 0;\n}\n\nvoid EdgeDraw(HWND H){\n  RECT R; HPEN P=CreatePen(0,2,0xFF00FF); int X,Y,N,O=0;\n  HDC D=GetWindowDC(H); P=SelectObject(D,P);\n  GetWindowRect(H,&amp;R); X=R.right-R.left,Y=R.bottom-R.top;\n  int C[4][2]={{O+1,O+1},{O+1,O+Y-1},{O+X-1,O+Y-1},{O+X-1,O+1}};\n  MoveToEx(D,O+1,O+1,NULL); N=4; while(N--){LineTo(D,C[N][0],C[N][1]);}\n  P=SelectObject(D,P); DeleteObject(P); ReleaseDC(H,D);\n}\n</code></pre>\n<p>This example is complete because it's important to do things in the right order, and in a fully established context, if you want the result to be flicker-free at all times.</p>\n<p>There is a compromise: The region must be set to allow some area(s) to allow through-clicks, or to be drawn on. It can't do both. This is a limitation of the basic API functions used, being chosen for widest compatibility. If someone knows a way to improve on this without sacrificing that, go for it...</p>\n<p>Reasons to avoid WS_EX_LAYERED:</p>\n<p>It forces the task bar/switcher windows to have entries for the hidden window, and prevents it from showing normally in Windows 7 (though it will still appear in W98, and even there, the task entries exist when not wanted if WS_EX_LAYERED is set). Also, in Windows 7, if the drawn outline intercepts the taskbar, unrest results. It's ugly. Avoiding WS_EX_LAYERED is far easier than trying to manage its consequences.</p>\n", "tags": ["c++", "winapi", "gdi"]}
{"id": "be699ddc-e1a1-49f3-83c7-cb3057905bb5", "text": "Q: Testing postgresql in unit tests - mocking and unit test libraries A: <p>It's been a few years since your question, but here's how things stand now:</p>\n<ul>\n<li><p><code>testing.postgresql</code> hasn't had commits for 8 years, but has 294 stars and 47 forks.</p>\n</li>\n<li><p><code>pytest-postgresql</code> has recent commits, and 502 stars and 52 forks on github.</p>\n</li>\n<li><p><code>pytest-pgsql</code> hasn't had commits for 7 years, but has 67 stars and 5 forks.</p>\n</li>\n</ul>\n<p>So it appears that only <code>pytest-postgresql</code> is not stale.</p>\n<p>I'm mostly interested in this from a test-speed perspective. For you current setup with docker you can make the database essentially in-memory by following this guide: <a href=\"https://www.fusonic.net/en/blog/fusonic-test-with-databases-part-3\" rel=\"nofollow noreferrer\">https://www.fusonic.net/en/blog/fusonic-test-with-databases-part-3</a>, but I'll be doing some experimentation to see if one of these libraries can turn out a test suite runtime reduction (e.g. cutting out some of the networking)</p>\n", "tags": ["python", "postgresql", "unit-testing", "mocking", "pytest-mock"]}
{"id": "2aee1a12-bc36-4999-94ea-36cc482239d3", "text": "Q: Angular 20 Reactive Forms - Custom validator based on signal A: <p>Now I'm working on just that.</p>\n<pre><code>export class CustomValidators {\n  ...\n\n  static basedOnSignals&lt;Params&gt;(opts: {\n    params: () =&gt; Params;\n    factory: (data: { params: Params }) =&gt; ValidatorFn;\n  }) {\n    var init = false;\n    var params = null;\n\n    try {\n      params = opts.params();\n      init = true;\n    } catch (error) {\n      init = false;\n    }\n\n    return (control: AbstractControl) =&gt; {\n      const root = control.root;\n      console.log({ root, init });\n\n      return (\n        !init\n          ? Validators.nullValidator\n          : opts.factory({ params: opts.params() })\n      )?.(control);\n    };\n  }\n}\n</code></pre>\n<p>I also tried passing an Injector as an argument, so that the effect can be executed within the runInInjectionContext callback, but it currently fails.</p>\n", "tags": ["angular", "angular-reactive-forms", "ngrx", "angular-signals", "ngrx-signal-store"]}
{"id": "69243924-5fac-409b-a696-cc965fc961de", "text": "Q: Cloudflare API return 403 &quot;Enable JavaScript and cookies to continue&quot; A: <p>Cloudflare recently deployed stricter <strong>bot-detection</strong> (via Turnstile / <code>cf_clearance</code> cookie / javascript challenges).</p>\n<p>Your application <strong>cannot execute JavaScript</strong>, <strong>cannot solve a Turnstile/CF challenge</strong>, and <strong>does not send Cloudflare cookies</strong>.</p>\n<p>So Cloudflare thinks your C++ application is a bot \u2192 <strong>403 \u201cEnable JavaScript and cookies to continue\u201d</strong>.</p>\n<p>POSTMAN and RESTMAN work because <strong>they run inside a full browser environment</strong> or they simulate one well enough (with cookies and JS challenge pre-solved).</p>\n<p>Indy / Chilkat <strong>do not</strong>.</p>\n<p>This has nothing to do with your code; Cloudflare changed the security rules.</p>\n", "tags": ["c++", "cloudflare", "http-status-code-403", "indy10"]}
