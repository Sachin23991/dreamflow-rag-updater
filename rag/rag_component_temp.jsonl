{"id": "25747e2f-1418-4ec2-8d55-5be8aac7fad6", "text": "Q: How to disable certain certificate types in Java SSL handshake A: <p>The snippet you provided is usually under the &quot;Handshake Protocol: Certificate Request&quot; section in the TLS handshake. The server signals which client certificates it accepts (certificate types, signing algorithms and optionally issuing CAs):</p>\n<pre class=\"lang-none prettyprint-override\"><code>[...]\nv Handshake Protocol: Server Key Exchange\n    Handshake Type: Server Key Exchange (12)\n    Length: 176\n  &gt; EC Diffie-Hellman Server Params\nv Handshake Protocol: Certificate Request\n    Handshake Type: Certificate Request (13)\n    Length: 428\n    Certificate types count: 3\n  v Certificate types (3 types)\n       Certificate type: RSA Sign (1)\n       Certificate type: DSS Sign (2)\n       Certificate type: ECDSA Sign (64)\n    &gt; Signature Hash Algorithms Length: 24\n    Signature Hash Algorithms (12 algorithms)\n    Distinguished Names Length: 396\n  &gt; Distinguished Names (396 bytes)\nv Handshake Protocol: Server Hello Done\n    Handshake Type: Server Hello Done (14)\n    Length: 0\n</code></pre>\n<p>As mentioned before, disabling all algorithms that use DSA <strong>SHOULD</strong> work to to disable DSS Sign.</p>\n<p>After some testing with different JAVA_OPTIONS like</p>\n<pre class=\"lang-none prettyprint-override\"><code>  -Djdk.tls.disabledAlgorithms=DSA,SHA1withDSA\n  -Djdk.tls.disabledSignatureAlgorithms=DSA,SHA1withDSA\n  -Djavax.net.debug=ssl,handshake\n</code></pre>\n<p>and always getting the debug output</p>\n<pre class=\"lang-none prettyprint-override\"><code>CertificateRequest.java:659|Produced CertificateRequest handshake message (\n&quot;CertificateRequest&quot;: {\n  &quot;certificate types&quot;: [ecdsa_sign, rsa_sign, dss_sign]\n  &quot;supported signature algorithms&quot;: [ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384, ecdsa_secp521r1_sha512, ed25519, ed448, rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512, rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, rsa_pkcs1_sha256, rsa_pkcs1_sha384, rsa_pkcs1_sha512, dsa_sha256, ecdsa_sha224, rsa_sha224, dsa_sha224, ecdsa_sha1, rsa_pkcs1_sha1, dsa_sha1]\n</code></pre>\n<p>no matter what i disabled, I looked into the source code of CertificateRequest.java (<a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/sun/security/ssl/CertificateRequest.java\" rel=\"nofollow noreferrer\">https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/sun/security/ssl/CertificateRequest.java</a>) and found this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    // TLS 1.2 and prior versions\n    private enum ClientCertificateType {\n        // RFC 2246\n        RSA_SIGN            ((byte)0x01, &quot;rsa_sign&quot;, List.of(&quot;RSA&quot;), true),\n        DSS_SIGN            ((byte)0x02, &quot;dss_sign&quot;, List.of(&quot;DSA&quot;), true),\n        RSA_FIXED_DH        ((byte)0x03, &quot;rsa_fixed_dh&quot;),\n        DSS_FIXED_DH        ((byte)0x04, &quot;dss_fixed_dh&quot;),\n\n        // RFC 4346\n        RSA_EPHEMERAL_DH    ((byte)0x05, &quot;rsa_ephemeral_dh&quot;),\n        DSS_EPHEMERAL_DH    ((byte)0x06, &quot;dss_ephemeral_dh&quot;),\n        FORTEZZA_DMS        ((byte)0x14, &quot;fortezza_dms&quot;),\n\n        // RFC 4492 and 8442\n        ECDSA_SIGN          ((byte)0x40, &quot;ecdsa_sign&quot;,\n                                            List.of(&quot;EC&quot;, &quot;EdDSA&quot;),\n                                            JsseJce.isEcAvailable()),\n        RSA_FIXED_ECDH      ((byte)0x41, &quot;rsa_fixed_ecdh&quot;),\n        ECDSA_FIXED_ECDH    ((byte)0x42, &quot;ecdsa_fixed_ecdh&quot;);\n\n        private static final byte[] CERT_TYPES =\n                JsseJce.isEcAvailable() ? new byte[] {\n                        ECDSA_SIGN.id,\n                        RSA_SIGN.id,\n                        DSS_SIGN.id\n                    } :  new byte[] {\n                        RSA_SIGN.id,\n                        DSS_SIGN.id\n                    };\n</code></pre>\n<p>So, in Java up to TLS version 1.2 you <strong>ALWAYS</strong> have DSS_SIGN.id (&quot;dss_sign&quot;) in the CertificateRequest because it is hardcoded. Therefore you can disable the <strong>usage</strong> of the DSA (DSS) algorithms in Java, but you can't remove &quot;Certificate Type: DSS Sign&quot; on the protocol level.</p>\n<p>RFC 5246 &quot;The Transport Layer Security (TLS) Protocol Version 1.2&quot; states in Section 7.4.4 (<a href=\"https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.4\" rel=\"nofollow noreferrer\">https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.4</a>):</p>\n<pre class=\"lang-none prettyprint-override\"><code>[...]\nThe interaction of the certificate_types and\nsupported_signature_algorithms fields is somewhat complicated.\ncertificate_types has been present in TLS since SSLv3, but was\nsomewhat underspecified.  Much of its functionality is superseded by\nsupported_signature_algorithms. The following rules apply:\n    \n       -  Any certificates provided by the client MUST be signed using a\n          hash/signature algorithm pair found in\n          supported_signature_algorithms.\n    \n       -  The end-entity certificate provided by the client MUST contain a\n          key that is compatible with certificate_types.  If the key is a\n          signature key, it MUST be usable with some hash/signature\n          algorithm pair in supported_signature_algorithms.\n    \n       -  For historical reasons, the names of some client certificate types\n          include the algorithm used to sign the certificate.  For example,\n          in earlier versions of TLS, rsa_fixed_dh meant a certificate\n          signed with RSA and containing a static DH key.  In TLS 1.2, this\n          functionality has been obsoleted by the\n          supported_signature_algorithms, and the certificate type no longer\n          restricts the algorithm used to sign the certificate.  For\n          example, if the server sends dss_fixed_dh certificate type and\n          {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply\n          with a certificate containing a static DH key, signed with RSA-\n          SHA1.\n[...]\n</code></pre>\n<p>Solutions</p>\n<ol>\n<li>Use TLS 1.3 (removed the legacy <code>certificate_types</code> field from the handshake and removed all weak legacy algorithms including DSS/DSA)</li>\n<li>Disable the usage of all DSA algorithms and ignore the protocol level</li>\n<li>Modify above code and build your own Java Runtime and your own TLS protocol implementation ;-)</li>\n</ol>\n", "tags": ["java", "ssl", "ssl-handshake"]}
{"id": "4474bc95-b2d6-4e50-974b-211e8262b1d2", "text": "Q: How does attribute access (.) actually work internally? A: <p><strong>update</strong>:  the last part was actually wrong in the first version: <code>__getattr__</code> is called <em>after</em> <code>__getattribute__</code> not inside it.</p>\n<p>Python will normally retrieve the &quot;expected&quot; attribute - but the as you put it, there are many steps and fallbacks.</p>\n<p>When retrieving an attribute for <em>reading</em> -\n(1)\nthe first step in the class <code>__getattribute__</code> method - which is usually the default <code>object.__getattribute__</code>.</p>\n<pre><code>\nIn [24]: class A:\n    ...:     def __getattribute__(self, attrname):\n    ...:         if attrname == &quot;a&quot;:\n    ...:             return 5\n    ...:         raise AttributeError\n    ...: \n\nIn [25]: a = A()\n\nIn [26]: a.a\nOut[26]: 5\n\nIn [27]: a.b\n---------------------------------------------------------------------------\nAttributeError \n\n\n</code></pre>\n<p>but we usually do not override <code>__getattribute__</code> and let the default implementation in <code>object.__getattribute__</code> - which performs steps 2-5 (but not 6)</p>\n<p>(2) Inside getattribute, Python will search the attribute in the <em>class</em> itself, or in the superclasses, <a href=\"https://docs.python.org/3/howto/mro.html\" rel=\"nofollow noreferrer\">linearized by the <code>mro</code></a>. If it is found, Python checks if <a href=\"https://docs.python.org/3/reference/datamodel.html#implementing-descriptors\" rel=\"nofollow noreferrer\">it is a <em>data</em> descriptor</a>:</p>\n<p>If the attribute in the class (or superclasses) is an <em>instance</em> of a class which implements either <code>__set__</code> or <code>__delete__</code> (check the descriptor protocol) - it is a DATA descriptor, and Python will try to call the <code>__get__</code> method in this class, passing the instance as parameter.</p>\n<p>Note that &quot;methods&quot; are usually &quot;non data descriptors&quot;, and attributes defined in the class or super-classes using <code>__slots__</code> are exposed to Python language as data descriptors themselves.</p>\n<pre><code>In [29]: class A:\n    ...:     @property\n    ...:     def a(self):\n    ...:         return 5\n    ...:     # the &quot;property&quot; decorator always creates an object which is a data descriptor:\n    ...:     # it contains the `__set__` method even if not declared\n    ...: \n\nIn [30]: a = A()\n\nIn [31]: # injects another value than &quot;5&quot; in the instance:\n\nIn [32]: a.__dict__[&quot;a&quot;] = 23\n\nIn [33]: # this bypasses the descriptor protocol writting the &quot;23&quot; \n\nIn [34]: a.a\nOut[34]: 5\n\nIn [35]: # but the descriptor is still called!\n\n</code></pre>\n<p>(3) If the attribute is not a data descriptor, Python will search the instance <code>.__dict__</code> dictionary for a key equal to the attribute name.</p>\n<p>If that key exists, it is returned.</p>\n<p>(4) If not, Python will check if the class (or superclasses) contain that attribute as a non-data descriptor (for example, a method - which features a <code>__get__</code> but no <code>__set__</code>)-  then, that method is retrieved by calling <code>__get__</code>.</p>\n<p>Here an example for '3' and '4': the existing method <code>a</code> is replaced by another function in the instance: that is called instead of the method defined in the class:</p>\n<pre><code>In [36]: class A:\n    ...:     def a(self):\n    ...:         return 5\n    ...: \n\nIn [37]: a = A()\n\nIn [38]: a.a = lambda: 23\n\nIn [40]: a.a()\nOut[40]: 23\n\n# note that functions attached to instances like this  don't have the auto-inserted `self` attribute: the mechanisms that retrieve a method using the descriptor protocol are the ones which insert the `self` value in the method call!\n\n</code></pre>\n<p>(5) Python will return the class attribute for that attribute, even if it is not a descriptor. The attribute should be a plain attribute in the class or a superclass according to the mro: either in the <code>type(instance).__dict__</code>    - the whole algorithm is not re-used to search for the attribute in the class if it is in the class of the class (the metaclass), or a descriptor assigned in the metaclass, it is not found.</p>\n<pre><code>In [45]: class A:\n    ...:     a = 5\n    ...: \n\nIn [46]: a = A()\n\nIn [47]: a.a = 23  # creates an instance value of &quot;23&quot; overriding the &quot;5&quot; in the class\n\nIn [48]: a.__dict__  # shows the instance storage:\nOut[48]: {'a': 23}\n\nIn [49]: a.a\nOut[49]: 23\n\nIn [50]: del a.a  # deletes the value in the instance, leaving the class attribute untouched\n\nIn [51]: a.a\nOut[51]: 5\n</code></pre>\n<p>(6) If all of this fails, getattribute will raise an &quot;AttributeError&quot;    inner exception - which is caught internally by Python machinery, and then it will try to call the <code>__getattr__</code> function (not <code>__getattribute__</code>  ll the steps above are encoded inside <code>__getattribute__</code>,  <code>__getattr__</code> is called afterwards), and if that doesn't exist, or raise AttributeError, then the attribute is said not to exist.</p>\n<pre><code>In [55]: a = A()\n\nIn [56]: a.a\nOut[56]: 5\n\nIn [57]: a.a = 23\n\nIn [58]: a.a\nOut[58]: 23\n\nIn [59]: a.__dict__\nOut[59]: {'a': 23}\n\nIn [60]: a.__dict__.clear()\n\nIn [61]: a.a\nOut[61]: 5\n\n\n</code></pre>\n<p>And to show that  <code>__getattr__</code>  is called after  <code>__getattribute__</code> we can use this snippet:</p>\n<pre><code>\nIn [8]: class A:\n   ...:     def __getattribute__(self, attr):\n   ...:         print(f&quot;entering getattribute&quot;)\n   ...:         try:\n   ...:             res = super().__getattribute__(attr)\n   ...:         except AttributeError:\n   ...:             print(&quot;attribute error inside getattribute&quot;)\n   ...:             raise\n   ...:         finally:\n   ...:             print(&quot;exiting getattribute&quot;)\n   ...:         return res\n   ...:     def __getattr__(self, attr):\n   ...:         print(&quot;getattr&quot;)\n   ...:         return attr\n   ...: \n\nIn [9]: A().b\nentering getattribute\nattribute error inside getattribute\nexiting getattribute\ngetattr\nOut[9]: 'b'\n\n</code></pre>\n<p>It is important to note that metaclasses can't actually customize this behavior of calling  <code>__getattr__</code> after <code>__getattribute__</code> runs all the steps above and raises itself: that is hardcoded in  the language.\n(Unlike the mechanism to create an instance which goes through the metaclass <code>__call__</code> method  which can be reimplemented to customize the steps of calling the class' <code>__new__</code> and <code>__init__</code>.)</p>\n<p>As for metaclasses, as described in (5), any modifications they make to attribute access is normally restricted to attributes in the classes themselves - the final instances of classes modified by a custom metaclass won't have attribute access easily modifiable by anything on the metaclass. However customising <code>__getattr__</code>, <code>__getattribute__</code> or creating descriptors in the class itself, do modify attribute access directly. Of course, metaclasses could make indirect things, like modifying the mro itself (not trivial either)  - and this could have attributes searched (or the mechanisms described above) in other classes than what one would expect due to normal inheritance order.</p>\n", "tags": ["python", "oop", "attributes", "metaclass"]}
{"id": "02a57304-ec1e-40ff-baf4-f8f28799bb8f", "text": "Q: What&#39;s the most efficient way to implement an array permutation? A: <p>I understand that only a benchmark will give the true answer, but I also wanted to know what to expect before trying to implement the second way (the first one is what I already have working).</p>\n<p>I already parallelize the permutation manually with OpenMP, but I think the same question applies even in that case. I also don't know if having multithreading somehow impacts what sequential I/O is preferred.</p>\n", "tags": ["performance", "fortran"]}
{"id": "05e65064-a26c-42d0-b3f2-0f8a9deb0141", "text": "Q: How to easyily find unused public methods/properties A: <p>I built a .NET CLI tool that analyzes a solution and reports unused members (methods, properties, fields).</p>\n<p><strong>Repository:</strong><br />\n<a href=\"https://github.com/kokkerametla/dotnet-unused\" rel=\"nofollow noreferrer\">https://github.com/kokkerametla/dotnet-unused</a></p>\n<p><strong>Usage example:</strong></p>\n<pre><code>dotnet-unused MySolution.sln\n</code></pre>\n<p>It scans the entire solution and prints the results directly to the console.</p>\n", "tags": [".net", "properties", "methods", "refactoring", "public-method"]}
{"id": "f95288df-9912-422e-910d-4da84546e1a2", "text": "Q: printf() not working on colab while running a CUDA c++ code A: <p>There is very likely a mismatch between the architecture that your generated binary targets and the expected target architecture for T4 GPU, i.e., <code>sm_75</code>. You should use the <code>-arch</code> option to tell the <code>nvcc</code> compiler exactly which GPU architecture it should generate the binary for.</p>\n<p>Try invoking the compiler with the command below:</p>\n<pre><code>nvcc hello.cu -arch=sm_75 -o hello\n</code></pre>\n<h3>Comment on Error Handling</h3>\n<p><code>cudaDeviceSynchronize()</code> returns an error code that you are not checking. Checking the returned error code, in this specific situation, can tell if there was a problem launching your kernel.</p>\n<p>This is how you can check the returned error code:</p>\n<pre><code>cudaError_t cudaerr = cudaDeviceSynchronize();\nif (cudaerr != cudaSuccess)\n{\n  printf(&quot;Error: \\&quot;%s\\&quot;.\\n&quot;, cudaGetErrorString(cudaerr));\n}\n</code></pre>\n<h3>References</h3>\n<ul>\n<li><p>For more on how <code>nvcc</code> generates PTX and Cubin (what I referred to as &quot;binary&quot; above), you should check out <a href=\"https://docs.nvidia.com/cuda/cuda-programming-guide/02-basics/nvcc.html?utm_source=chatgpt.com#nvcc-ptx-and-cubin-generation\" rel=\"nofollow noreferrer\">NVCC PTX and Cubin Generation section of CUDA Programming Guide</a>.</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/13321253/21452631\">This is a good answer</a> that summarizes certain limitations of CUDA's <code>printf()</code> function, such as, at what points in the program its output is displayed.</p>\n</li>\n</ul>\n", "tags": ["c++", "cuda", "google-colaboratory"]}
{"id": "1fcc3c61-ed53-4363-b99e-d0edf4bc9fd7", "text": "Q: Being too reliant on AI, roast the crap out of my coding please A: <p>There's nothing to critique; because we don't know what problem you're trying to solve. AI is great at solving the wrong problem ... because it can't read minds. And, 99% of AI &quot;answers&quot; are someone else's &quot;old&quot; answer.</p>\n", "tags": ["c#", ".net", "refactoring"]}
