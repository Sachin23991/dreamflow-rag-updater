{"id": "45d44f54-fe1b-49d6-8eaf-da9393284652", "text": "Q: How to read JSON data sent to my asp.net page (callback url) from gateway A: <p>You\u2019re thinking about this the wrong way around.</p>\n<p>With a callback (webhook), you don\u2019t fetch the data and you don\u2019t need to know the sender\u2019s URL. The payment gateway calls <strong>your</strong> callback URL and sends the JSON in the request.</p>\n<p>So your <code>notifypayment.aspx</code> page should just read the incoming HTTP request body, usually via POST. You don\u2019t create an <code>HttpWebRequest</code> to your own URL.</p>\n<p>In ASP.NET you can simply read it from <code>Request.InputStream</code> and then parse it.</p>\n<p>The <code>timestamp</code>, <code>nonce</code>, and <code>sign</code> fields are there for request verification, not for identifying the source by URL.</p>\n<p>Once you treat the callback as an incoming request, the rest falls into place.</p>\n", "tags": ["c#", "asp.net", "json", "get"]}
{"id": "121b415f-c80c-4845-829b-77a9d84e3fb5", "text": "Q: Bash script sftp only downloading files to same directory script is in A: <p>If you're just trying to send or receive single files, it really might be easier to use <code>scp</code> rather than <code>sftp</code>.  They both use the same underlying SSH protocol, but <code>scp</code> runs from the command line and doesn't require any additional scripting.</p>\n<p>You can directly specify the source and destination directories:</p>\n<p><code>scp user@host:/some/remote/folder/FILE /some/local/folder/</code></p>\n<p>Or if you're trying to upload a file to a remote server, just swap the order (same as with the <code>cp</code> command):</p>\n<p><code>scp /some/local/folder/FILE user@host:/some/remote/folder/</code></p>\n<p>This won't work if you need to do additional commands in the <code>sftp</code> client, but if you're only copying a few files from one server to another, just add your SSH keys and get scp'ing!</p>\n<p>(And if you did need to run some extra commands, you could always use <code>ssh</code> to run commands/scripts on the remote server.)</p>\n", "tags": ["linux", "bash", "shell", "sftp"]}
{"id": "778abaa7-23d9-4e2c-901f-98cdde757ee6", "text": "Q: npm behind a proxy fails with status 403 A: <p>I was able to solve by using npm mirror url:</p>\n<pre><code>npm config set registry https://registry.npmmirror.com\n</code></pre>\n", "tags": ["http", "node.js", "proxy", "npm"]}
{"id": "58239cbf-ec99-4c40-aadd-3d5b4befe357", "text": "Q: Generate all versions of a string with each letter replaced by a wildcard (?) once in bash A: <p>Note that in <code>grep</code> regular expressions the <em>wildcard</em> that matches any character is <code>.</code>, not <code>?</code>. You could use <code>bash</code> to build the <code>.GCCACAGTGC|...|GGCCACAGTG.</code> regular expression and use it with <code>grep</code>; something like:</p>\n<pre><code>s=&quot;GGCCACAGTGC&quot;; re=&quot;&quot;\nfor ((i=1; i&lt;=${#s}; i++)); do\n  printf -v re '%s|%s' &quot;$re&quot; &quot;${s:0:i-1}.${s:i}&quot;\ndone\ngrep &quot;${re#|}&quot; fastq-file\n</code></pre>\n<p>Or, with just <code>awk</code>:</p>\n<pre><code>awk -v s=&quot;GGCCACAGTGC&quot; '\nBEGIN {\n  for(i=1; i&lt;=length(s); i++)\n    re = re (re?&quot;|&quot;:&quot;&quot;) substr(s,1,i-1) &quot;.&quot; substr(s,i+1)\n}\n$0 ~ re' fastq-file\n</code></pre>\n", "tags": ["bash", "grep", "wildcard", "fastq"]}
{"id": "6d1c178e-fce6-4639-8c4d-89c4886473eb", "text": "Q: Python PIP cannot find pywin32 (on windows) A: <p>I ran into this error a few times. It always occurred because I &quot;compiled&quot; pinned dependencies on Windows (using e.g. `pip-compile pyproject.toml`) but then used the resulting requirements.txt on a linux system (mostly in Docker containers). The workaround is to make the (windows-)implicit dependency explicit but add a constraint to the OS/platform like this:</p>\n<pre><code># rest of pyproject.toml\ndependencies = [\n     ...,\n    &quot;pywin32&gt;=306; sys_platform == 'win32'&quot;,\n]\n</code></pre>\n<p>which results in requirements.txt after pip-compile:</p>\n<pre><code># rest of requirements.txt\n# ...\npywin32==311 ; sys_platform == &quot;win32&quot;\n</code></pre>\n", "tags": ["python", "python-3.x", "pip"]}
{"id": "08f0a288-bd90-4376-b426-5435bf147c35", "text": "Q: How to create alias to template function wrapper A: <p>This</p>\n<blockquote>\n<pre><code>template &lt; typename T &gt; using foo_alias = foo &lt; T &gt;::make_shared_ptr &lt; T &gt; ;\n</code></pre>\n</blockquote>\n<p>Is wrong, because <code>using</code> is for type aliases (or type alias templates), but <code>foo&lt;T&gt;::make_shared_ptr&lt;T&gt;</code> is not a type. To alias the static member function you could write a free function that forwards to the actual member function.</p>\n<p>You have at least 3 different template arguments that are all called <code>T</code>. That hinders readability and, I suppose, is part of your problem. I suppose <code>foo_make_shared_ptr&lt;T&gt;::foo_make_shared_ptr</code> should return a <code>shared_ptr&lt;foo&lt;T&gt;&gt;</code> not some <code>shared_ptr&lt;foo&lt;U&gt;&gt;</code>. Hence, you don't need that extra <code>T</code> template arguments. In the scope of the class template you can use <code>foo</code> to refer to the current instantiation <code>foo&lt;T&gt;</code> (this is called <a href=\"https://en.cppreference.com/w/cpp/language/injected-class-name.html\" rel=\"nofollow noreferrer\">&quot;injected-class name&quot;</a>). If you change that, the function call is already much less verbose:</p>\n<pre><code>#include &lt;memory&gt;\n\n\ntemplate &lt; class T &gt;\nstruct foo {\n    T variable;\n    foo (T t) : variable (t) {}\n    virtual ~foo(){}\n    using foo_shared_ptr = std::shared_ptr&lt;foo&gt;;\n    template &lt;typename... Args &gt; foo_shared_ptr static foo_make_shared_ptr ( Args&amp;&amp;... args) {\n        return std::make_shared&lt;foo&gt;(std::forward&lt;Args&gt;(args)...);\n    }\n};\n\nint main() {\n    auto f = foo&lt;int&gt;::foo_make_shared_ptr(42);\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/z/318j5zv7T\" rel=\"nofollow noreferrer\">Live Demo</a></p>\n<p>However, I see no advantage of defining <code>foo_make_shared_ptr</code> as static member. Compare to <code>make_xxx</code> function from the standard library: They are all free function templates. Do the same and the call is just</p>\n<pre><code>auto f = foo_make_shared_ptr&lt;int&gt;(42);\n</code></pre>\n<p>(Note that for the simple case where <code>Args... == T</code> there is no need for <code>Args...</code> either and <code>T</code> could be deduced from arguments to <code>foo_make_shared_ptr</code>, then the call would be just <code>f = foo_make_shared_ptr(42)</code>. On the other hand, if you want to allow passing <code>T</code>s constructor arguments to <code>foo_make_shared_ptr</code>, the approach is fine.)</p>\n", "tags": ["c++", "c++11", "templates", "variadic-templates", "shared-ptr"]}
