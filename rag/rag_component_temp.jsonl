{"id": "1ff2f3d5-c176-4739-bb67-d2d0dea922d4", "text": "Q: multiprocessing.JoinableQueue.empty() seems broken A: <p>Try using <a href=\"https://github.com/python/cpython/issues/87302#issuecomment-3660276003\" rel=\"nofollow noreferrer\">the workaround from related python/cpython#87302</a>, replacing <code>multiprocessing.queues.Queue</code> with <code>multiprocessing.queues.JoinableQueue</code> as the parent. For me on Linux, this fixed your problem due to the redefined <code>empty()</code> via semaphore.</p>\n<p>As for the cause, <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue\" rel=\"nofollow noreferrer\"><code>multiprocessing.Queue</code></a> uses <a href=\"https://github.com/python/cpython/blob/0b8c348f2756c193d6bd2618cadbb90b2f218ccc/Lib/multiprocessing/connection.py#L1140-L1171\" rel=\"nofollow noreferrer\">pipe waiting via poll/select with zero timeout (on UNIX)</a> in <a href=\"https://github.com/python/cpython/blob/db098a475a47b16d25c88d95dbcf0c6572c68576/Lib/multiprocessing/queues.py#L126-L127\" rel=\"nofollow noreferrer\">its implementation of the <code>empty()</code> method</a>. It is possible that the pipe may not be ready to read due to buffering, some limits, or simply undocumented behavior.</p>\n<p>If you succeed in further localizing the issue, I suggest <a href=\"https://github.com/python/cpython/issues\" rel=\"nofollow noreferrer\">reporting it to the CPython team</a>.</p>\n<hr />\n<p><strong>Update.</strong> If we take a closer look, we can see that the <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.put\" rel=\"nofollow noreferrer\"><code>put()</code></a> method does not take effect immediately, but instead <a href=\"https://github.com/python/cpython/blob/db098a475a47b16d25c88d95dbcf0c6572c68576/Lib/multiprocessing/queues.py#L90-L94\" rel=\"nofollow noreferrer\">delegates pickling and subsequent insertion to the background thread</a> (the documented behavior you refer to in your question).</p>\n<pre class=\"lang-py prettyprint-override\"><code>#!/usr/bin/env python3\n\nimport sys\nimport time\n\nfrom multiprocessing import Queue\n\n\ndef main():\n    queue = Queue()\n    queue.put(&quot;spam&quot;)\n    assert queue.qsize() == 1\n\n    print(queue.empty())  # True\n\n    time.sleep(1)\n\n    print(queue.empty())  # False\n\n\nif __name__ == &quot;__main__&quot;:\n    sys.exit(main())\n</code></pre>\n<p>Moreover, starting from a certain number of bytes, the thread hangs (related: <a href=\"https://github.com/python/cpython/issues/85927\" rel=\"nofollow noreferrer\">python/cpython#85927</a> | <a href=\"https://github.com/python/cpython/issues/128186\" rel=\"nofollow noreferrer\">python/cpython#128186</a> | <a href=\"https://github.com/python/cpython/issues/132634\" rel=\"nofollow noreferrer\">python/cpython#132634</a>).</p>\n<pre class=\"lang-py prettyprint-override\"><code>#!/usr/bin/env python3\n\nimport sys\n\nfrom multiprocessing import Queue\n\nITEMS = 10_000  # or another large number\n\n\ndef main():\n    queue = Queue()\n\n    for i in range(ITEMS):\n        queue.put(i)\n\n    assert queue.qsize() == ITEMS\n\n\nif __name__ == &quot;__main__&quot;:\n    sys.exit(main())\n\n# program will hang until you press Control-C\n</code></pre>\n<p>Thus, the implementation makes the incorrect assumption that the pipe always contains at least some of the inserted items. This does not cause problems in simple cases due to the lack of context switching with a small number of processes, but has an unpleasant effect when there are enough of them.</p>\n<pre class=\"lang-py prettyprint-override\"><code>#!/usr/bin/env python3\n\nimport sys\nimport time\n\nfrom multiprocessing import Process, Queue\n\nCONSUMERS = 100  # any sufficiently large number\nITEMS = CONSUMERS * 100  # should result in exceeding the underlying pipe\nDELAY = 1  # &quot;infinitesimal&quot;, but it can actually be as large as you like\n\n\ndef consume(queue):\n    for _ in range(ITEMS // CONSUMERS):\n        if queue.empty():  # it should never be printed, but it will be\n            print(&quot;EMPTY!&quot;)\n\n        queue.get()\n\n\ndef main():\n    queue = Queue()\n\n    for i in range(ITEMS):\n        queue.put(i)\n\n    time.sleep(DELAY)\n    assert queue.qsize() == ITEMS\n\n    consumers = [\n        Process(target=consume, args=[queue], daemon=True)\n        for _ in range(CONSUMERS)\n    ]\n\n    for consumer in consumers:\n        consumer.start()\n\n    for consumer in consumers:\n        consumer.join()\n\n\nif __name__ == &quot;__main__&quot;:\n    sys.exit(main())\n</code></pre>\n<p>Essentially, the problem is that <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.qsize\" rel=\"nofollow noreferrer\"><code>qsize()</code></a> (and anything that emulates it) does not depend on the pipe's state, but <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty\" rel=\"nofollow noreferrer\"><code>empty()</code></a> checks its readiness. In situations where the pipe drains faster than the buffer is flushed, <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty\" rel=\"nofollow noreferrer\"><code>empty()</code></a> will return <code>True</code> earlier than expected.</p>\n<p>Okay, so how does the above apply to your example? Let us suppose that in your example, one worker process, having received an item, always has time to insert all items into the underlying buffer in one timeslice (or something like that) immediately, and the next worker process wakes up as soon as the background thread of the previous process finishes inserting one item into the pipe. Then we get that regardless of how many items are left to serialize and write to the pipe, each process immediately empties the pipe and, due to the behavior of the <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty\" rel=\"nofollow noreferrer\"><code>empty()</code></a> method described above, sees that the queue is &quot;empty&quot; (when in fact the background threads simply have not had time to insert items from the buffers yet). This may be caused by some specific process scheduling policy.</p>\n<p>Is this a bug? Answers may vary. But this is definitely not expected behavior, and this point (the asymmetry of <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.qsize\" rel=\"nofollow noreferrer\"><code>qsize()</code></a>/<a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.full\" rel=\"nofollow noreferrer\"><code>full()</code></a> and <a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue.empty\" rel=\"nofollow noreferrer\"><code>empty()</code></a>) should at least be clarified in the documentation.</p>\n<hr />\n<p>Reported as <a href=\"https://github.com/python/cpython/issues/142837\" rel=\"nofollow noreferrer\">python/cpython#142837</a>.</p>\n<p>There are also <a href=\"https://github.com/orgs/python/projects/14/views/1?filterQuery=queue\" rel=\"nofollow noreferrer\">many other issues on GitHub related to multiprocessing queues</a> that you may not be aware of. No code is perfect, so do not be afraid to report issues. Even if they are rarely resolved, your report will at least make the problem known.</p>\n", "tags": ["python", "multithreading", "queue"]}
{"id": "47c3bd7a-8fbc-43df-85c4-f11a0c9e6df6", "text": "Q: What does &quot;%.*s&quot; mean as a format specifier in printf? A: <p>This is a format-specifier, which takes 2 values from the stack, the first is the size, the second the value.</p>\n<p>The <code>.</code>-notation: <code>atleast-length.maxlength</code> (so <code>.*</code> means: max <code>*</code> characters)</p>\n", "tags": ["c"]}
{"id": "6b22ed60-3e52-42a1-8744-5612201a85af", "text": "Q: How do I mask out every bit of a number but a single random one? A: <p>This seems to be all you need:</p>\n<pre><code>u_int16_t setRandomBit(u_int16_tnumber) {\n    int bit_to_set = randomRange(0, __builtin_popcount(number));\n    return number == 0 ? 0 : 1 &lt;&lt; bit_to_set;\n}\n</code></pre>\n", "tags": ["c++", "bit-manipulation"]}
{"id": "9ae9d2cf-1649-4952-88fd-fe3025f674c1", "text": "Q: The useState set method is not reflecting a change immediately A: <p>I am not saying to do this, but it isn't hard to do what the OP asked without useEffect.</p>\n<p>Use a promise to resolve the new state in the body of the setter function:</p>\n<pre class=\"lang-ts prettyprint-override\"><code>const getState = &lt;T&gt;(\n  setState: React.Dispatch&lt;React.SetStateAction&lt;T&gt;&gt;\n): Promise&lt;T&gt; =&gt; {\n  return new Promise((resolve) =&gt; {\n    setState((currentState: T) =&gt; {\n      resolve(currentState);\n      return currentState;\n    });\n  });\n};\n</code></pre>\n<p>And this is how you use it (example shows the comparison between <code>count</code> and <code>outOfSyncCount</code>/<code>syncCount</code> in the UI rendering):</p>\n<pre class=\"lang-tsx prettyprint-override\"><code>const App: React.FC = () =&gt; {\n  const [count, setCount] = useState(0);\n  const [outOfSyncCount, setOutOfSyncCount] = useState(0);\n  const [syncCount, setSyncCount] = useState(0);\n\n  const handleOnClick = async () =&gt; {\n    setCount(count + 1);\n\n    // Doesn't work\n    setOutOfSyncCount(count);\n\n    // Works\n    const newCount = await getState(setCount);\n    setSyncCount(newCount);\n  };\n\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Count = {count}&lt;/h2&gt;\n      &lt;h2&gt;Synced count = {syncCount}&lt;/h2&gt;\n      &lt;h2&gt;Out of sync count = {outOfSyncCount}&lt;/h2&gt;\n      &lt;button onClick={handleOnClick}&gt;Increment&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n", "tags": ["javascript", "reactjs", "react-hooks"]}
{"id": "c59608b1-ce99-4e11-9cdb-370ef4fe2a44", "text": "Q: Publish razor pages to Blazer server hosted in IIS A: <p>I\u2019m leaning towards creating a DataCache shared network folder outside the project but available directly to my app pool service account.  I can synchronize my singleton tables to several csv files. If I introduce load balancing in the future, I can add file timestamps to my synchronization service.</p>\n<p>This seems clunky, but it would be faster than full data loads and will reduce network bandwidth\u2026 at least until I grow beyond a single server.</p>\n", "tags": ["iis", "blazor", "blazor-server-side", "razor-pages"]}
{"id": "e172be86-9c32-4070-af21-c184bc62aff1", "text": "Q: How to create self-signed SSL certificate in pure python? (Without any additional installation like openssl or mkcert) A: <p>I\u2019ve been curious about this myself. I came up with this, with help from Claude Opus. It worked for &quot;trust on first use&quot; server/client setup. It\u2019s slow though, and I wouldn\u2019t use it for production, except maybe as a fallback.</p>\n<pre class=\"lang-py prettyprint-override\"><code>import os\nimport random\nimport hashlib\nimport binascii\nfrom datetime import datetime, timedelta, timezone\n\n# --- CONFIGURATION ---\nKEY_SIZE = 3072\n\nclass TLSCertGenerator:\n    &quot;&quot;&quot;\n    Pure Python TLS Certificate Generator (No external dependencies).\n    &quot;&quot;&quot;\n\n    # --- ASN.1 / DER Helpers ---\n    @staticmethod\n    def _len(length):\n        if length &lt; 128: return bytes([length])\n        b = length.to_bytes((length.bit_length() + 7) // 8, 'big')\n        return bytes([0x80 | len(b)]) + b\n\n    @staticmethod\n    def _seq(*args):\n        c = b''.join(args)\n        return b'\\x30' + TLSCertGenerator._len(len(c)) + c\n\n    @staticmethod\n    def _int(val):\n        # Handle zero specially\n        if val == 0:\n            return b'\\x02\\x01\\x00'\n        b = val.to_bytes((val.bit_length() + 7) // 8, 'big')\n        # ASN.1 DER integers are signed - if high bit is set, prepend 0x00\n        # to indicate positive (otherwise it's interpreted as negative)\n        if b[0] &amp; 0x80:\n            b = b'\\x00' + b\n        return b'\\x02' + TLSCertGenerator._len(len(b)) + b\n\n    @staticmethod\n    def _oid(oid_str):\n        # ASN.1 OID encoder with proper variable-length integer encoding\n        p = [int(x) for x in oid_str.split('.')]\n        # First two components combined: 40*first + second\n        b = bytes([40 * p[0] + p[1]])\n        for v in p[2:]:\n            if v == 0:\n                b += b'\\x00'\n            else:\n                # Variable-length encoding: high bit = continuation flag\n                # Build bytes from low to high, then reverse\n                enc = []\n                while v &gt; 0:\n                    enc.append(v &amp; 0x7F)\n                    v &gt;&gt;= 7\n                # After reversing, continuation bit goes on all but LAST byte\n                # Before reversing: index 0 is lowest, becomes last after reverse\n                # So set continuation on indices 1..n-1 (which become 0..n-2 after reverse)\n                enc = list(reversed(enc))\n                for i in range(len(enc) - 1):\n                    enc[i] |= 0x80\n                b += bytes(enc)\n        return b'\\x06' + TLSCertGenerator._len(len(b)) + b\n\n    @staticmethod\n    def _utf8(s):\n        b = s.encode('utf8')\n        return b'\\x0C' + TLSCertGenerator._len(len(b)) + b # 0x0C = UTF8String\n\n    @staticmethod\n    def _time(dt):\n        s = dt.strftime('%y%m%d%H%M%SZ').encode('ascii')\n        return b'\\x17' + TLSCertGenerator._len(len(s)) + s\n\n    # --- RSA Math ---\n    def _is_prime(self, n, k=5):\n        if n % 2 == 0: return False\n        r, s = 0, n - 1\n        while s % 2 == 0: r += 1; s //= 2\n        for _ in range(k):\n            a = random.randint(2, n - 2)\n            x = pow(a, s, n)\n            if x == 1 or x == n - 1: continue\n            for _ in range(r - 1):\n                x = pow(x, 2, n)\n                if x == n - 1: break\n            else: return False\n        return True\n\n    def _get_prime(self, bits):\n        while True:\n            n = int.from_bytes(os.urandom(bits // 8), 'big') | 1 | (1 &lt;&lt; (bits - 1))\n            if self._is_prime(n): return n\n\n    def _modinv(self, a, m):\n        m0, x0, x1 = m, 0, 1\n        while a &gt; 1:\n            q = a // m\n            m, a = a % m, m\n            x0, x1 = x1 - q * x0, x0\n        if x1 &lt; 0: x1 += m0\n        return x1\n\n    def generate(self, cn=&quot;testtest&quot;, days=3650):\n        print(f&quot;[INFO] Generating {KEY_SIZE}-bit RSA Key (this takes 10-40s)...&quot;)\n\n        # 1. Generate Keys\n        e = 65537\n        # Retry loop to ensure key is never too small\n        while True:\n            p = self._get_prime(KEY_SIZE // 2)\n            q = self._get_prime(KEY_SIZE // 2)\n            n = p * q\n            # CRITICAL: Fedora rejects 2047 bits. Ensure strict length.\n            if n.bit_length() &gt;= KEY_SIZE:\n                break\n\n        phi = (p - 1) * (q - 1)\n        d = self._modinv(e, phi)\n\n        # 2. Build Certificate\n        # OIDs: rsaEncryption, sha256WithRSAEncryption, commonName\n        oid_rsa = self._oid(&quot;1.2.840.113549.1.1.1&quot;)\n        oid_sha256 = self._oid(&quot;1.2.840.113549.1.1.11&quot;)\n        oid_cn = self._oid(&quot;2.5.4.3&quot;)\n\n        # Public Key\n        pk = self._seq(self._int(n), self._int(e))\n        spki = self._seq(self._seq(oid_rsa, b'\\x05\\x00'), b'\\x03' + self._len(len(pk)+1) + b'\\x00' + pk)\n\n        # Name (Issuer &amp; Subject are same)\n        name = self._seq(b'\\x31' + self._len(len(self._seq(oid_cn, self._utf8(cn)))) + self._seq(oid_cn, self._utf8(cn)))\n\n        # Validity\n        now = datetime.now(timezone.utc)\n        validity = self._seq(self._time(now), self._time(now + timedelta(days=days)))\n\n        # TBS (To Be Signed)\n        tbs = self._seq(\n            b'\\xA0\\x03' + self._int(2), # v3\n            self._int(random.getrandbits(64)), # Serial\n            self._seq(oid_sha256, b'\\x05\\x00'), # Algo\n            name, validity, name, spki\n        )\n\n        # 3. Sign\n        h = hashlib.sha256(tbs).digest()\n        # PKCS#1 v1.5 Padding\n        prefix = b'\\x30\\x31\\x30\\x0d\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x02\\x01\\x05\\x00\\x04\\x20'\n        pad_len = (n.bit_length() + 7) // 8 - len(prefix) - len(h) - 3\n        padded = b'\\x00\\x01' + (b'\\xff' * pad_len) + b'\\x00' + prefix + h\n        sig = pow(int.from_bytes(padded, 'big'), d, n)\n        sig_b = sig.to_bytes((n.bit_length() + 7) // 8, 'big')\n\n        full_cert = self._seq(tbs, self._seq(oid_sha256, b'\\x05\\x00'), b'\\x03' + self._len(len(sig_b)+1) + b'\\x00' + sig_b)\n\n        # 4. PEM Encoding\n        def to_pem(tag, data):\n            b64 = binascii.b2a_base64(data, newline=True).decode()\n            return f&quot;-----BEGIN {tag}-----\\n{b64}-----END {tag}-----\\n&quot;\n\n        # Private Key Structure (Minimal PKCS#1)\n        # Seq(0, n, e, d, p, q, d%p-1, d%q-1, qinv)\n        dp, dq, qinv = d % (p-1), d % (q-1), self._modinv(q, p)\n        priv = self._seq(self._int(0), self._int(n), self._int(e), self._int(d), self._int(p), self._int(q), self._int(dp), self._int(dq), self._int(qinv))\n\n        return to_pem(&quot;RSA PRIVATE KEY&quot;, priv), to_pem(&quot;CERTIFICATE&quot;, full_cert)\n\n# --- Usage Example ---\nif __name__ == &quot;__main__&quot;:\n    if not os.path.exists(&quot;key.pem&quot;):\n        gen = TLSCertGenerator()\n        key_pem, cert_pem = gen.generate(cn=&quot;testtest&quot;)\n\n        with open(&quot;key.pem&quot;, &quot;w&quot;) as f: f.write(key_pem)\n        with open(&quot;cert.pem&quot;, &quot;w&quot;) as f: f.write(cert_pem)\n        os.chmod(&quot;key.pem&quot;, 0o600)\n        print(&quot;[SUCCESS] New valid 3072-bit certificates generated.&quot;)\n    else:\n        print(&quot;Certificates already exist.&quot;)\n</code></pre>\n", "tags": ["python", "django", "ssl", "self-signed", "self-signed-certificate"]}
{"id": "ce96a84c-37e5-4196-adf2-49be3f8efdac", "text": "Q: SQL Server Stored Procedure passed a Biztalk XML message not returning field values when parsing the XML text A: <ul>\n<li>Those backslashes in your XPath expressions (by the square-brackets) shouldn't be there.</li>\n<li>The XPath syntax for an XML Element's <code>#text</code> node is <code>/text()</code>, not <code>/text</code>.</li>\n<li>You'll need to repeat the root element's name in the <code>.value()</code> XPath expressions (see <code>'(/ns0:HHN_MohCTOrder/ns0:MessageID/text())[1]'</code>).\n<ul>\n<li>Or remove the leading <code>/</code> slash (see <code>'(ns0:VisitNo/text())[1]'</code>).</li>\n</ul>\n</li>\n<li>I don't recommend re-using an <code>XMLNAMESPACE</code> name as a column-name; it's also always a good idea to fully-qualify T-SQL names (So in this example, I've renamed the column to <code>col0</code> and used <code>t</code> as the relation (virtual-table)'s alias).</li>\n<li>Extra line-breaks added for readability, but they don't affect parsing or behaviour.</li>\n</ul>\n<p>Like so:</p>\n<pre><code>DECLARE @xml xml = '&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;ns0:HHN_MohCTOrder\n    xmlns:ns0=&quot;http://schemas.microsoft.com/Sql/2008/05/Procedures/dbo&quot;\n    xmlns:ns3=&quot;http://schemas.datacontract.org/2004/07/System.Data&quot;\n&gt;\n    &lt;ns0:MessageID&gt;1757928831507&lt;/ns0:MessageID&gt;\n    &lt;ns0:CTDateTime&gt;20250915063351&lt;/ns0:CTDateTime&gt;\n    &lt;ns0:VisitNo&gt;DP000013/25&lt;/ns0:VisitNo&gt;\n    &lt;ns0:AccessionNo&gt;CT2509140001&lt;/ns0:AccessionNo&gt;\n&lt;/ns0:HHN_MohCTOrder&gt;';\n\n/* =============== */\n\nWITH XMLNAMESPACES(\n    'http://schemas.microsoft.com/Sql/2008/05/Procedures/dbo' AS ns0\n)\n    SELECT\n        t.col0.value( '(/ns0:HHN_MohCTOrder/ns0:MessageID/text())[1]'  ,'varchar(13)' ) MessageID,\n        t.col0.value( '(/ns0:HHN_MohCTOrder/ns0:CTDateTime/text())[1]' ,'varchar(14)' ) CTDateTime,\n        t.col0.value( '(ns0:VisitNo/text())[1]'                        ,'varchar(12)' ) VisitNo,\n        t.col0.value( '(ns0:AccessionNo/text())[1]'                    ,'varchar(12)' ) AccessionNo\n    FROM\n        @xml.nodes('(/ns0:HHN_MohCTOrder)[1]') AS t( col0 );\n</code></pre>\n<p>...which gives me this output:</p>\n<pre><code>MessageID       CTDateTime       VisitNo        AccessionNo\n1757928831507   20250915063351   DP000013/25    CT2509140001 \n</code></pre>\n", "tags": ["sql-server", "xml", "t-sql", "stored-procedures", "biztalk"]}
{"id": "00dc82a5-aca6-4548-a848-02799e93f750", "text": "Q: Can a system call happen in a C program? A: <h3>System call background</h3>\n<p>A system call, according to <a href=\"https://en.wikipedia.org/wiki/System_call\" rel=\"nofollow noreferrer\">Wikipedia</a>, is a &quot;programmatic way in which a computer program requests a service from the kernel of the operating system on which it is executed&quot;.</p>\n<p>Another way of understanding a system call is as a <a href=\"https://en.wikipedia.org/wiki/User_space\" rel=\"nofollow noreferrer\">user space</a> program making a request to the <a href=\"https://en.wikipedia.org/wiki/Kernel_(operating_system)\" rel=\"nofollow noreferrer\">operating system kernel</a> to perform some task on behalf of the user space program. The full set of system calls provided by the kernel is analogous (in some ways) to an API provided by the kernel to user space.</p>\n<p>As system calls are a low level interface to the kernel, correctly providing their arguments can be error prone or even dangerous. For these reasons, C library authors provide simpler and safer wrapper functions for a significant portion of a kernel's set of system calls.</p>\n<p>These wrapper functions take a simplified argument set and then derive the appropriate values to pass on to the kernel so the system call can be executed.</p>\n<h3>Example</h3>\n<p><strong>Note</strong>: This example is based on compiling and running a C program with <code>gcc</code> on Linux. The system calls, library functions, and output may differ on other POSIX or non-POSIX operating systems.</p>\n<p>I will attempt to show how to see when system calls are being made with a simple example.</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n\nint main() {\n    write(1, &quot;Hello world!\\n&quot;, 13);\n}\n</code></pre>\n<p>Above we have a very simple C program that writes the string <code>Hello world!\\n</code> to <code>stdout</code>. If we compile and then execute this program with <a href=\"https://man7.org/linux/man-pages/man1/strace.1.html\" rel=\"nofollow noreferrer\"><code>strace</code></a>, we see the following (note the output may look different on other computers):</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ strace ./hello &gt; /dev/null\nexecve(&quot;./hello&quot;, [&quot;./hello&quot;], 0x7fff083a0630 /* 58 vars */) = 0\n&lt;a bunch of output we aren't interested in&gt;\nwrite(1, &quot;Hello world!\\n&quot;, 13)          = 13\nexit_group(0)                           = ?\n+++ exited with 0 +++\n</code></pre>\n<p><code>strace</code> is a Linux program that intercepts and displays all system calls made by a program, as well as the arguments provided to the system calls and their return values.</p>\n<p>We can see here that, as expected, the <code>write</code> system call was made with the expected arguments. Nothing strange yet.</p>\n<p>Another Linux tracing program is <a href=\"https://man7.org/linux/man-pages/man1/ltrace.1.html\" rel=\"nofollow noreferrer\"><code>ltrace</code></a>, which intercepts dynamic library calls made by a program, and displays their arguments and return values.</p>\n<p>If we run the same program with <code>ltrace</code>, we see this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ ltrace ./hello &gt; /dev/null\nwrite(1, &quot;Hello world!\\n&quot;, 13)                                = 13\n+++ exited (status 0) +++\n</code></pre>\n<p>This tells us that the <code>write</code> library function was executed. This means that the C code first called the <code>write</code> library function, which then in turn called the <code>write</code> system call.</p>\n<p>Suppose now that we want to explicitly make a <code>write</code> system call without calling the <code>write</code> library function. (This is inadvisable in normal use, but useful for illustration.)</p>\n<p>Here is the new code:</p>\n<pre class=\"lang-c prettyprint-override\"><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main() {\n    syscall(SYS_write, 1, &quot;Hello world!\\n&quot;, 13);\n}\n</code></pre>\n<p>Here we directly call the <a href=\"https://man7.org/linux/man-pages/man2/syscall.2.html\" rel=\"nofollow noreferrer\"><code>syscall</code></a> library function, telling it we want to execute the <code>write</code> system call.</p>\n<p>After recompiling, here is the output of <code>strace</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ strace ./hello &gt; /dev/null \nexecve(&quot;./hello&quot;, [&quot;./hello&quot;], 0x7ffe3790a660 /* 58 vars */) = 0\n&lt;a bunch of output we aren't interested in&gt;\nwrite(1, &quot;Hello world!\\n&quot;, 13)          = 13\nexit_group(0)                           = ?\n+++ exited with 0 +++\n</code></pre>\n<p>We can see the <code>write</code> system call is made as before as expected.</p>\n<p>If we run <code>ltrace</code> we see the following:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ ltrace ./hello &gt; /dev/null \nsyscall(1, 1, 0x560b30e4d704, 13)                             = 13\n+++ exited (status 0) +++\n</code></pre>\n<p>So the <code>write</code> library function is no longer being called, but we are still making a library function call. Now we are making a call to the <code>syscall</code> library function instead of the <code>write</code> library function.</p>\n<p>It is possible to directly make a system call from a user space C program without calling any library functions, but this is an advanced technique. For details, see <a href=\"https://www.youtube.com/watch?v=IbibjkI1kIs\" rel=\"nofollow noreferrer\">this video</a>, starting at <a href=\"https://youtu.be/IbibjkI1kIs?t=1480\" rel=\"nofollow noreferrer\">24:40</a>.</p>\n<h3>Detecting when a C program makes system calls</h3>\n<p>In general, nearly every non-trivial C program makes at least one system call. This is because user space does not have direct access to kernel memory or to the computer's hardware. User space programs have indirect access to kernel memory and the hardware through system calls.</p>\n<p>To identify if a compiled C program (or any other program on Linux) makes a system call, and to identify which system calls it makes, simply use <code>strace</code>.</p>\n<h3>Are there compiler options to prevent calling the library wrapper functions for system calls?</h3>\n<p>You can compile your C program (assuming you are using <code>gcc</code>) with the <code>-nostdlib</code> option. This will prevent linking the C standard library as part of producing your executable. However, then you would need to write your own code to make system calls.</p>\n", "tags": ["c", "function", "system-calls", "libc"]}
{"id": "7ff0f854-a522-419e-8dd3-e22cb8038592", "text": "Q: Ensuring specialization while preventing inlining A: <p>Why This Works Well</p>\n<ol>\n<li><p><strong><code>INLINABLE</code></strong>: Allows specialization at call sites for specific <code>k</code> types</p>\n</li>\n<li><p><strong>Fast path first</strong>: Checks bitmaps before iterating (hot/cold separation)</p>\n</li>\n<li><p><strong>Helper has <code>NOINLINE</code></strong>: <code>leafInArray</code> won't bloat the main function</p>\n</li>\n<li><p><strong>Still specialized</strong>: Each <code>k</code> type gets optimized equality checks</p>\n</li>\n</ol>\n<p>Option 1: <code>NOINLINE</code> with Worker-Wrapper</p>\n<pre><code>{-# NOINLINE disjointCollisions #-}\ndisjointCollisions :: Eq k =&gt; Word -&gt; Array (Leaf k a) -&gt; Word -&gt; Array (Leaf k b) -&gt; Bool\ndisjointCollisions bitmap1 arr1 bitmap2 arr2 =\n    go 0\n  where\n    go !i\n        | i &gt;= n1 = True\n        | otherwise = case arr1 `A.index` i of\n            Leaf h1 k1 _ -&gt; not (collides h1 k1) &amp;&amp; go (i + 1)\n    \n    collides h1 k1 = ...  -- Check if collides with anything in arr2\n    \n    n1 = A.length arr1\n</code></pre>\n<p>Option 2: Use INLINABLE but Control Inlining Elsewhere</p>\n<pre><code>{-# INLINABLE disjointCollisions #-}\ndisjointCollisions :: Eq k =&gt; Word -&gt; Array (Leaf k a) -&gt; Word -&gt; Array (Leaf k b) -&gt; Bool\n\n-- In the calling function:\ndisjointSubtrees :: Eq k =&gt; ... -&gt; ...\ndisjointSubtrees = ...\n  where\n    checkCollisions = disjointCollisions  -- Give it a name to control inlining\n    {-# NOINLINE checkCollisions #-}\n</code></pre>\n<p>Recommended Solution Based on HAMT Patterns</p>\n<p>For hash map collision checks, I recommend:</p>\n<pre><code>{-# INLINEABLE disjointCollisions #-}\ndisjointCollisions :: Eq k =&gt; Word -&gt; Array (Leaf k a) -&gt; Word -&gt; Array (Leaf k b) -&gt; Bool\ndisjointCollisions bitmap1 arr1 bitmap2 arr2\n    | bitmap1 .&amp;. bitmap2 == 0 = True  -- Fast path: no overlapping bits\n    | otherwise = go 0\n  where\n    go !i\n        | i &gt;= n1 = True\n        | testBit bitmap2 (hashIndex h1) = \n            case leafInArray h1 k1 arr2 of\n                Nothing -&gt; go (i + 1)\n                Just _  -&gt; False\n        | otherwise = go (i + 1)\n      where\n        Leaf h1 k1 _ = arr1 `A.index` i\n    \n    n1 = A.length arr1\n    hashIndex h = fromIntegral (h .&amp;. 0x1F)  -- For 32-bit mask\n\n{-# NOINLINE leafInArray #-}\nleafInArray :: Eq k =&gt; Word -&gt; k -&gt; Array (Leaf k b) -&gt; Maybe (Leaf k b)\nleafInArray targetHash targetKey arr = ...\n</code></pre>\n", "tags": ["haskell", "ghc", "inlining"]}
{"id": "52de80d1-9f85-4c6f-ac6f-278a9e63eb53", "text": "Q: View model vs bloc in Flutter A: <p>Could you please have a look at this link? It might provide some useful information. Clean Architecture in Flutter | MVVM | BloC | Dio =&gt; <a href=\"https://medium.com/@yamen.abd98/clean-architecture-in-flutter-mvvm-bloc-dio-79b1615530e1\" rel=\"nofollow noreferrer\">https://medium.com/@yamen.abd98/clean-architecture-in-flutter-mvvm-bloc-dio-79b1615530e1</a></p>\n", "tags": ["flutter", "mvvm", "viewmodel", "bloc"]}
