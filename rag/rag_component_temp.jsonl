{"id": "c65ab6ce-c3e8-4324-98d5-244618506af7", "text": "Q: Sgahsttsjw b\u1eadn hsiwkk A: <p>What are you talking about? What is your question?</p>\n", "tags": ["jetty-httpclient"]}
{"id": "c1a153ee-44d8-42d6-a385-45bfa6036aa9", "text": "Q: Why would one reset local variables at the end of a C function? A: <p>Apparently you are right, if you have a function, a local variable is created and the function ends, then your variables are indeed getting out of scope. However, it looks like the author worried about their values still being unchanged someplace in memory and even though the variables no longer exist, their values are still unchanged at the memory location they were located at. So if somehow a hacker finds a reliable way to localize those unreferenced, but unchanged locations in memory, then referring to them later on may get the information leaked. It is also important what the function actually does, at the section you marked at</p>\n<pre><code>[LOTS OF SIMILAR STATEMENTS REMOVED FOR READABILITY]\n</code></pre>\n<p>and before and after that. If these variables are being passed by address someplace, then it is possible that helper functions are storing their address someplace that can be reached even after the function returns, in which case, reaching out to those goodies one may be able to get the values at that address, even though there is no variable addressing them anymore.</p>\n<p>So the questions you need to ask yourself of are:</p>\n<ol>\n<li>Do I need to do this micro-optimization, do I really have a performance issue whose fix would be this? (removing the resets)</li>\n<li>How secure the values should be? Are they top-secret I am willing to protect from eager hackers, what is the security implication if that sha1 gets partially or entirely leaked?</li>\n</ol>\n<p>Likely your answer to 1 is &quot;no&quot; and to 2 is &quot;I need security&quot;. Hence, you need protection even of the no longer referenced values and hence it is smart to remove it, as the best security that can be offered here for those values is their nonexistent not only as variables, but as address too.</p>\n", "tags": ["c", "hash", "cryptography", "hmacsha1"]}
{"id": "f24cda88-c07a-4ecc-9569-ce13782c4ba5", "text": "Q: Trying to create function that would compare my age to somebody else&#39;s age A: <div class=\"s-table-container\"><table class=\"s-table\">\n<thead>\n<tr>\n<th>header 1</th>\n<th>header 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>cell 1</td>\n<td>cell 2</td>\n</tr>\n<tr>\n<td>cell 3</td>\n<td>cell 4</td>\n</tr>\n</tbody>\n</table></div>\n", "tags": ["javascript", "algorithm", "function", "compare"]}
{"id": "3d211c51-0a42-4f79-8fbe-48d405030a0e", "text": "Q: Is it possible to use random IV for each ts segment when ffmpeg do hls encrypt? A: <p>Add <code>periodic_rekey</code> to <code>-hls_flags</code> like below, which will make ffmpeg to recheck the key each segment.</p>\n<pre><code>independent_segments+periodic_rekey\n</code></pre>\n<p>So there is a trick to make it work, run another process to refresh the IV in the keyinfo.txt.</p>\n<p>For example: (Note: refresh per second may be too slow, which will result more than one segment use the same IV, you can refresh more frequently to make each segemnt an IV)</p>\n<pre><code>while true\ndo\nrandom_hex=$(openssl rand -hex 16)\nsed -i &quot;3s/.*/$random_hex/&quot; keyinfo.txt\nsleep 1\ndone\n</code></pre>\n<p><a href=\"https://i.sstatic.net/M6EEC4ep.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/M6EEC4ep.png\" alt=\"enter image description here\" /></a></p>\n", "tags": ["encryption", "video", "ffmpeg", "http-live-streaming", "m3u8"]}
{"id": "360ea6cc-21cb-45b8-85ae-9ee70c015ecc", "text": "Q: Is the Forge Model Upgrader Example Deprecated? A: <p><strong>yes, the Forge Model Upgrader example is effectively deprecated</strong>, even if it\u2019s not always clearly labeled as such in the documentation.</p>\n<p>The example you\u2019re referring to was created for an <strong>older Forge workflow and data model</strong>. Since then, Forge has gone through multiple structural and API-level changes, including:</p>\n<ul>\n<li><p>Updated model formats</p>\n</li>\n<li><p>New upgrade/migration paths</p>\n</li>\n<li><p>Changes in how metadata and versioning are handled</p>\n</li>\n</ul>\n<p>Because of that, the original <em>Model Upgrader</em> example no longer reflects the recommended or supported way to handle model upgrades today.</p>\n<hr />\n<h3>Why it\u2019s considered deprecated</h3>\n<ul>\n<li><p>The example relies on <strong>legacy Forge SDK patterns</strong></p>\n</li>\n<li><p>It assumes older version-to-version transitions that are no longer relevant</p>\n</li>\n<li><p>Some referenced classes or methods no longer exist or behave differently</p>\n</li>\n<li><p>Newer Forge tooling favors <strong>rebuilding or re-exporting models</strong> rather than upgrading them in place</p>\n</li>\n</ul>\n<p>In practice, Autodesk has moved away from maintaining that example, even though it may still appear in older repos or blog posts.</p>\n<hr />\n<h3>What to do instead</h3>\n<p>The recommended approach today is:</p>\n<ol>\n<li><p><strong>Re-export or regenerate models</strong> using the current Forge APIs</p>\n</li>\n<li><p>Handle version differences at the <strong>application logic level</strong>, not via a dedicated upgrader</p>\n</li>\n<li><p>Avoid relying on legacy upgrade examples for production systems</p>\n</li>\n</ol>\n<p>This is also what most modern Forge-based tools do. For example, when validating and comparing Forge-related data flows for calculation and analysis (similar to what we do when verifying outputs for tools like <a href=\"https://theforgecalculators.com/\" rel=\"nofollow noreferrer\">https://theforgecalculators.com/</a>), rebuilding against the current schema is far more reliable than attempting to upgrade legacy models.</p>\n<hr />\n<h3>Summary</h3>\n<ul>\n<li><p>The Forge Model Upgrader example is outdated</p>\n</li>\n<li><p>It\u2019s no longer aligned with current Forge APIs</p>\n</li>\n<li><p>Treat it as deprecated, even if it\u2019s still accessible</p>\n</li>\n<li><p>Rebuild or migrate using current tooling instead</p>\n</li>\n</ul>\n<p>If you\u2019re working on a new Forge integration, you\u2019re better off ignoring that example entirely and starting from the latest SDK documentation.</p>\n", "tags": ["autodesk-forge"]}
{"id": "d119bb08-9200-4c07-89ee-5a57c1b70042", "text": "Q: Pure Type Punning In C A: <p>The line</p>\n<pre class=\"lang-c prettyprint-override\"><code>short data = *(short*)(page+6);\n</code></pre>\n<p>will invoke undefined behavior due to violating the <a href=\"https://stackoverflow.com/q/98650/12149471\">strict aliasing rule</a>, because the bytes stored at <code>page[6]</code> and <code>page[7]</code> have the &quot;effective type&quot; <code>char</code>, so you are not allowed read them by dereferencing a pointer to <code>short</code>. These bytes have the &quot;effective type&quot; <code>char</code> because <a href=\"https://www.iso-9899.info/n3220.html#6.5.1p6\" rel=\"nofollow noreferrer\">\u00a76.5.1 \u00b66 sentence 3 of the N3220 draft of the C23 standard</a> states the following:</p>\n<blockquote>\n<p>If a value is copied into an object having no declared type using memcpy or memmove, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one.</p>\n</blockquote>\n<p>The proper way to read these byte values as a <code>short</code> is the following:</p>\n<pre class=\"lang-c prettyprint-override\"><code>short data;\n\nmemcpy( &amp;data, page + 6, sizeof data );\n</code></pre>\n<p>As far as I can tell, this is the only strict aliasing violation in your code. Reading the first four bytes as an <code>int</code> is not a problem, because that is the &quot;effective type` of the first four bytes.</p>\n<p>The line</p>\n<pre class=\"lang-c prettyprint-override\"><code>*(short*)(page+6) = 0x7777;\n</code></pre>\n<p>is well-defined, because you are writing, not reading, so this will change the &quot;effective type&quot; of the bytes <code>page[6]</code> and <code>page[7]</code> from <code>char</code> to <code>short</code>.</p>\n<p>If you want to ensure that your code works despite violating the strict aliasing rule, then, if you are using the compilers GCC or Clang, you can compile with the <code>-fno-strict-aliasing</code> command-line option. This will prevent your compiler from making optimizations that rely on the strict aliasing rule, which may reduce performance, but will ensure that your code behaves correctly even when violating the strict aliasing rule.</p>\n<hr />\n<p>In the comments section of this answer, it is claimed that my answer above is wrong, because a string literal does not have a &quot;declared type&quot;. I tend to disagree with this statement, for the following reason:</p>\n<p>Although the C standard uses the term &quot;declared type&quot;, it does not define this term.</p>\n<p><a href=\"https://www.iso-9899.info/n3220.html#6.4.5p6\" rel=\"nofollow noreferrer\">\u00a76.4.5 \u00b66 sentence 3 of the N3220 draft of the C23 standard</a> states the following:</p>\n<blockquote>\n<p>For character string literals, the array elements have type char</p>\n</blockquote>\n<p>So the standard explicitly states that all elements of a string literal are of type <code>char</code>. In my opinion, this implies that the &quot;declared type&quot; of the array elements is <code>char</code>.</p>\n<p>According to the (non-normative) <a href=\"https://www.iso-9899.info/n3220.html#FOOTNOTE.84\" rel=\"nofollow noreferrer\">footnote #84 of N3220</a>, allocated objects have no declared type. It does not say whether string literals have a declared type or not.</p>\n", "tags": ["c", "pointers", "gcc"]}
