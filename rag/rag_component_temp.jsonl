{"id": "2fbbe98e-b0ba-4447-97f7-8bd886244353", "text": "Q: Determining Runs per Day A: <h2><em>java.time</em></h2>\n<p>In modern Java, use the <em>java.time</em> classes for all your date-time work.</p>\n<h2>Problem statement</h2>\n<p>Apparently you want to detect episodes from the current moment until the first moment of tomorrow.</p>\n<p>Let's write a method <code>calculateEpisodesForToday</code>. Pass a collection of the minutes you want to target. And pass the time zone through which you want to view the day.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static SequencedCollection &lt; ZonedDateTime &gt; calculateEpisodesForToday\n        (\n                final SequencedCollection &lt; Integer &gt; theMinutes ,\n                final ZoneId theZoneId\n        )\n{ \u2026 }\n</code></pre>\n<h3>Validate inputs</h3>\n<p>Let's validate the inputs. Perform a null-check (in real work, use <a href=\"https://jspecify.dev/\" rel=\"nofollow noreferrer\">JSpecify</a>). Run through the collection of minutes to be sure they are valid values of 0-59, then delete duplicates, and lastly sort.</p>\n<pre class=\"lang-java prettyprint-override\"><code>// Validate inputs.\nObjects.requireNonNull( theMinutes );\nObjects.requireNonNull( theZoneId );\nfinal List &lt; Integer &gt; minutes =\n        theMinutes\n                .stream()\n                .filter( ( Integer minute ) -&gt; ( minute &gt;= 0 ) &amp;&amp; ( minute &lt;= 59 ) ) // 0-59 are the 60 minutes of an hour.\n                .distinct()\n                .sorted()\n                .toList();\nif ( minutes.isEmpty() ) return List.of();\n</code></pre>\n<h3>Current moment</h3>\n<p>Capture the current moment as seen in the specified time zone. From that, determine the first moment of tomorrow. Always let <em>java.time</em> determine the first moment of the day. Do not assume the day starts at 00:00, as that is not the case for some dates in some zones.</p>\n<pre class=\"lang-java prettyprint-override\"><code>final ZonedDateTime now = ZonedDateTime.now( theZoneId );\nZonedDateTime startOfTomorrow = now.toLocalDate().plusDays( 1 ).atStartOfDay( theZoneId );\n</code></pre>\n<h3>Collect results</h3>\n<p>Prepare an empty collection into which we will deposit our produced episodes.</p>\n<pre class=\"lang-java prettyprint-override\"><code>ArrayList &lt; ZonedDateTime &gt; episodes = new ArrayList &lt;&gt;();\n</code></pre>\n<h3>Process each hour of the clock</h3>\n<p>Our approach is to work with each clock hour, one at a time. For each hour, we run through our collection of minutes. For each minute, we produce a moment with today's date. If the result meets our criteria (later than now, earlier than tomorrow), we deposit.</p>\n<pre class=\"lang-java prettyprint-override\"><code>// Truncate to the current hour. Start checking there.\nZonedDateTime currentHour = now.truncatedTo( java.time.temporal.ChronoUnit.HOURS );\n\n// Work with one clock hour at a time.\nwhile ( currentHour.isBefore( startOfTomorrow ) )\n{\n    // For each allowed minute in this hour, create a candidate moment.\n    for ( int minute : minutes )\n    {\n        ZonedDateTime candidate = currentHour.withMinute( minute ).withSecond( 0 ).withNano( 0 );\n\n        // Keep only if this moment is after now AND before tomorrow.\n        if ( candidate.isAfter( now ) &amp;&amp; candidate.isBefore( startOfTomorrow ) )\n        {\n            episodes.add( candidate );\n        }\n    }\n    // Move to the next hour\n    currentHour = currentHour.plusHours( 1 );\n}\n</code></pre>\n<h2>Package results</h2>\n<p>Finally, we return our sequenced collection of moments. As a general habit, we return an unmodifiable collection (<a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/List.html#copyOf(java.util.Collection)\" rel=\"nofollow noreferrer\"><code>List.copyOf</code></a>) of the most general (highest level) interface that is practical (<a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/SequencedCollection.html\" rel=\"nofollow noreferrer\"><code>SequencedCollection</code></a> in this case).</p>\n<pre class=\"lang-java prettyprint-override\"><code>return List.copyOf( episodes );\n</code></pre>\n<p>When run:</p>\n<pre class=\"lang-none prettyprint-override\"><code>2025-12-11T15:32-07:00[America/Edmonton]\n2025-12-11T15:48-07:00[America/Edmonton]\n2025-12-11T16:16-07:00[America/Edmonton]\n2025-12-11T16:32-07:00[America/Edmonton]\n2025-12-11T16:48-07:00[America/Edmonton]\n2025-12-11T17:16-07:00[America/Edmonton]\n2025-12-11T17:32-07:00[America/Edmonton]\n2025-12-11T17:48-07:00[America/Edmonton]\n2025-12-11T18:16-07:00[America/Edmonton]\n2025-12-11T18:32-07:00[America/Edmonton]\n2025-12-11T18:48-07:00[America/Edmonton]\n2025-12-11T19:16-07:00[America/Edmonton]\n2025-12-11T19:32-07:00[America/Edmonton]\n2025-12-11T19:48-07:00[America/Edmonton]\n2025-12-11T20:16-07:00[America/Edmonton]\n2025-12-11T20:32-07:00[America/Edmonton]\n2025-12-11T20:48-07:00[America/Edmonton]\n2025-12-11T21:16-07:00[America/Edmonton]\n2025-12-11T21:32-07:00[America/Edmonton]\n2025-12-11T21:48-07:00[America/Edmonton]\n2025-12-11T22:16-07:00[America/Edmonton]\n2025-12-11T22:32-07:00[America/Edmonton]\n2025-12-11T22:48-07:00[America/Edmonton]\n2025-12-11T23:16-07:00[America/Edmonton]\n2025-12-11T23:32-07:00[America/Edmonton]\n2025-12-11T23:48-07:00[America/Edmonton]\n</code></pre>\n<h3>Full code</h3>\n<p>For your copy-paste convenience:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package work.basil.example;\n\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.SequencedCollection;\n\npublic class EpisodesLeftInToday\n{\n    static void main ( )\n    {\n        SequencedCollection &lt; ZonedDateTime &gt; episodes = EpisodesLeftInToday.calculateEpisodesForToday( List.of( 16 , 32 , 48 ) , ZoneId.of( &quot;America/Edmonton&quot; ) );\n        episodes.forEach( IO :: println );\n    }\n\n    public static SequencedCollection &lt; ZonedDateTime &gt; calculateEpisodesForToday\n            (\n                    final SequencedCollection &lt; Integer &gt; theMinutes ,\n                    final ZoneId theZoneId\n            )\n    {\n        // Validate inputs.\n        Objects.requireNonNull( theMinutes );\n        Objects.requireNonNull( theZoneId );\n        final List &lt; Integer &gt; minutes =\n                theMinutes\n                        .stream()\n                        .filter( ( Integer minute ) -&gt; ( minute &gt;= 0 ) &amp;&amp; ( minute &lt;= 59 ) ) // 0-59 are the 60 minutes of an hour.\n                        .distinct()\n                        .sorted()\n                        .toList();\n        if ( minutes.isEmpty() ) return List.of();\n\n        final ZonedDateTime now = ZonedDateTime.now( theZoneId );\n        ZonedDateTime startOfTomorrow = now.toLocalDate().plusDays( 1 ).atStartOfDay( theZoneId );\n\n        ArrayList &lt; ZonedDateTime &gt; episodes = new ArrayList &lt;&gt;();\n\n        // Truncate to the current hour. Start checking there.\n        ZonedDateTime currentHour = now.truncatedTo( java.time.temporal.ChronoUnit.HOURS );\n\n        // Work with one clock hour at a time.\n        while ( currentHour.isBefore( startOfTomorrow ) )\n        {\n            // For each allowed minute in this hour, create a candidate moment.\n            for ( int minute : minutes )\n            {\n                ZonedDateTime candidate = currentHour.withMinute( minute ).withSecond( 0 ).withNano( 0 );\n\n                // Keep only if this moment is after now AND before tomorrow.\n                if ( candidate.isAfter( now ) &amp;&amp; candidate.isBefore( startOfTomorrow ) )\n                {\n                    episodes.add( candidate );\n                }\n            }\n            // Move to the next hour\n            currentHour = currentHour.plusHours( 1 );\n        }\n\n        return List.copyOf( episodes );\n    }\n}\n</code></pre>\n", "tags": ["java"]}
{"id": "6b4c0993-89d6-4739-af95-c611533f7b4d", "text": "Q: Please check your firewall rules and network connection then try again. Error Code: CERT_HAS_EXPIRED A: <p>on MacOS go to System Settings -&gt; Network -&gt; VPN &amp; Filters<br />\nand disable content filters.<br />\nworked for me.</p>\n", "tags": ["visual-studio-code", "github", "github-copilot"]}
{"id": "245fb1ca-ac03-4dc2-b15d-ab835c212b62", "text": "Q: My custom antd button is not working for color=&quot;primary&quot; and variant=&quot;text&quot; A: <p>I think this part is problematic.</p>\n<pre><code>const button = &lt;AntdButton color={color === 'error' ? &quot;danger&quot; : &quot;primary&quot;} {...rest}&gt;\n</code></pre>\n<p>You're always overriding color to <em><strong>&quot;primary&quot;</strong></em> (or <em><strong>&quot;danger&quot;</strong></em>), so when the user passes <em><strong>color=&quot;primary&quot;</strong></em> with <em><strong>variant=&quot;text&quot;</strong></em>, the native antd behavior doesn't work because you're not passing through the original value correctly.</p>\n<pre class=\"lang-jsx prettyprint-override\"><code>import React from &quot;react&quot;;\nimport { Button as AntdButton, theme, ConfigProvider } from &quot;antd&quot;;\nimport PropTypes from &quot;prop-types&quot;;\n\nexport const Button = ({ color, children, ...rest }) =&gt; {\n    const { token } = theme.useToken();\n\n    const colorMap = {\n        success: token.colorSuccess,\n        warning: token.colorWarning,\n        info: token.colorInfo,\n        error: token.colorError,\n        secondary: &quot;#3577f1&quot;,\n    };\n\n    const customColor = colorMap[color];\n    \n    // Only override color when using custom colors, otherwise pass through\n    const antdColor = color === &quot;error&quot; \n        ? &quot;danger&quot; \n        : customColor \n            ? &quot;primary&quot;  // custom colors use primary + ConfigProvider override\n            : color;     // native colors (primary, default, danger) pass through\n\n    const button = (\n        &lt;AntdButton color={antdColor} {...rest}&gt;\n            {children}\n        &lt;/AntdButton&gt;\n    );\n\n    return customColor ? (\n        &lt;ConfigProvider theme={{ token: { colorPrimary: customColor } }}&gt;\n            {button}\n        &lt;/ConfigProvider&gt;\n    ) : (\n        button\n    );\n};\n</code></pre>\n", "tags": ["reactjs", "button", "antd"]}
{"id": "ca47fdad-23db-4dca-9e9d-a92fc357a9d0", "text": "Q: Passport-Local-Mongoose Local Strategy causes infinite loop when trying to log in A: <p>It appears that the issue is related to version 9.0.0 of passport-local-mongoose and its authenticate() method. Upgrading to version 9.0.1 or downgrading to version 8 or earlier resolves the problem.</p>\n", "tags": ["node.js", "passport.js", "passport-local", "passport-local-mongoose"]}
{"id": "c3064ec5-5283-42de-ae8f-dc37335b2325", "text": "Q: How to recursively populate a hierarchical structure from a CodeIgniter query result A: <p>You are not implementing OOP syntax. You are calling your method as if it is a function. In this context, to call class methods within the class, you must pretend <code>$this-&gt;</code>.</p>\n<p>You don't not need two methods for this task. If you want to default to 0 (the top level parent), declare that in the method signature. Call from your controller like this: <code>$tree = $this-&gt;Model-&gt;getTree();</code></p>\n<pre class=\"lang-php prettyprint-override\"><code>public function getTree(int $parentId = 0): array\n{\n    $rows = $this-&gt;db\n        -&gt;order_by('OfID')\n        -&gt;get_where('college', ['OfID' =&gt; $parentId])\n        -&gt;result();\n\n    $tree = [];\n    foreach ($rows as $row) {\n        $row-&gt;children ??= [];\n        array_push(\n            $row-&gt;children,\n            ...$this-&gt;getTree($row-&gt;id)\n        );\n        $tree[] = $row;\n    }\n    return $tree;\n}\n</code></pre>\n", "tags": ["php", "codeigniter", "recursion", "multidimensional-array", "parent-child"]}
