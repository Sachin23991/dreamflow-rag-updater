{"id": "6054c3a6-c99e-472c-9b92-3ab2913a93d1", "text": "Q: The reference assemblies for .NETFramework,Version=v0.0 were not found, good practice to target &quot;net-9.0-android&quot; when building MAUI project? A: <p>It usually means MSBuild couldnt parse the TFM. In your command you used an extra hyphen after net.</p>\n<p>The correct TMF is: <code>-f net9.0-android</code></p>\n<p>Ideally your MAUI apps TargetFrameworks should include multiple TFMs:</p>\n<pre><code>&lt;TargetFrameworks&gt;net9.0-android;net9.0-ios;net9.0-windows10.0.19041.0&lt;/TargetFrameworks&gt;\n</code></pre>\n<p>This is the most common practice when you plan to distribute Android-only artifacts.</p>\n", "tags": ["c#", ".net-core", "maui", "maui-android"]}
{"id": "620de4a4-4219-4fdf-9de7-89db16e5e8a7", "text": "Q: Why does `tcc` compile local variables onto the stack? A: <p>Well, I put it in the path of execution, because, well, in my pseudo-C the declaration of <code>struct timespec const a</code>  goes right after <code>fun()</code>, so I expected it to be the most literal mapping of C to assembly. Placing them at the end of the function would be the same, but would look as if I have declared them at the bottom of my C function. C does not seem to permit doing that, but for all intents and purposes it should be fine, because the compiler should be able to &quot;scan out&quot; variable definitions first.</p>\n<p>The reason I would not want to declare them in <code>.rodata</code> is that I would not want to assume that each machine I am compiling this code on has the concept of <code>.rodata</code>, or even that it has a concept of segments or sections.</p>\n<p>This is actually the reason I chose <code>tcc</code> as well. I expected it to produce the most readable assembly of all, rather than the most optimised or most compact.</p>\n", "tags": ["c", "assembly", "arm64", "gnu-assembler", "tcc"]}
{"id": "639ff765-12c6-458f-9983-09f99dc836d1", "text": "Q: How to deal with long running server responses and Load Balancer that treats this as stalled connection A: <p>Migrate to HTTP3 with QUIC, enabling request multiplexing. Then run a short request in parallel on the same connection every once in a while.</p>\n", "tags": ["go", "request", "connection", "timeout"]}
{"id": "1da750f1-184a-4200-8c98-3e51fec1bf93", "text": "Q: How to clone a large git repo over slow/unreliable connection in a fully automatic/generic/RESUMABLE manner? A: <p>Git does not support resumable <code>git clone</code> directly. However, you can approximate resumable behavior using <strong>partial clones + sparse checkout</strong>.</p>\n<h4>Step 1: Clone metadata only</h4>\n<pre class=\"lang-bash prettyprint-override\"><code>git clone --filter=blob:none --no-checkout &lt;URL&gt;\n</code></pre>\n<p>This downloads all repository metadata but no file contents.</p>\n<hr />\n<h4>Step 2: Generate the list of missing files</h4>\n<pre class=\"lang-bash prettyprint-override\"><code>git reset\ngit ls-files --deleted &gt; filelist.txt\n</code></pre>\n<hr />\n<h4>Step 3: Fetch blobs in batches using sparse checkout</h4>\n<p><code>sparse-checkout add</code> implicitly fetches required blobs. By feeding it subsets of paths, you can download files incrementally.</p>\n<p>Workflow:</p>\n<ol>\n<li><p>Split <code>filelist.txt</code> into batches</p>\n</li>\n<li><p>Initialize sparse checkout:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>git sparse-checkout init --no-cone\n</code></pre>\n</li>\n<li><p>For each batch:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>git sparse-checkout add --stdin &lt; batch.txt\n</code></pre>\n</li>\n<li><p>Retry failed batches</p>\n</li>\n<li><p>Disable sparse checkout when complete:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>git sparse-checkout disable\n</code></pre>\n</li>\n</ol>\n<p>Each successfully fetched blob is cached locally, making the process resumable.</p>\n<hr />\n<h4>Notes</h4>\n<ul>\n<li>This is a workaround, not official Git functionality.</li>\n<li>Particularly useful on unstable connections or very large repositories.</li>\n<li>Works on Windows and other platforms (the script would need to be adapted).</li>\n</ul>\n<hr />\n<hr />\n<pre class=\"lang-none prettyprint-override\"><code>@echo off\n\nset &quot;BATCH_SIZE=50&quot;\nset &quot;MAX_RETRY=3&quot;\nset &quot;USER=pchemguy&quot;\nset &quot;REPO=FGVC_Aircraft_dataset&quot;\nset &quot;URL=https://github.com/%USER%/%REPO%.git&quot;\n\nset &quot;ROOT=%~dp0&quot;\nset &quot;ROOT=%ROOT:~0,-1%&quot;\nset &quot;ROOT=%ROOT:\\=/%&quot;\n\nif not exist &quot;%ROOT%/%REPO%/.git/config&quot; (git clone --filter=blob:none --no-checkout %URL%)\ncd /d &quot;%ROOT%/%REPO%&quot;\ngit reset &gt;nul\nif not exist &quot;%ROOT%/filelist.txt&quot; (git ls-files --deleted &gt;&quot;%ROOT%/filelist.txt&quot;)\nif not exist &quot;%ROOT%/%REPO%_batches&quot; (mkdir &quot;%ROOT%/%REPO%_batches&quot;)\n\nset &quot;LINE_COUNT=0&quot;\nset &quot;FILE_COUNT=100&quot;\n\nif exist &quot;%ROOT%/%REPO%_batches/_batches_created_flag&quot; (goto :SKIP_BATCHING)\n\nfor /f &quot;usebackq tokens=*&quot; %%L in (&quot;%ROOT%/filelist.txt&quot;) do (\n    echo %%L&gt;&gt;&quot;%ROOT%/%REPO%_batches/batch!FILE_COUNT!.txt&quot;\n    set /a &quot;LINE_COUNT+=1&quot;\n    set /a &quot;LINE_COUNT%%=%BATCH_SIZE%&quot;\n    if !LINE_COUNT!==0 (set /a &quot;FILE_COUNT+=1&quot;)\n)\necho. &gt;&quot;%ROOT%/%REPO%_batches/_batches_created_flag&quot;\n\n:SKIP_BATCHING\n\ngit sparse-checkout init --no-cone\n\necho Starting batch checkout. Attempts left: %MAX_RETRY%.\n\n:RETRY_BATCH_CHECKOUT\n\nset &quot;TOTAL_ERRORS=0&quot;\nfor %%B in (%ROOT%/%REPO%_batches/batch*.txt) do (\n    set &quot;EXIT_STATUS=1&quot;\n    set &quot;NEXT_BATCH=%ROOT%/%REPO%_batches/%%~nxB&quot;\n    echo --- Processing &quot;%ROOT%/%REPO%_batches/%%~nxB&quot; ---\n    call git sparse-checkout add --stdin &lt; &quot;!NEXT_BATCH!&quot;\n    set &quot;EXIT_STATUS=!ERRORLEVEL!&quot;\n    set /a &quot;TOTAL_ERRORS+=!EXIT_STATUS!&quot;\n    if !EXIT_STATUS!==0 (\n        del /Q &quot;!NEXT_BATCH:/=\\!&quot;\n    )\n)\nset /a &quot;MAX_RETRY-=1&quot;\n\nif exist &quot;%ROOT%/%REPO%_batches/batch*.txt&quot; (\n    echo Some errors have occured...\n    if !MAX_RETRY! gtr 0 (\n        echo Retrying batch checkout. Attempts left: %MAX_RETRY%.\n        goto :RETRY_BATCH_CHECKOUT\n    ) else (\n        echo No more retries left. Aborting...\n        exit /b 1\n    )\n)\n\ncall git sparse-checkout disable\necho Batched checkout is complete.\nrmdir /S /Q &quot;%ROOT%/%REPO%_batches&quot;\n</code></pre>\n", "tags": ["windows", "git", "github", "git-clone"]}
{"id": "26b76602-9ed4-4037-9a53-b47599a59ec6", "text": "Q: Crystal Reports summing within a sub group A: <pre><code>// Place this in Details (or Group 2 sections if you prefer)\nSum({@Formula_Field}, {Group_2_field})\n</code></pre>\n<p>This will give you the same value on each row within the current Group 2</p>\n<pre><code>Row  Column_1  Column_2  Column_3\n1    20        30        40\n2    20        30        40\n3    5         5         5\n4    8         8         9\n5    6         7         6\n</code></pre>\n<p>You have to keep in mind that <code>{Group_2_field}</code> is the actual field you used to define Group 2 (not a formula unless the group was created on that formula). If <code>{@Formula_Field}</code> itself depends on print-time values, this still works, but if you see evaluation-order issues, see below:</p>\n<p>Reset the subgroup sum in Group2 Header by creating a formula called <code>@SubSum_Reset</code> and place it in <strong>Group 2 Header</strong>:</p>\n<pre><code>WhilePrintingRecords;\nGlobal NumberVar SubSum := 0;\n</code></pre>\n<p>Create a formula as<code>@SubSum_Add</code> and place it in Details:</p>\n<pre><code>WhilePrintingRecords;\nGlobal NumberVar SubSum;\nSubSum := SubSum + {@Formula_Field};\n</code></pre>\n<p>Create a formula called <code>@SubSum_Finalize</code> and place it in Group 2 Footer:</p>\n<pre><code>WhilePrintingRecords;\nGlobal NumberVar SubSum;\nGlobal NumberVar SubSumFinal := SubSum;\n</code></pre>\n<p>Finally you can get that in <code>@Subgroup_Total_Display</code> and place it in <strong>Details</strong> where you need the repeated value</p>\n<pre><code>WhilePrintingRecords;\nGlobal NumberVar SubSumFinal;\nSubSumFinal;\n</code></pre>\n<p>This should resolve your issue as it guarantees the same (final) total on every line of the subgroup, even for print-time formulas.</p>\n<p>Hope it helps</p>\n", "tags": ["sql", "crystal-reports"]}
{"id": "e3c96335-40f4-45a0-a7b9-9b28044aad13", "text": "Q: Django Unit Testing taking a very long time to create test database A: <p>If you're using Postgres, use a Postgres template to store a copy of an otherwise empty database with all migrations applied.  Then configure Django to use that template during test database creation.</p>\n<p>One way to do this:</p>\n<ol>\n<li>Run Django's test command with the <code>--keepdb</code> argument.</li>\n<li>On Postgres, rename the created test database using the query</li>\n</ol>\n<blockquote>\n<p><code>alter database &quot;test_your_db_name&quot; rename to &quot;test_your_db_name_template&quot;;</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>On Postgres, make the database a template using the query</li>\n</ol>\n<blockquote>\n<p><code>alter database &quot;test_your_db_name_template&quot; IS_TEMPLATE = true</code></p>\n</blockquote>\n<ol start=\"4\">\n<li>Tweak your test settings using something like:</li>\n</ol>\n<pre><code>DATABASES[&quot;default&quot;][&quot;TEST&quot;] = {}\nDATABASES[&quot;default&quot;][&quot;TEST&quot;][&quot;TEMPLATE&quot;] = &quot;test_your_db_name_template&quot;\n</code></pre>\n<ol start=\"5\">\n<li>Run the Django tests again without the <code>--keepdb</code> argument.  Since the migrations were already applied to the template database, they will not have to run again, so the tests will start pretty much immediately.</li>\n</ol>\n<p>See also the documentation:</p>\n<ul>\n<li><a href=\"https://docs.djangoproject.com/en/6.0/ref/settings/#template\" rel=\"nofollow noreferrer\">Django TEMPLATE database setting</a></li>\n</ul>\n", "tags": ["python", "django", "django-unittest", "django-nose"]}
