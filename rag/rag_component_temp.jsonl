{"id": "c14631d4-56a0-4f3e-9a4d-3f3dd4c02fa7", "text": "Q: faster methods to remove substrings stored in one column from strings stored in another column A: <p>To make this significantly faster, consider a few general principles</p>\n<ul>\n<li>avoid iteration when possible, preferring Pandas methods directly, which are vectorized <a href=\"https://stackoverflow.com/a/55557758/4541045\">How to iterate over rows in a DataFrame in Pandas</a></li>\n<li>keep data in native (non-object) types like <code>datetime64</code> (<code>datetime64[ns]</code>) <a href=\"https://pandas.pydata.org/docs/user_guide/timeseries.html\" rel=\"nofollow noreferrer\">https://pandas.pydata.org/docs/user_guide/timeseries.html</a> (note that splitting the datetime as you are makes them into strings, but this also freezes them for display..)</li>\n</ul>\n<p>While there's not enough information to understand exactly what your data looks like, it seems like you're just trying to split the time and date apart in different Series, which can be <a href=\"https://stackoverflow.com/a/35596174/4541045\">remarkably easy via the <code>.dt</code> property of time series data</a></p>\n<pre><code>hist_df_2[&quot;time&quot;] = hist_df_2['timestamp'].dt.time\n</code></pre>\n<p>The <code>.dt</code> property actually has many useful methods like <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.dayofweek.html\" rel=\"nofollow noreferrer\"><code>.day_of_week</code></a> which may help you get to other goals you have and are annoying to calculate yourself - you can list all the attributes of an object with <a href=\"https://docs.python.org/3/library/functions.html#dir\" rel=\"nofollow noreferrer\"><code>dir()</code></a> to explore it!</p>\n<pre><code>dir(hist_df_2['timestamp'].dt)\n</code></pre>\n<p>If the <code>&quot;timestamp&quot;</code> column isn't a datetime dtype yet, convert it first with <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.to_datetime.html\" rel=\"nofollow noreferrer\"><code>pandas.to_datetime()</code></a> (note this is a method of the Pandas library, not the DataFrame)</p>\n<pre><code>hist_df_2[&quot;timestamp&quot;] = pd.to_datetime(hist_df_2[&quot;timestamp&quot;])\n</code></pre>\n", "tags": ["python", "pandas", "string", "dataframe"]}
{"id": "b77be53d-5db6-40a2-a04b-b08bba8d6f75", "text": "Q: Why 0 is true but false is 1 in the shell? A: <p>I want to provide a different explanation that one could try and build an intutition on (rather than accepting convention or practicality).</p>\n<p>Don't think of it as true and false, but rather as the positive and negative of hypothesis testing: the null hypothesis is the &quot;the process succeeded&quot;, to which a positive test rejecting the null hypothesis is a true non-zero exit code.</p>\n<p>This doesn't really answer the question but rather shifts it to understanding the wider scope hypothesis testing, which in turn is itself a headache but at least there is more to go on with. As a pro side to this way of thinking though is realizing that false positives and negatives make sense, because processes can change/set their exit codes skewing the meaning and introducing bugs in the meaning of the exit status.</p>\n<p>So maybe we can think of &quot;false&quot; as a false positive, a process that successfully returns a failure code.</p>\n", "tags": ["shell", "boolean"]}
{"id": "d5eb076c-6334-40ce-8555-00c1115e76c1", "text": "Q: How to plan migration from EF 6 with EDMX to EF Core A: <p><strong>TL;DR</strong>: A complete overhaul from scratch may be the best option. Otherwise: first convert EDMX code to EF6 code-first. Then port all code to EF-core.</p>\n<hr />\n<p>First thing to contemplate conscientiously is: is it really worth the effort to convert the existing code? Rebuilding from scratch may actually be quite feasible, esp. if the code is structured <a href=\"https://www.geeksforgeeks.org/system-design/solid-principle-in-programming-understand-with-real-life-examples/\" rel=\"nofollow noreferrer\">SOLID</a>-ly. It also offers better chances of employing more modernizations (such as new C# language features, better design principles like mediator, CQRS, or &quot;clean architecture&quot;.)</p>\n<p>When you choose to convert the code, unfortunately, there's no readily available tool that does this for you. The article <a href=\"https://learn.microsoft.com/en-us/ef/efcore-and-ef6/porting/\" rel=\"nofollow noreferrer\">Port from EF6 to EF Core</a> does a pretty good job describing most of the hurdles to take, but for those coming from EDMX, it's pretty scanty. Porting EDMX-based code to EF-core (EFC) is a major transformation.</p>\n<p>Based on my own experience, the greatest challenge is controlling regression. That's much easier when following a couple of steps that do introduce redundancy, but for a good reason:</p>\n<ul>\n<li><p>If not yet abundantly present: create integrations test, <em>lots</em> of them. If already present: create just a couple more of them. You will (obviously) run these tests after each of the following steps.</p>\n</li>\n<li><p>Then the process begins. If you still have code based on <code>ObjectContext</code>, first convert that into <code>DbContext</code>-based code. Mind you, this can be a major step. All entity classes will turn into POCOs and the different change tracking mechanism may change the behavior of your code thoroughly. (IMO, if this is your starting point, you better start from scratch).</p>\n</li>\n<li><p>Port the EDMX-based code to &quot;code-first from database&quot;, still EF6. The starting point may be reverse-engineering the model from database, either using EF tooling in Visual Studio or third-party tools like Entity Framework 6 Power Tools (I believe that requires VS 2019 though). In my experience, the biggest step in the entire conversion was to get all idiosyncrasies and customizations in EDMX mappings right when converting them to code-based mappings. Although this step seems redundant, it's far easier to control regression: you still have the same application code, so you can focus on making all tests run as-is. Converting this code-based configuration to EFC (later step) is a relatively easy one that will cause less regression.</p>\n</li>\n<li><p>(If applicable) Still in EF6, implement a .Net-core-ready alternative for validation by <code>IValidatableObject</code>, because EF-core doesn't integrate it out-of-the-box anymore. Again, this offers you a regression step without changing application code.</p>\n</li>\n<li><p>Now the &quot;big bang&quot; (but much smaller than it was):</p>\n<ul>\n<li>Change the NuGet package.</li>\n<li>Convert the fluent mappings to the EFC methods.</li>\n<li>Make the rest of the code compile again (namespaces, class names, etc.)</li>\n<li>Apply .Net-core application startup and configuration, also in the regression test project.</li>\n</ul>\n</li>\n<li><p>Now regression tests will run, but unless you're extremely lucky, many of them will fail, because:</p>\n<ul>\n<li>EF6 supported a couple of complex, but still pretty common, query shapes that EFC (still) doesn't.</li>\n<li>Some of the mapping code may need correction.</li>\n<li>Applying entity state changes has changed in EFC. This is a tough area that's hard to debug. Make sure to scrutinize <a href=\"https://learn.microsoft.com/en-us/ef/efcore-and-ef6/porting/port-behavior\" rel=\"nofollow noreferrer\">Behavior Changes between EF6 and EF Core</a>.</li>\n</ul>\n<p>So now for the final step:</p>\n</li>\n<li><p>Make all tests succeed again. In the worst case, this may require thorough changes in application code, but now you have already covered a lot of ground and greatly reduced the number of reasons why tests fail.</p>\n</li>\n</ul>\n<p>All of this is easier if it can be done in parts. It depends on the application structure (specifically the existence of aggregates) if this is possible. We started with smaller parts to get the hang of it and then proceeded to the big chunks.</p>\n<p>As for migrations: make a new start in EFC. Note that <a href=\"https://learn.microsoft.com/en-us/ef/core/modeling/data-seeding\" rel=\"nofollow noreferrer\">Data Seeding</a> was changed thoroughly, with new features introduced in EF9.</p>\n", "tags": ["entity-framework", "entity-framework-core", "refactoring"]}
{"id": "5811ee8e-2349-4a9d-ad15-eb247e988f12", "text": "Q: How do I draw recursive Sierpi\u0144ski arrowhead curve using python turtle graphics on Visual Studio Code A: <p>Try:</p>\n\n<pre><code>import turtle \n\ndef seg(level, step, angle):\n    if level&gt;0:\n        seg(level-1, step/2, -angle)\n        T.rt(angle)\n        seg(level-1, step/2,  angle)\n        T.rt(angle)\n        seg(level-1, step/2, -angle)\n    else:\n        T.fd(step)\n\n\n# Main Code\nturtle.bye()\nT = turtle.Turtle()   \nT.speed(10)\nd = 220\nb = 300\nfor level in range(7):\n    T.penup()\n    T.setpos((d*int(level/3)-b, d*(level%3)-b)) # pick new starting point\n    T.setheading(0)                         # reset heading\n    T.pendown()\n    if level%2==1: # is level odd or even? if even than ...\n        T.lt(60)\n    seg(level, 200, 60)\n</code></pre>\n\n<p>and got <a href=\"https://i.sstatic.net/JlQBd.png\" rel=\"nofollow noreferrer\">this plot</a></p>\n", "tags": ["python", "visual-studio-code", "turtle-graphics", "python-turtle"]}
{"id": "89818621-00f3-41b8-8dbe-2e172acb95d8", "text": "Q: How can I make the most efficient Hilbert Curve with Turtle [Python 3]? A: <p>Short of rethinking the program's entire approach, here's a quick fix that provides noticeable speed up.  We'll use <code>tracer()</code> and <code>update()</code> to precisely control the graphics.  We don't want to hide any of the drawing (which is possible with <code>tracer()</code>) but rather only draw when there is a line to draw, treating all the turtle's turns as internal logic calculations, displaying only the final heading:</p>\n<pre><code>from turtle import Screen, Turtle\n\ndef hilbert_curve(distance, facing, n):\n    if n &lt; 1:\n        return\n\n    turtle.left(facing * 90)\n    hilbert_curve(distance, -facing, n - 1)\n    turtle.forward(distance)\n    screen.update()\n\n    turtle.right(facing * 90)\n    hilbert_curve(distance, facing, n - 1)\n    turtle.forward(distance)\n    screen.update()\n\n    hilbert_curve(distance, facing, n - 1)\n    turtle.right(facing * 90)\n    turtle.forward(distance)\n    screen.update()\n\n    hilbert_curve(distance, -facing, n - 1)\n    turtle.left(facing * 90)\n\nscreen = Screen()\nscreen.tracer(False)\n\nturtle = Turtle()\nturtle.hideturtle()\nturtle.penup()\nturtle.goto(10 - screen.window_width()/2, 20 - screen.window_height()/2)\nturtle.pendown()\n\nhilbert_curve(5, 1, 15)\n\nscreen.tracer(True)\nscreen.mainloop()\n</code></pre>\n<p>If, on the other hand, you don't care about watching the drawing and simply want to fill the plane as quickly as possible with a Hilbert curve, then remove the <code>screen.update()</code> calls from the above code and change this line:</p>\n<pre><code>screen.tracer(False)\n</code></pre>\n<p>to instead be:</p>\n<pre><code>screen.tracer(1000)\n</code></pre>\n<p>to fill the window with the fractal in a few seconds.</p>\n", "tags": ["python", "python-3.x", "turtle-graphics", "python-turtle", "hilbert-curve"]}
