{"id": "a466838f-258c-41cd-9224-6ed4a46e7160", "text": "Q: I feel that () is a standard for starting a function A: <p>I would strongly suggest you read some language and programming manuals before asking such question. After reading, you have to experiment writing your code from scratch and make sure you understand the conceptions correctly.</p>\n<p>This is not because I'm not ready or too lazy to answer questions. This is because we all want more mature questions based on more effort. It would be simply a lot more efficient way of learning.</p>\n", "tags": ["python"]}
{"id": "3af8afcd-b21d-414d-b833-dcb535c3c541", "text": "Q: Sql Server JSON result separated in multiple rows A: <p>The answer from Google's Gemini AI:</p>\n<p>To prevent a <code>FOR JSON AUTO</code> response from being split into multiple rows, you should <strong>assign the result to a variable of type <code>VARCHAR(MAX)</code></strong>. This forces SQL Server to buffer the entire JSON string as a single value before returning it to the client application.</p>\n<pre><code>DECLARE @jsonResult NVARCHAR(MAX);\n\nSELECT @jsonResult = (\n    SELECT\n        Column1,\n        Column2\n    FROM\n        YourTable\n    FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER\n);\n\nSELECT @jsonResult AS JSON_Output;\n</code></pre>\n<p>or cross-link is here: <a href=\"https://dba.stackexchange.com/a/279614/23923\">https://dba.stackexchange.com/a/279614/23923</a></p>\n", "tags": ["sql-server", "json", "azure"]}
{"id": "5d13a0c9-ec79-4bde-9d19-47cd213814d2", "text": "Q: Unexpected end of JSON input / Unexpected token &#39;&lt;&#39; when using response.json() with fetch A: <p><code>response.ok === true</code> only means the HTTP status is in the 2xx range. It does not guarantee that the response body contains valid JSON.</p>\n<p>In your case, the behavior is expected: <strong>202 Accepted</strong> often returns <strong>no response body</strong> \u2192 calling <code>response.json()</code> on an empty body throws <code>Unexpected end of JSON input</code>. <code>Unexpected token '&lt;'</code> means the response body is <strong>HTML</strong>, not JSON, commonly an SPA <code>index.html</code>, login page, redirect, or proxy error page. <code>fetch</code> does not validate response content \u2014 <code>response.json()</code> blindly tries to parse whatever it receives. That\u2019s why <code>response.text()</code> works and shows HTML, while <code>response.json()</code> fails.</p>\n<p><strong>The correct way to handle this is:</strong></p>\n<p>Only parse JSON when the server actually returns JSON, and handle empty responses explicitly:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const res = await fetch(url);\n\nconst contentType = res.headers.get(&quot;content-type&quot;) || &quot;&quot;;\n\nif (res.status === 202 || res.status === 204) {\n  return;\n}\n\nif (!contentType.includes(&quot;application/json&quot;)) {\n  const text = await res.text();\n  console.error(&quot;Expected JSON but got:&quot;, text);\n  return;\n}\n\nconst data = await res.json();\n</code></pre>\n", "tags": ["javascript", "reactjs", "json", "cors", "fetch-api"]}
{"id": "2250af77-6e33-42d8-a930-f6bac251faf8", "text": "Q: When is the renderer process in Electron application actually ready to listen for the events? A: <p>You are right, this is not <code>app.whenReady</code>.</p>\n<p>But you should not use <code>await</code>. In the main-process Electron workflow, pretty much never. The asynchronous model is well-known and works correctly. Basically, this is what you do:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const subscribeToEvents(window, /* ... */) =&gt; {\n    // here, your main process can subscribe to events coming from renderer:\n    ipcMain.on(someChannelName, /* data... */);\n    ipcMain.on( /* and so on... */);\n};\n\nconst createWindow = (title, /* ... */) =&gt; {\n    //...\n    const window = new BrowserWindow( /* ... */ );\n    // from this moment, you can use IPC to communicate with the renderer:\n    window.webContents.send(channelName, /* some data... */);\n    // now, you can handle whatever happens when the web page has been rendered\n    window.once('ready-to-show', () =&gt; {\n       // send whatever should be handled right before showing\n       // to the renderer to prepare it for showing:\n       window.webContents.send(/* ... *);\n       // here, window will be displayed without visual flash:\n       window.show();\n    }); //once ready to show\n    // ...\n    subscribeToEvents(window, /* ... */);\n};\n\napp.whenReady().then(() =&gt; {\n    // some initialization to calculate title\n    // and the options you need on createWindows\n    createWindow(title, /* ... */);\n    app.on(definitionSet.events.activate, () =&gt; {\n    if (BrowserWindow.getAllWindows().length === 0)\n        createWindow(title);\n});\n</code></pre>\n<p>As you can see, the ultimate event when a renderer window can be shown is not <code>app.whenReady</code>, but <a href=\"https://www.electronjs.org/docs/latest/api/browser-window#event-ready-to-show\" rel=\"nofollow noreferrer\">'ready-to-show'</a>. Inside the handler of this event, your renderer process is ready to receive IPC events, so you have to use the 'ready-to-show' hander to do the initialization you need. Nevertheless, you also have to use the event <code>app.whenReady</code>, because the handler of this event is the place when you can create an instance (or instances) of the <a href=\"https://www.electronjs.org/docs/latest/api/browser-window\" rel=\"nofollow noreferrer\">BrowserWindow</a>.</p>\n", "tags": ["electron"]}
{"id": "3d067bed-b77b-4b14-a8ff-e0e4267a0fad", "text": "Q: PHP dependency injection and PSR LoggerInterface A: <p>Dependency injection framework differs in how object instances are instantiated. It mostly depends on the library you used as container. Symfony needs you to create <a href=\"https://symfony.com/doc/current/configuration.html\" rel=\"nofollow noreferrer\">some YML configurations</a>. PHP-DI has its <a href=\"https://php-di.org/doc/php-definitions.html\" rel=\"nofollow noreferrer\">own definition pattern</a>.</p>\n<p>It is totally OK to create your own interface if you were to do all of the implementations anyway.</p>\n<p>For example,</p>\n<pre class=\"lang-php prettyprint-override\"><code>interface MyLoggerFactoryInterface {\n  public function log(string $message);\n}\n\nclass MyTextLogger implements MyLoggerFactoryInterface {\n  public function log(string $message) {\n    echo $message;\n  }\n}\n\nclass MyHelloController {\n  public function __construct(private MyLoggerFactoryInterface $logger) {\n  }\n\n  ...\n  public function handleIndex() {\n    ...\n    $this-&gt;logger-&gt;log(&quot;something&quot;);\n    ...\n  }\n}\n\n// Assume you're using PHP DI (without autowiring)\n$container = new DI\\Container([\n  MyTextLogger::class =&gt; create(),\n  MyHelloController::class =&gt; create()-&gt;constructor(\n     get(MyTextLogger::class), \n  ),\n]);\n\n...\n\n$container-&gt;get(MyHelloController::class)-&gt;handleIndex();\n</code></pre>\n", "tags": ["php", "logging", "dependency-injection"]}
{"id": "ad8025cd-3e3e-42d2-a71d-a4544b671b32", "text": "Q: Load html pages with css styles from jquery A: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Index.html&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../myIndexCss.css&quot;&gt;\n    &lt;!--\n        Link the CSS files directly here\n    --&gt;\n    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../myHeader.css&quot;&gt;\n    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../myFooter.css&quot;&gt;\n    &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;../myContent.css&quot;&gt;\n    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt;\n&lt;!-- \nYou can partially include parts of the required HTML files.\nMake sure to use the related to topic elements so you can easily refer to\nthem at the end of the load sentence. The error will be gone, since you are \nnot trying to include CSS or JS files from within an HTML document. \n --&gt;\n    &lt;script&gt;\n       $(document).ready(function() {\n            $(&quot;#header&quot;).load(&quot;header/header.html header&quot;);\n            $(&quot;#footer&quot;).load(&quot;footer/footer.html main&quot;);\n            $(&quot;#content&quot;).load(&quot;content/content.html footer&quot;);\n        });\n    &lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;header id=&quot;header&quot;&gt;\n        Add your desired header content\n    &lt;/header&gt;\n\n    &lt;main id=&quot;content&quot;&gt;\n        Add your desired main content \n    &lt;/main&gt;\n    \n    &lt;footer id=&quot;footer&quot;&gt;\n        Add your desired footer content \n    &lt;/footer&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n", "tags": ["javascript", "html", "jquery", "css"]}
