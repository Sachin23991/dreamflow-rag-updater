{"id": "8bdf8898-af7c-49a4-ad27-93631d657c7a", "text": "Q: How to turn off SSL from the Windows client library mariadb connector-c 3.4.8 win64 A: <p>Try using <code>--skip-ssl</code> command line option.</p>\n", "tags": ["mariadb", "mariadb-connector-c"]}
{"id": "a8576f83-ecfa-44a5-b635-ade10a490c4f", "text": "Q: Is GCC right when it accepts a C++ template struct having a member with a wrong default initializer? A: <blockquote>\n<p>Is GCC right when it accepts</p>\n</blockquote>\n<p>No, <strong>GCC is incorrect</strong> in accepting an ill-formed program  since <code>Wrapper w{};</code> is direct initialization and it needs an existing default constructor for <code>Wrapper w{};</code> to be valid but a default constructor will not be synthesized for <code>Wrapper</code> since you've provided your own constructor, as explained below in detail.</p>\n<hr />\n<p>First note that <code> Wrapper w{};</code> is direct initialisation(direct list initialization to be more specific). From <a href=\"https://eel.is/c++draft/dcl.init\" rel=\"nofollow noreferrer\">dcl.init</a>:</p>\n<blockquote>\n<p>The initialization that occurs:</p>\n<ul>\n<li><strong>for an initializer that is a</strong> parenthesized expression-list or a <strong>braced-init-list</strong>,</li>\n</ul>\n<p><strong>is called direct-initialization.</strong></p>\n</blockquote>\n<p>Next we move to the <a href=\"https://eel.is/c++draft/dcl.init#general-16\" rel=\"nofollow noreferrer\">semantics of the initializer</a>.</p>\n<blockquote>\n<ol start=\"16\">\n<li>The semantics of initializers are as follows. The destination type is the cv-unqualified type of the object or reference being initialized and the source type is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</li>\n</ol>\n<ul>\n<li><strong>If the initializer is a (non-parenthesized) braced-init-list</strong> or is = braced-init-list, <strong>the object or reference is list-initialized ([dcl.init.list]).</strong>.</li>\n<li></li>\n<li></li>\n</ul>\n</blockquote>\n<p>The above means that, the object is to be <a href=\"https://eel.is/c++draft/dcl.init#list\" rel=\"nofollow noreferrer\">list-initialized</a>.</p>\n<p>From <a href=\"https://eel.is/c++draft/dcl.init#list\" rel=\"nofollow noreferrer\">list initialization</a>:</p>\n<blockquote>\n<p>List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is called an initializer list, and the comma-separated initializer-clauses of the initializer-list or designated-initializer-clauses of the designated-initializer-list are called the elements of the initializer list. An initializer list may be empty. List-initialization can occur in direct-initialization or copy-initialization contexts; <strong>list-initialization in a direct-initialization context is called direct-list-initialization</strong> and list-initialization in a copy-initialization context is called copy-list-initialization. Direct-initialization that is not list-initialization is called direct-non-list-initialization.</p>\n</blockquote>\n<p>The above means that <code>Wrapper w{};</code> is direct-list initiaization. Next we see the <a href=\"https://eel.is/c++draft/dcl.init#list-3\" rel=\"nofollow noreferrer\">effect</a> of list initialization:</p>\n<blockquote>\n<p>List-initialization of an object or reference of type cv T is defined as follows:</p>\n<ul>\n<li>Otherwise, if the initializer list has no elements and T is a class type with a default constructor, the <strong>object is value-initialized.</strong></li>\n</ul>\n</blockquote>\n<p>The above means that the object will be <a href=\"https://eel.is/c++draft/dcl.init#general-9\" rel=\"nofollow noreferrer\">value initialized</a>, so we move on to value-initialization:</p>\n<blockquote>\n<ol start=\"8\">\n<li>To value-initialize an object of type T means:</li>\n</ol>\n<ul>\n<li>If T is a (possibly cv-qualified) class type ([class]), then let C be the constructor selected to default-initialize the object, if any. If C is not user-provided, the object is first zero-initialized. In all cases, the object is then default-initialized.;</li>\n</ul>\n</blockquote>\n<p>This means that the object will be <a href=\"https://eel.is/c++draft/dcl.init#general-7\" rel=\"nofollow noreferrer\">default initialized</a>:</p>\n<blockquote>\n<p>To default-initialize an object of type T means:</p>\n<ul>\n<li>If T is a (possibly cv-qualified) class type ([class]), constructors are considered. The applicable constructors are enumerated ([over.match.ctor]), and the best one for the initializer () is chosen through overload resolution ([over.match]). The constructor thus selected is called, with an empty argument list, to initialize the object.</li>\n</ul>\n</blockquote>\n<p>So we move on to <a href=\"https://eel.is/c++draft/over.match.ctor\" rel=\"nofollow noreferrer\">over.match.ctor</a> to get a list of candidate ctors. Also do note the <code>initializer()</code> part in the above quoted reference as it will be used at the end as an argument.</p>\n<blockquote>\n<p>When objects of class type are direct-initialized, copy-initialized from an expression of the same or a derived class type ([dcl.init]), or default-initialized, overload resolution selects the constructor. <strong>For direct-initialization or default-initialization</strong> (including default-initialization in the context of copy-list-initialization), the <strong>candidate functions are all the constructors of the class of the object being initialized.</strong> Otherwise, the candidate functions are all the non-explicit constructors ([class.conv.ctor]) of that class. The argument list is the expression-list or assignment-expression of the initializer. For default-initialization in the context of copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>But note that there is no default constructor for <code>Wrapper</code>. As you've provided your own parameterized ctor, the compiler won't synthesize a default ctor for <code>Wrapper</code>. Thus, the condition for <code>Wrapper w{};</code> to be valid(which requires a default ctor) is not fulfilled and clang is correct in rejecting the program.</p>\n", "tags": ["c++", "templates", "language-lawyer"]}
{"id": "2f1698d7-2e20-45db-8546-227d45db38db", "text": "Q: How can I solve data range error into google sheets with appscript A: <p>The error happens because <code>setValues()</code> always expects a <strong>2D array</strong>, even when you're writing to a single column. In your original code you were pushing plain strings (<code>&quot;text&quot;</code>) into <code>rowDescription</code>, which makes it a 1D array. When you pass <code>[rowDescription]</code> into <code>setValues()</code>, Sheets interprets it as <strong>1 row \u00d7 12 columns</strong>, but your range (<code>B2:B13</code>) is <strong>12 rows \u00d7 1 column</strong>, so the dimensions don\u2019t match.</p>\n<p>By changing each push to:</p>\n<pre><code>rowDescription.push([data.description]);\n</code></pre>\n<p>you correctly build a <strong>12\u00d71 2D array</strong>, which matches the 12\u00d71 range. That\u2019s why the updated version works.</p>\n", "tags": ["javascript", "google-sheets", "google-apps-script", "web-applications", "range"]}
{"id": "d024b30d-9f57-4674-967f-90cfbea37c7b", "text": "Q: How do you do partial text search in Supabase Db? A: <p>If you want to do partial text matching, such as matching <code>He</code> with <code>Hello</code>, first you need to create an SQL function for this matching logic:</p>\n<pre><code>create or replace function public.search_word_prefix(prefix text)\nreturns setof words as $$\n  select *\n  from words\n  where word ilike prefix || '%';\n$$ language sql stable;\n</code></pre>\n<p>You can run this in the SQL Editor in Supabase.</p>\n<p>Then, to use this function in the Supabase JS client, do:</p>\n<pre><code>const { data, error } = await supabase.rpc(\n  'search_word_prefix',\n  { prefix: 'He' }\n)\n</code></pre>\n", "tags": ["supabase", "supabase-database"]}
