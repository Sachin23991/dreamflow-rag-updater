{"id": "b39ec411-4eab-49c9-a38a-c9e8c745b319", "text": "Q: How to make devices discover each other using WIFI A: <p>One thing to be aware of is that broadcast messages are not generally routed between networks, so bear that in mind.</p>\n<p>Also, one option might be to reserve an IP address on your router for the MAC address of your server so your server always gets a fixed, known IP address without needing to configure it as static even though it gets its address via DHCP. Then your client will know where to find it.</p>\n<p>Alternatively, you could choose a port and let the client try that port on all addresses till it finds a server.</p>\n", "tags": ["network-programming", "distributed-computing", "distributed-system", "lan"]}
{"id": "e0b2bd5f-f216-42fa-a32a-ddc3ac4769cd", "text": "Q: Is there a way to print Runes as individual characters? A: <h3>Stored on the stack as a string of (wide) characters</h3>\n<p>If you want to add your runes (wchar_t) to a string then you can proceed the following way:</p>\n<p><s>using <a href=\"https://linux.die.net/man/3/wcsncpy\" rel=\"nofollow noreferrer\"><strong>wcsncpy</strong></a>: (overkill for char, thanks chqrlie for noticing)</s></p>\n<pre class=\"lang-c prettyprint-override\"><code>#define UNICODE_BLOCK_START 0x16A0 // see wikipedia link for the start\n#define UUICODE_BLOCK_END   0x16F0 // true ending of Runic wide chars\n\nint main(void) {\n  setlocale(LC_ALL, &quot;&quot;);\n  wchar_t buffer[UUICODE_BLOCK_END - UNICODE_BLOCK_START + sizeof(wchar_t) * 2];\n\n  int i = 0;\n  for (wchar_t wc = UNICODE_BLOCK_START; wc &lt;= UUICODE_BLOCK_END; wc++)\n    buffer[i++] = wc;\n  buffer[i] = L'\\0';\n\n  printf(&quot;%ls\\n&quot;, buffer);\n  return 0;\n}\n</code></pre>\n<hr />\n<h3>About Wide Chars (and Unicode)</h3>\n<p>To understand a bit better what is a <a href=\"https://en.wikipedia.org/wiki/Wide_character\" rel=\"nofollow noreferrer\">wide char</a>, you have to think of it as a set of bits set that exceed the original range used for character which was <code>2^8 = 256</code> or, with <a href=\"https://en.wikipedia.org/wiki/Arithmetic_shift\" rel=\"nofollow noreferrer\">left shifting</a>, <code>1 &lt;&lt; 8</code>).</p>\n<p>It is enough when you just need to print what is on your keyboard, but when you need to print Asian characters or other unicode characters, it was not enough anymore and that is the reason why the <a href=\"https://en.wikipedia.org/wiki/Unicode\" rel=\"nofollow noreferrer\">Unicode standard</a> was created. You can find more about the very different and exotic characters that exist, along with their range (named unicode blocks), on <a href=\"https://en.wikipedia.org/wiki/Unicode_block\" rel=\"nofollow noreferrer\">wikipedia</a>, in your case <strong><code>runic</code></strong>.</p>\n<blockquote>\n<p>Range U+16A0..U+16FF  - Runic (86 characters), Common (3 characters)</p>\n</blockquote>\n<p><strong>NB:</strong> Your Runic wide chars end at 0x16F1 which is slightly before 0x16FF (0x16F1 to 0x16FF are not defined)</p>\n<p>You can use the following function to print your wide char as bits:</p>\n<pre class=\"lang-c prettyprint-override\"><code>void print_binary(unsigned int number)\n{\n    char buffer[36]; // 32 bits, 3 spaces and one \\0\n    unsigned int mask = 0b1000000000000000000000000000;\n    int i = 0;\n    while (i++ &lt; 32) {\n        buffer[i] = '0' + !!(number &amp; (mask &gt;&gt; i));\n        if (i &amp;&amp; !(i % 8))\n            buffer[i] = ' ';\n    }\n    buffer[32] = '\\0';\n    printf(&quot;%s\\n&quot;, buffer);\n}\n</code></pre>\n<p>That you call in your loop with:</p>\n<pre class=\"lang-c prettyprint-override\"><code>print_binary((unsigned int)wc);\n</code></pre>\n<p>It will give you a better understand on how your wide char is represented at the machine level:</p>\n<pre><code>               \u16de\n0000000 0000001 1101101 1100000\n</code></pre>\n<hr />\n<p><strong>NB:</strong> You will need to pay attention to detail: Do not forget the final <code>L'\\0'</code> and you need to use <code>%ls</code> to get the output with <code>printf</code>.</p>\n", "tags": ["arrays", "c", "string", "cryptography", "char"]}
{"id": "288f9c88-2fcf-4643-a824-2c1fea23054b", "text": "Q: Customizing label format in facet nested plots with ggplot2 A: <p>We can use <code>ggtext::element_markdown()</code>.</p>\n<pre class=\"lang-r prettyprint-override\"><code>library(ggplot2)\nlibrary(dplyr)\nlibrary(patchwork)\nlibrary(ggh4x)\nlibrary(ggtext)\n</code></pre>\n<pre><code>plots &lt;- function(data, predictors) {\n  \n  all_plots &lt;- lapply(predictors, function(predictor) {\n    \n    data[[predictor]] &lt;- as.factor(data[[predictor]])\n    \n    filtered_data &lt;- data %&gt;%\n      filter(!is.na(.[[predictor]]))\n    \n    # HTML/Markdown format\n    facet_expression &lt;- if (predictor == &quot;x1ij&quot;) {\n      &quot;x&lt;sub&gt;1ij&lt;/sub&gt;&quot;\n    } else if (predictor == &quot;z2j&quot;) {\n      &quot;z&lt;sub&gt;2j&lt;/sub&gt;&quot;\n    }\n    \n    filtered_data$facet_var &lt;- facet_expression\n    filtered_data$ICC_label &lt;- paste0(&quot;ICC&lt;sub&gt;y&lt;/sub&gt; = &quot;,\n                                      filtered_data$ICC)\n    \n    p &lt;- ggplot(filtered_data, aes_string(x = predictor, y = &quot;.value&quot;)) +\n      geom_jitter(width = 0.15, size = 1, alpha = 0.2, color = &quot;gray30&quot;) +\n      geom_violin(aes_string(fill = predictor), alpha = 0.3) +\n      labs(y = &quot;Something&quot;) +\n      ylim(-5, 5) +\n      theme_minimal() +\n      facet_nested(~ facet_var + ICC_label, \n                   scales = &quot;free_x&quot;, \n                   nest_line = TRUE) +\n      theme(\n        axis.title.x = element_blank(),\n        strip.text = element_markdown(hjust = 0.5, size = 10)\n      ) +\n      guides(fill = &quot;none&quot;)\n    \n    return(p)\n  })\n  \n  final_plot &lt;- wrap_plots(all_plots, nrow = 1)\n  return(final_plot)\n}\n</code></pre>\n<pre><code>set.seed(1324563)\nexample_data &lt;- data.frame(\n  x1ij = sample(0:1, 100, replace = TRUE),\n  z2j = sample(0:1, 100, replace = TRUE),\n  ICC = as.factor(sample(c(0.2, 0.5, 0.8), 100, replace = TRUE)),\n  .value = rnorm(100)\n)\n\nplots(example_data, c(&quot;x1ij&quot;, &quot;z2j&quot;))\n</code></pre>\n<p><img src=\"https://i.sstatic.net/Z4sXGqHm.png\" alt=\"\" /></p>\n<p><sup>Created on 2025-12-10 with <a href=\"https://reprex.tidyverse.org\" rel=\"nofollow noreferrer\">reprex v2.1.1</a></sup></p>\n", "tags": ["r", "ggplot2", "plot", "facet-grid"]}
{"id": "705dc808-2e0f-4076-a50f-1deef9778733", "text": "Q: Bulk load data conversion error (type mismatch or invalid character for the specified codepage) for row 1, column 4 (Year) A: <p>My guess is that it's an encoding problem; for instance your file is UTF-8 but SQL will not read it the way it should, so it attempts to insert 100\u00ff or something along these lines into your table.</p>\n<p>Possible fixes:</p>\n<ol>\n<li>Specify the <a href=\"https://en.wikipedia.org/wiki/Code_page\" rel=\"nofollow noreferrer\">Codepage</a></li>\n<li>Change the Encoding of the source using PowerShell</li>\n</ol>\n<p>Code samples:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>1.\n   BULK INSERT myTable FROM 'c:\\Temp\\myfile.csv' WITH (\n       FIELDTERMINATOR = '\u00a3',\n       ROWTERMINATOR = '\\n',\n       CODEPAGE = 'ACP' -- ACP corresponds to ANSI, also try UTF-8 or 65001 for Unicode\n   );\n</code></pre>\n<pre class=\"lang-bash prettyprint-override\"><code>2.\n   get-content &quot;myfile.csv&quot; | Set-content -Path &quot;myfile.csv&quot; -Encoding String\n   # String = ANSI, also try Ascii, Oem, Unicode, UTF7, UTF8, UTF32\n</code></pre>\n", "tags": ["sql", "sql-server", "t-sql"]}
