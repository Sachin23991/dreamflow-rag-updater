{"id": "2ecb5977-6ff7-4e57-ae8a-954123072676", "text": "Q: What can I use for input conversion instead of scanf? A: <p>Two of the most common uses of <code>scanf</code> are to read a single line of input from the user and to</p>\n<ol>\n<li>convert it to an <code>int</code> value, or</li>\n<li>store it as a string.</li>\n</ol>\n<p>Therefore, I will write an answer which focuses on these two problems only:</p>\n<h1>How to read an <code>int</code> from the user</h1>\n<p>Here is an example of how <code>scanf</code> is commonly used for reading an <code>int</code> from the user:</p>\n<pre><code>int num;\n\nprintf( &quot;Please enter an integer: &quot; );\n\nif ( scanf( &quot;%d&quot;, &amp;num ) != 1 )\n{\n    printf( &quot;Error converting input!\\n&quot; );\n}\nelse\n{\n    printf( &quot;The input was successfully converted to %d.\\n&quot;, num );\n}\n</code></pre>\n<p>Using <code>scanf</code> in this manner has several problems:</p>\n<p>Most importantly, the function <code>scanf</code> will not always consume the entire line of input. This makes the function not appropriate for line-based user input.</p>\n<p>For example, if the input conversion fails due to the user entering bad input such as <code>abc</code>, then the bad input will be left on the input stream. If this bad input is not discarded afterwards, then all further calls to <code>scanf</code> with the <code>%d</code> format specification will immediately fail, without waiting for the user to enter further input. This may cause an infinite loop if you are calling <code>scanf</code> in a loop.</p>\n<p>Even if the input conversion succeeds, any trailing bad input will be left on the input stream. For example, if the user enters <code>6abc</code>, then <code>scanf</code> will successfully convert the <code>6</code>, but leave <code>abc</code> on the input stream. If this input is not discarded, then we will once again have the problem of all further calls to <code>scanf</code> with the <code>%d</code> format specification immediately failing, which may cause an infinite loop.</p>\n<p>Even in the case of the input succeeding and the user not entering any trailing bad input, the mere fact that <code>scanf</code> generally leaves the newline character on the input stream can cause trouble, as demonstrated in <a href=\"https://stackoverflow.com/q/5240789/12149471\">this question</a>.</p>\n<p>Another issue with using <code>scanf</code> with the <code>%d</code> format specification is that if the result of the conversion is not representable as an <code>int</code> (e.g. if the result is larger than <a href=\"https://en.cppreference.com/w/c/types/limits\" rel=\"nofollow noreferrer\"><code>INT_MAX</code></a>), then, according to <a href=\"http://port70.net/%7Ensz/c/c11/n1570.html#7.21.6.2p10\" rel=\"nofollow noreferrer\">\u00a77.21.6.2 \u00b610 of the ISO C11 standard</a>, the behavior of the program is undefined, which means that you cannot rely on any specific behavior. It also means that <code>scanf</code> does not provide any way to test whether the result of the conversion is representable as an <code>int</code>.</p>\n<p>In order to solve all of the issues mentioned above, it is generally better to use the function <a href=\"https://en.cppreference.com/w/c/io/fgets\" rel=\"nofollow noreferrer\"><code>fgets</code></a>, which will always read an entire line of input at once, if possible. This function will read the input as a string. After doing this, you can use the function <a href=\"https://en.cppreference.com/w/c/string/byte/strtol\" rel=\"nofollow noreferrer\"><code>strtol</code></a> to attempt to convert the string to an integer. Here is an example program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main( void )\n{\n    char line[200], *p;\n    int num;\n\n    // prompt user for input\n    printf( &quot;Enter a number: &quot; );\n\n    // attempt to read one line of input\n    if ( fgets( line, sizeof line, stdin ) == NULL )\n    {\n        printf( &quot;Input failure!\\n&quot; );\n        exit( EXIT_FAILURE );\n    }\n\n    // attempt to convert string to integer\n    num = strtol( line, &amp;p, 10 );\n    if ( p == line )\n    {\n        printf( &quot;Unable to convert to integer!\\n&quot; );\n        exit( EXIT_FAILURE );\n    }\n\n    // print result\n    printf( &quot;Conversion successful! The number is %d.\\n&quot;, num );\n}\n</code></pre>\n<p>However, this code has the following issues:</p>\n<ol>\n<li><p>It does not check whether the input line was too long to fit into the buffer.</p>\n</li>\n<li><p>It does not check whether the converted number is representable as an <code>int</code>, for example whether the number is too large to be stored in an <code>int</code>.</p>\n</li>\n<li><p>It will accept <code>6abc</code> as valid input for the number <code>6</code>. This is not as bad as <code>scanf</code>, because <code>scanf</code> will leave <code>abc</code> on the input stream, whereas <code>fgets</code> will not. However, it would probably still be better to reject the input instead of accepting it.</p>\n</li>\n</ol>\n<p>All of these issues can be solved by doing the following:</p>\n<p>Issue #1 can be solved by checking</p>\n<ul>\n<li>whether the input buffer contains a newline character, or</li>\n<li>whether end-of-file has been reached, which can be treated as equivalent to a newline character, because it also indicates the end of the line.</li>\n</ul>\n<p>Issue #2 can be solved by checking whether the function <code>strtol</code> set <code>errno</code> to the value of the macro constant <code>ERANGE</code>, to determine whether the converted value is representable as a <code>long</code>. In order to determine whether this value is also representable as an <code>int</code>, the value returned by <code>strtol</code> should be compared against <a href=\"https://en.cppreference.com/w/c/types/limits\" rel=\"nofollow noreferrer\"><code>INT_MIN</code></a> and <code>INT_MAX</code>.</p>\n<p>Issue #3 can be solved by checking all remaining characters on the line. Since <code>strtol</code> accepts leading <a href=\"https://en.wikipedia.org/wiki/Whitespace_character\" rel=\"nofollow noreferrer\">whitespace characters</a>, it would probably be appropriate to also accept trailing whitespace characters. However, if the input contains any other trailing characters, the input should probably be rejected.</p>\n<p>Here is an improved version of the code, which solves all of the issues mentioned above and also puts everything into a function named <code>get_int_from_user</code>. This function will automatically reprompt the user for input, until the input is valid.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;errno.h&gt;\n\n// This function will attempt to read one integer of type &quot;int&quot;\n// from the user. If the input is invalid, it will automatically\n// reprompt the user, until the input is valid.\nint get_int_from_user( const char *prompt )\n{\n    // loop forever until user enters a valid number\n    for (;;)\n    {\n        char buffer[1024], *p;\n        long num;\n\n        // prompt user for input\n        fputs( prompt, stdout );\n\n        // explicitly flushing the output stream\n        // may be necessary on some platforms\n        fflush( stdout );\n\n        // get one line of input from input stream\n        if ( fgets( buffer, sizeof buffer, stdin ) == NULL )\n        {\n            fprintf( stderr, &quot;Unrecoverable input error!\\n&quot; );\n            exit( EXIT_FAILURE );\n        }\n\n        // make sure that entire line was read in (i.e. that\n        // the buffer was not too small)\n        if ( strchr( buffer, '\\n' ) == NULL &amp;&amp; !feof( stdin ) )\n        {\n            int c;\n\n            printf( &quot;Line input was too long!\\n&quot; );\n\n            // discard remainder of line\n            do\n            {\n                c = getchar();\n\n                if ( c == EOF )\n                {\n                    fprintf( stderr, &quot;Unrecoverable error reading from input!\\n&quot; );\n                    exit( EXIT_FAILURE );\n                }\n\n            } while ( c != '\\n' );\n\n            continue;\n        }\n\n        // attempt to convert string to number\n        errno = 0;\n        num = strtol( buffer, &amp;p, 10 );\n        if ( p == buffer )\n        {\n            printf( &quot;Error converting string to number!\\n&quot; );\n            continue;\n        }\n\n        // make sure that number is representable as an &quot;int&quot;\n        if ( errno == ERANGE || num &lt; INT_MIN || num &gt; INT_MAX )\n        {\n            printf( &quot;Number out of range error!\\n&quot; );\n            continue;\n        }\n\n        // make sure that remainder of line contains only whitespace,\n        // so that input such as &quot;6abc&quot; gets rejected\n        for ( ; *p != '\\0'; p++ )\n        {\n            if ( !isspace( (unsigned char)*p ) )\n            {\n                printf( &quot;Unexpected input encountered!\\n&quot; );\n\n                // cannot use `continue` here, because that would go to\n                // the next iteration of the innermost loop, but we\n                // want to go to the next iteration of the outer loop\n                goto continue_outer_loop;\n            }\n        }\n\n        return num;\n\n    continue_outer_loop:\n        continue;\n    }\n}\n\nint main( void )\n{\n    int number;\n\n    number = get_int_from_user( &quot;Enter a number: &quot; );\n\n    printf( &quot;Input was valid.\\n&quot; );\n    printf( &quot;The number is: %d\\n&quot;, number );\n\n    return 0;\n}\n</code></pre>\n<p>This program has the following behavior:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Enter a number: abc\nError converting string to number!\nEnter a number: 6000000000\nNumber out of range error!\nEnter a number: 6 7 8\nUnexpected input encountered!\nEnter a number: 6abc\nUnexpected input encountered!\nEnter a number: 6\nInput was valid.\nThe number is: 6\n</code></pre>\n<p>If you want to read a <code>double</code> instead of an <code>int</code> from the user, then you can use <a href=\"https://en.cppreference.com/w/c/string/byte/strtof\" rel=\"nofollow noreferrer\"><code>strtod</code></a> instead of <code>strtol</code>, and remove the code block which checks whether the input is in the range <code>INT_MIN</code> to <code>INT_MAX</code>.</p>\n<h1>How to read a single line of input as a string</h1>\n<p>One common way to read a string from the user using <code>scanf</code> is to use something like the following:</p>\n<pre class=\"lang-c prettyprint-override\"><code>char line[100];\n\nprintf( &quot;Please enter a string: &quot; );\n\nif ( scanf( &quot;%s&quot;, line ) != 1 )\n{\n    printf( &quot;Error reading string!\\n&quot; );\n}\nelse\n{\n    printf( &quot;The input was successfully converted to \\&quot;%s\\&quot;.\\n&quot;, line );\n}\n</code></pre>\n<p>However, this code has several problems:</p>\n<ol>\n<li>The <code>%s</code> conversion specification will only match and consume a single word, not the entire line of input.</li>\n<li>Even if the user enters only a single word, <code>scanf</code> will leave the newline character on the input stream, which, as already pointed out in the previous section, can lead to problems, as demonstrated in <a href=\"https://stackoverflow.com/q/5240789/12149471\">this question</a>.</li>\n<li>If the user enters more than 99 characters, then there will be a <a href=\"https://en.wikipedia.org/wiki/Buffer_overflow\" rel=\"nofollow noreferrer\">buffer overflow</a>, which will invoke <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a> (i.e. your program may crash).</li>\n</ol>\n<p>It is possible to fix all 3 of these problems using <code>scanf</code>, by changing the code to the following:</p>\n<pre><code>char line[100];\n\nprintf( &quot;Please enter a string: &quot; );\n\nif ( scanf( &quot;%99[^\\n]&quot;, line ) != 1 )\n{\n    printf( &quot;Error reading string!\\n&quot; );\n}\nelse\n{\n    // verify that the next character is the newline\n    // character, and discard it. Alternatively\n    // encountering end-of-file is also acceptable.\n    if ( getchar() != '\\n' &amp;&amp; !feof(stdin) )\n    {\n        if ( ferror(stdin) )\n        {\n            printf( &quot;Input stream error!\\n&quot; );\n        }\n        else\n        {\n            printf( &quot;Input line was too long!\\n&quot; );\n        }\n    }\n    else\n    {\n        printf( &quot;The input was successfully converted to \\&quot;%s\\&quot;.\\n&quot;, line );\n    }\n}\n</code></pre>\n<p>However, this has the problem that the <code>%[^\\n]</code> format specification will only match at least one character. This means that matching will fail if the user enters an empty line. In that case, the <code>char</code> array that was specified as an argument to <code>scanf</code> is not guaranteed to be null-terminated. This behavior is probably undesirable, and possibly dangerous (as a missing null terminator can easily lead to a <a href=\"https://en.wikipedia.org/wiki/Buffer_overflow\" rel=\"nofollow noreferrer\">buffer overflow</a> if not handled correctly).</p>\n<p>A more flexible approach, which also allows the user to enter an empty line, would be to use <a href=\"https://en.cppreference.com/w/c/io/fgets\" rel=\"nofollow noreferrer\"><code>fgets</code></a> and to then <a href=\"https://stackoverflow.com/q/2693776/12149471\">remove the newline character</a>, if it exists.</p>\n<p>Below is the code for my function <code>get_line_from_user</code>, which works in a similar manner to <code>get_int_from_user</code> from the first section of my answer, except that it stores the input as a string, instead of converting it to an <code>int</code>. It contains all of the improvements mentioned above. In particular, it uses <code>fgets</code> instead of <code>scanf</code>.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// This function will read exactly one line of input from the\n// user. It will remove the newline character, if it exists. If\n// the line is too long to fit in the buffer, then the function\n// will automatically reprompt the user for input. On failure,\n// the function will never return, but will print an error\n// message and call &quot;exit&quot; instead.\nvoid get_line_from_user( const char *prompt, char *buffer, int buffer_size )\n{\n    for (;;) //infinite loop, equivalent to while(1)\n    {\n        char *p;\n\n        // prompt user for input\n        fputs( prompt, stdout );\n\n        // explicitly flushing the output stream\n        // may be necessary on some platforms\n        fflush( stdout );\n\n        // attempt to read one line of input\n        if ( fgets( buffer, buffer_size, stdin ) == NULL )\n        {\n            printf( &quot;Error reading from input!\\n&quot; );\n            exit( EXIT_FAILURE );\n        }\n\n        // attempt to find newline character\n        p = strchr( buffer, '\\n' );\n\n        // make sure that entire line was read in (i.e. that\n        // the buffer was not too small to store the entire line)\n        if ( p == NULL )\n        {\n            int c;\n\n            // a missing newline character is ok if the next\n            // character is a newline character or if we have\n            // reached end-of-file (for example if the input is\n            // being piped from a file or if the user enters\n            // end-of-file in the terminal itself)\n            if ( (c=getchar()) != '\\n' &amp;&amp; !feof(stdin) )\n            {\n                if ( c == EOF )\n                {\n                    printf( &quot;Error reading from input!\\n&quot; );\n                    exit( EXIT_FAILURE );\n                }\n\n                printf( &quot;Input was too long to fit in buffer!\\n&quot; );\n\n                // discard remainder of line\n                do\n                {\n                    c = getchar();\n\n                    if ( c == EOF )\n                    {\n                        // this error message will be printed if either\n                        // a stream error or an unexpected end-of-file\n                        // is encountered\n                        printf( &quot;Error reading from input!\\n&quot; );\n                        exit( EXIT_FAILURE );\n                    }\n\n                } while ( c != '\\n' );\n\n                // reprompt user for input by restarting loop\n                continue;\n            }\n        }\n        else\n        {\n            // remove newline character by overwriting it with\n            // null character\n            *p = '\\0';\n        }\n\n        // input was ok, so break out of loop\n        break;\n    }\n}\n</code></pre>\n", "tags": ["c", "scanf"]}
{"id": "555589b9-6c3b-4d6f-b43d-cbc0996ecae0", "text": "Q: Classic HTML blockquote consisting of top and bottom centered special character A: <p>If you're stuck with the the <code>&lt;blockquote&gt;&lt;p&gt;...&lt;/p&gt;&lt;/blockquote&gt;</code> structure, I'd recommend using pseudo-elements on the <code>&lt;p&gt;</code> for the quotation marks, and pseudo-elements on the <code>&lt;blockquote&gt;</code> for the ornamentation.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\" data-babel-preset-react=\"false\" data-babel-preset-ts=\"false\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>blockquote {\n  position: relative;\n  border: 1px solid gray;\n  margin: 1rem;\n  padding: 1rem;\n}\nblockquote:before,\nblockquote:after {\n  content: '\u223f';\n  display: block;\n  position: absolute;\n  width: 1em; /* set height/width based on font-size */\n  height: 1em;  /* set height/width based on font-size */\n  line-height: 0.8;  /* '\u223f' character is not naturally vertically centered; adjusting line-height can compensate */\n  text-align: center;\n  top: -0.5em; /* move it up half its height */ \n  left: calc(50% - 0.5em); /* move it left half its parent's width, minus half its own width, which will center it */\n  background: white;\n}\nblockquote:after {\n  top: unset; /* unset the previously declared \"top\" property because now we're styling the bottom one and don\u2019t want it to have a height derived from the \"top\" and \"bottom\" values, which is what would happen if it weren't unset */\n  bottom: -0.5em; /* move it down half its height */\n}\np {\n  margin: 0;\n}\np:before {\n  content: '\u201c'\n}\np:after {\n  content: '\u201d';\n}</code></pre>\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;blockquote&gt;\n  &lt;p&gt;I love you not only for what you are, but for what I am when I'm with you. I love you not only for what you have made of yourself, but for what you are making of me. I love you for ignoring the possibilities of the fool in me, and for accepting the possibilities of the good in me. I love you for helping me to construct of my life not a tavern, but a temple.&lt;/p&gt;\n&lt;/blockquote&gt;</code></pre>\n</div>\n</div>\n</p>\n", "tags": ["html", "css", "layout", "css-content", "blockquote"]}
{"id": "f26c4a7a-1fc8-4ed2-97fe-2dc634d3ed51", "text": "Q: Elements appearing in the up position A: <p>I reviewed your Java code carefully, and it seems like everything is correct even tough readability could be optionally improved.</p>\n<p>1. <strong>Delayed Component Loading:</strong><br />\nI can see that you are not using EDT (Event Dispatching Thread) in your code, it is type of Thread that we use in Java Swing to make components update easily and fastly.<br />\n2. <strong>Inheriting JFrame and then Initializing the Frame:</strong><br />\nActually, it is an interesting choice but actually doing so can lead to StackOverflowError, Instead it is truly better to finish creating instance of JFrame class.<br />\n3. <strong>Additional changes to JFrame:</strong><br />\nIt is totally optional but I added little changes to JFrame, so It works efficiently. otherwise its fine.<br />\n4. <strong>Important Part:</strong><br />\nPlease make sure that Components have their bounds set to correct coordinates such as (x, y, width, height).<br />\n5. <strong>Visibility of the Components:</strong><br />\nit is also optional but I highly recommend to set components to visible and focusable to false as well (Excluding JTextArea/JTextField because text may not appear after doing so).</p>\n<p>Fixed version of your code:</p>\n<pre><code>package main;\n\nimport javax.swing.*;\nimport javax.swing.border.TitledBorder;\n\npublic class Todolist {\n   private static final long serialVersionUID = 1L;\n   private JLabel jcriar, jtexto, jnum, jtexto1;\n   private JButton btcriar, btrem;\n   private JTextField txtcriar;\n   private JPanel jp;\n   private JFrame op;\n   int t = 0;\n   \n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -&gt; {\n            new Todolist().elemen();\n        }); //fixing component loading Delay (using EDT)\n    }\n    public Todolist(){\n        op = new JFrame(); // lets directly initialize with JFrame because the same Todo-list class is called and StackOverflowError is happening..\n   //   op.setTitle(&quot;To-Do List&quot;); optional\n        op.setLayout(null);\n   //   op.setResizable(false); optional \n        op.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        op.setSize(500, 400);\n        op.setLocationRelativeTo(null); // make the window appear at the middle/center of the screen\n        op.setVisible(true);\n    }\n    public void elemen(){\n      jcriar =  new JLabel(&quot;criar/remover&quot;);\n      txtcriar = new JTextField();\n      btcriar = new JButton(&quot;criar&quot;);\n      btrem = new JButton(&quot;remover&quot;);\n      \n      jp = new JPanel();\n      jp.setBounds(230, 100, 150, 200);\n      jp.setLayout(null);\n      jp.setBorder(new TitledBorder(&quot;&quot;));\n      \n      // MOST IMPORANT PART (Adjust the bounds as you want to make components appear in a right place)\n      jcriar.setBounds(30, 30, 100, 20);\n      txtcriar.setBounds(131, 30, 100, 20);      \n      btcriar.setBounds(232, 30, 80, 20);\n      btrem.setBounds(314, 30, 85, 20); //changed the bounds little bit to make text fit inside of the button\n    \n      jcriar.setFocusable(false);\n      btcriar.setFocusable(false);\n\n      btcriar.setVisible(true);\n      btrem.setVisible(true);\n      jcriar.setVisible(true);\n      txtcriar.setVisible(true);\n      \n      op.add(jcriar);\n      op.add(txtcriar);\n      op.add(btcriar);\n      op.add(jp);\n      op.add(btrem);\n    }\n}\n</code></pre>\n", "tags": ["java", "swing", "jpanel", "jbutton", "swingx"]}
{"id": "a7f94094-b5e2-4dbb-becf-992fbc09543e", "text": "Q: Conflicting assets with the same target path in ASP.NET Core 10 static web asset compression A: <p>Best fix for static web asset conflicts in .NET 10:</p>\n<p>Create a shared Razor Class Library (or regular project) for the duplicate assets.</p>\n<ol>\n<li><p>Move the conflicting file(s) from <code>wwwroot</code> in both projects to <code>wwwroot</code> in the new shared project.</p>\n</li>\n<li><p>Add a <code>&lt;ProjectReference&gt;</code> to this shared project in both <code>PortalAdmin</code> and <code>Portal</code>.</p>\n</li>\n<li><p>Reference the asset as <code>_content/SharedProjectName/path/to/file.js</code>.</p>\n</li>\n</ol>\n<p>This eliminates duplicates completely, keeps compression/fingerprinting intact, and is the cleanest, most scalable solution.</p>\n<p>(Quick alternative: In one <code>.csproj</code>, add <code>&lt;EnableStaticWebAssetCompression&gt;false&lt;/EnableStaticWebAssetCompression&gt;</code> to disable compression there and avoid the conflict.)</p>\n", "tags": ["c#", "asp.net-core", "static-files", ".net-10.0", "asp.net-core-10.0"]}
{"id": "da4f8c22-670b-42d2-9e05-15112f09c1de", "text": "Q: Quasar &lt;q-scroll-area /&gt; to stretch full height A: <p>When q-scroll-area is placed inside a flex column , the parent flex item must explicitly allow shrinking.\nBy default, flex items have min-height: auto, which prevents them from shrinking and breaks height calculation for scroll containers.</p>\n<pre><code>&lt;template&gt;\n  &lt;div class=&quot;column col fit&quot;&gt;\n    &lt;div class=&quot;&quot; style=&quot;min-height: 0&quot;&gt;\n      &lt;q-scroll-area class=&quot;q-pa-md fit&quot;&gt;\n        &lt;div v-for=&quot;dummymessage of 50&quot; :key=&quot;dummymessage&quot;&gt; message: {{ dummymessage }}&lt;/div&gt;\n      &lt;/q-scroll-area&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;col-auto&quot;&gt;INPUT&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>on the flex child that wraps q-scroll-area (the .col)</p>\n", "tags": ["html", "css", "vue.js", "quasar"]}
{"id": "379c2d18-b2a0-428f-8b22-953def4f2894", "text": "Q: Wait until curl command has finished A: <h2>Pitfall</h2>\n<p>If passing an URL to <code>curl</code> without quoting it and it contains an ampersand (&amp;) like</p>\n<pre class=\"lang-bash prettyprint-override\"><code>$ curl -L -o file.zip https:...?wp=20&amp;refresh=69...\n$ unzip file.zip\n</code></pre>\n<p>then the ampersand gets interpreted by the shell and it puts the curl command into background. Thus the script continues by the next command and will likely fail due to a non-existent <code>file.zip</code> which is still downloading by <code>curl</code>.</p>\n<p>So I would recommend to put the URL always in single quotes '' so that no meta character gets interpreted by the shell. Then everything should run sequential instead of accidentally asynchronous.</p>\n<pre><code>$ curl -L -o file.zip 'https:...?wp=20&amp;refresh=69...'\n$ unzip file.zip\n</code></pre>\n", "tags": ["linux", "bash", "curl"]}
