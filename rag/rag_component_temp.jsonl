{"id": "1e4a893f-4a64-4b89-a160-127eaee398d4", "text": "Q: Body {background-color} not working in external css? A: <p>I was having the same issue but you solved it for me. Even the page title counted as text, despite not being part of the body or a paragraph, so I put the CSS intro above it, first thing in the head.</p>\n", "tags": ["html", "css", "stylesheet", "background-color"]}
{"id": "50c4060f-8a53-4c60-be63-b3ccd29e4707", "text": "Q: Compatible versions of bucket4j - NoSuchMethodError: &#39;void io.github.bucket4j.distributed.proxy.ClientSideConfig&lt;init&gt;(...)&#39; A: <p>As you've already pointed out, there is a dependency collision for <code>bucket4j-core</code>. By running the command <code>gradle dependencies</code>, the console lists <code>bucket4j_jdk17-core:8.15.0</code> as the dependency explicitly imported, while <code>bucket4j-core:7.6.0</code> as a transitive dependency coming from <code>client-java-extended:19.0.2</code> &gt; <code>spring-cloud-kubernetes-commons:3.3.0</code> &gt; <code>spring-cloud-kubernetes-client-autoconfig:3.3.0</code> &gt; <code>spring-cloud-kubernetes-client-discovery:3.3.0</code>.</p>\n<p>These two dependencies are the ones that are actually clashing, where you're indirectly attempting to use a constructor for <code>ClientSideConfig</code> coming from version <a href=\"https://github.com/bucket4j/bucket4j/blob/8.15/bucket4j-core/src/main/java/io/github/bucket4j/distributed/proxy/ClientSideConfig.java\" rel=\"nofollow noreferrer\">8.15.0</a>, while at runtime it is loaded the version from <a href=\"https://github.com/bucket4j/bucket4j/blob/7.6/bucket4j-core/src/main/java/io/github/bucket4j/distributed/proxy/ClientSideConfig.java\" rel=\"nofollow noreferrer\">7.6.0</a>.</p>\n<p>Now, to fix your issue, even though transitive dependencies could be excluded or overridden, this could potentially break the dependencies that are based on them. So, the only two options I see are</p>\n<ol>\n<li><p>Downgrading <code>bucket4j_jdk17-core</code>, <code>bucket4j_jdk17-redis-common</code>, and <code>bucket4j_jdk17-lettuce</code> to <code>7.6.0</code>, if you don't strictly need <code>8.15.0</code>.</p>\n</li>\n<li><p>Use package relocation (or shading) for your explicit dependencies to avoid JAR hell (classpath conflicts).</p>\n</li>\n</ol>\n<h2>Package Relocation</h2>\n<p>Package relocation works by relocating the classes brought by your dependencies to a different custom classpath. Keep in mind that this solution works only if the relocated dependency or its transitive dependencies don't heavily rely on direct class reference (reflection, string-based referencing, etc.). However, in this scenario, relocation is generally safe since Bucket4j does not rely on reflection or <code>ServiceLoader</code> mechanisms, but you should thoroughly test all functionality after shading.</p>\n<p>Also, as a side note, we can see from the dependency tree that <code>bucket4j_jdk17-lettuce</code> already imports <code>bucket4j_jdk17-core</code> and <code>bucket4j_jdk17-redis-common</code>, so there is no need to re-import them explicitly. This simplifies the <code>build.gradle</code> and the configurations for the shadow plugin.</p>\n<p>A snippet of your <code>build.gradle</code> based on what you shared would look like this:</p>\n<pre><code>plugins {\n    id 'org.springframework.boot' version '3.5.0'\n    id 'io.spring.dependency-management' version '1.1.7'\n    id 'java'\n\n    // Add ShadowJar plugin\n    id 'com.github.johnrengelman.shadow' version '8.1.1'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ngroup = 'com.yourcompany'\nversion = '1.2.3'\n\next {\n    set('springCloudVersion', &quot;2025.0.0&quot;)\n}\n\ndependencies {\n    // remove core and redis-commons and leave only lettuce\n    implementation 'com.bucket4j:bucket4j_jdk17-lettuce:8.15.0'\n    implementation platform(&quot;org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}&quot;)\n    implementation 'org.springframework.cloud:spring-cloud-kubernetes-client-discovery'\n}\n\nshadowJar {\n    archiveClassifier.set(&quot;&quot;)\n\n    // relocate bucket4j-core, bucket4j-redis-commons, and bucket4j-lettuce\n    // since their classes are respectively under\n    //    - 'io.github.bucket4j'\n    //    - 'io.github.bucket4j.redis'\n    //    - 'io.github.bucket4j.redis.lettuce'\n    // So, this single pattern relocates all three of them\n    relocate (&quot;io.github.bucket4j&quot;, &quot;com.yourcompany.shadow.bucket4j&quot;)\n}\n</code></pre>\n", "tags": ["java", "spring-boot", "spring-cloud-kubernetes", "bucket4j"]}
{"id": "0b90756e-65bb-418f-9947-c519e9921ff2", "text": "Q: Migration ID4 to WSO2 IS: Strategy for validating granular permissions in Ocelot Gateway A: <p>In <strong>WSO2 Identity Server (IS)</strong>:</p>\n<ul>\n<li><p>A <strong>role</strong> is a collection of <strong>scopes</strong>, where scopes are defined under <strong>API resources</strong>.</p>\n</li>\n<li><p>During the OAuth2 <strong>authorize request</strong>, you request the scopes your client needs.</p>\n</li>\n<li><p>WSO2 IS performs <strong>role-based access control</strong>, resolves the allowed scopes for the user, and returns them in the JWT:</p>\n<ul>\n<li><p><code>&quot;scope&quot;</code> attribute in the <strong>JWT access token</strong></p>\n</li>\n<li><p><code>&quot;scope&quot;</code> attribute in the <strong>payload</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>If you want those scopes to appear in the access token as a <strong>multi-valued <code>permissions</code> attribute</strong>, you have two main options using <a href=\"https://is.docs.wso2.com/en/latest/guides/service-extensions/pre-flow-extensions/pre-issue-access-token-action/\" rel=\"nofollow noreferrer\">pre issue access token action</a> (extension point)</p>\n<hr />\n<h3><strong>Option 1: Request All Scopes Initially</strong></h3>\n<ul>\n<li><p>Request <strong>all scopes</strong> in the initial authorization request.</p>\n</li>\n<li><p>After role-based validation, filter the allowed scopes.</p>\n</li>\n<li><p>Add them as a <strong>new attribute</strong> named <code>&quot;permissions&quot;</code> in the access token using the service extension.</p>\n</li>\n<li><p>WSO2 supports this using the <strong>Pre-Issue Access Token extension point</strong>, which allows you to <strong>add, replace, or delete attributes</strong>.</p>\n</li>\n<li><p>Example go server: add the filtered scopes as <code>&quot;permissions&quot;</code>.</p>\n<pre><code>package main\n\nimport (\n  &quot;bytes&quot;\n  &quot;encoding/json&quot;\n  &quot;io&quot;\n  &quot;log&quot;\n  &quot;net/http&quot;\n  &quot;os&quot;\n)\n\n/*\n-------------------------\nRequest Models (updated)\n-------------------------\n*/\n\ntype RequestBody struct {\n  ActionType string `json:&quot;actionType&quot;`\n  Event      Event  `json:&quot;event&quot;`\n}\n\ntype Event struct {\n  AccessToken AccessToken `json:&quot;accessToken&quot;`\n}\n\ntype AccessToken struct {\n  Scopes []string `json:&quot;scopes&quot;`\n}\n\n/*\n-------------------------\nResponse Models\n-------------------------\n*/\n\ntype SuccessResponse struct {\n  ActionStatus string      `json:&quot;actionStatus&quot;`\n  Operations   []Operation `json:&quot;operations&quot;`\n}\n\ntype Operation struct {\n  Op    string      `json:&quot;op&quot;`\n  Path  string      `json:&quot;path&quot;`\n  Value CustomValue `json:&quot;value&quot;`\n}\n\ntype CustomValue struct {\n  Name  string      `json:&quot;name&quot;`\n  Value interface{} `json:&quot;value&quot;`\n}\n\n/*\n-------------------------\nHTTP Handler\n-------------------------\n*/\n\nfunc preIssueAccessTokenHandler(w http.ResponseWriter, r *http.Request) {\n  if r.Method != http.MethodPost {\n      http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)\n      return\n  }\n\n  // Read and log raw request body\n  bodyBytes, err := io.ReadAll(r.Body)\n  if err != nil {\n      http.Error(w, &quot;Failed to read request body&quot;, http.StatusBadRequest)\n      return\n  }\n\n  log.Printf(&quot;Incoming request body: %s\\n&quot;, string(bodyBytes))\n\n  // Restore body for JSON decoding\n  r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))\n\n  // Decode request\n  var req RequestBody\n  if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {\n      http.Error(w, &quot;Invalid JSON payload&quot;, http.StatusBadRequest)\n      return\n  }\n\n  // \u2705 Extract scopes from event.accessToken.scopes\n  scopes := req.Event.AccessToken.Scopes\n  if scopes == nil {\n      scopes = []string{}\n  }\n\n  // Build SUCCESS response\n  resp := SuccessResponse{\n      ActionStatus: &quot;SUCCESS&quot;,\n      Operations: []Operation{\n          {\n              Op:   &quot;add&quot;,\n              Path: &quot;/accessToken/claims/-&quot;,\n              Value: CustomValue{\n                  Name:  &quot;permissions&quot;,\n                  Value: scopes, // multi-valued permissions\n              },\n          },\n      },\n  }\n\n  w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)\n  w.WriteHeader(http.StatusOK)\n\n  if err := json.NewEncoder(w).Encode(resp); err != nil {\n      log.Printf(&quot;Failed to write response: %v&quot;, err)\n  }\n}\n\n/*\n-------------------------\nMain\n-------------------------\n*/\n\nfunc main() {\n  port := os.Getenv(&quot;PORT&quot;)\n  if port == &quot;&quot; {\n      port = &quot;8080&quot;\n  }\n\n  http.HandleFunc(&quot;/&quot;, preIssueAccessTokenHandler)\n\n  log.Printf(&quot;Pre-Issue Access Token service started on port %s\\n&quot;, port)\n  log.Fatal(http.ListenAndServe(&quot;:&quot;+port, nil))\n}\n</code></pre>\n</li>\n</ul>\n<hr />\n<h3><strong>Option 2: Request Roles Instead of Scopes</strong></h3>\n<ul>\n<li><p>If you <strong>cannot request all scopes upfront</strong>, request <strong>roles</strong> as an access token attribute.</p>\n</li>\n<li><p>In the <strong>Pre-Issue Access Token extension</strong>, call <strong><a href=\"https://is.docs.wso2.com/en/latest/apis/role-management/roles-v2-rest-api/\" rel=\"nofollow noreferrer\">WSO2 IS Role management APIs</a></strong> to:</p>\n<ol>\n<li><p>Retrieve scopes associated with each user role.</p>\n</li>\n<li><p>Derive the final scopes for the user.</p>\n</li>\n</ol>\n</li>\n<li><p>Populate these derived scopes in the <code>&quot;permissions&quot;</code> attribute in the access token.</p>\n</li>\n</ul>\n", "tags": ["oauth-2.0", "jwt", "identityserver4", "wso2-identity-server", "ocelot"]}
{"id": "e22ffead-09c0-4714-9cbf-2361a8c42541", "text": "Q: How to set grid-row on grids that are subgrids? A: <p><code>grid-row:1/4</code> specifies that the <em>sub-grid</em> spans the 3 rows defined in the grid <strong>parent</strong>.</p>\n<p>The parent rule is not <em>replaced</em> as you state, the <code>grid-row:1/4</code> <strong>refines</strong> how the sub-grid should act. It takes the information from the parent's defined three <code>auto</code> rows and spans them all.</p>\n<p>You don't specify how the sub-grid rows should look actually on the sub-grid, you define it on the parent.</p>\n", "tags": ["html", "css", "css-grid"]}
{"id": "87bfe240-8445-47a2-9ea0-d97e7cfa2367", "text": "Q: Count NULL values row-wise A: <p>The idea is to construct an array and apply higher-order function <a href=\"https://docs.snowflake.com/en/sql-reference/functions/reduce\" rel=\"nofollow noreferrer\">REDUCE</a>:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>SELECT *,\n  REDUCE(ARRAY_CONSTRUCT(t.*), 0, (acc, x) -&gt; acc + (x IS NULL)::INT) AS null_cnt\nFROM tab AS t;\n</code></pre>\n<p>Alternatively we can construct arrays twice:</p>\n<ul>\n<li>including nulls <a href=\"https://docs.snowflake.com/en/sql-reference/functions/array_construct\" rel=\"nofollow noreferrer\">ARRAY_CONSTRUCT</a></li>\n<li>excluding nulls <a href=\"https://docs.snowflake.com/en/sql-reference/functions/array_construct_compact\" rel=\"nofollow noreferrer\">ARRAY_CONSTRUCT_COMPACT</a></li>\n</ul>\n<p>Null count is a difference of arrays size.</p>\n<pre><code>SELECT *,\n  ARRAY_SIZE(ARRAY_CONSTRUCT(t.*))-ARRAY_SIZE(ARRAY_CONSTRUCT_COMPACT(t.*)) AS null_cnt\nFROM tab AS t;\n</code></pre>\n<p>Output:</p>\n<p><img src=\"https://i.sstatic.net/oJQJrBjA.png\" alt=\"enter image description here\" /></p>\n<hr />\n<p>This approach can be combined with <a href=\"https://docs.snowflake.com/en/sql-reference/sql/select#selecting-all-columns\" rel=\"nofollow noreferrer\">SELECT * EXCLUDE/ILIKE</a> if specific columns should be omitted:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>SELECT *,\n  ARRAY_SIZE(ARRAY_CONSTRUCT_COMPACT(t.*)) AS non_null_cnt,\n\n  REDUCE(ARRAY_CONSTRUCT(t.* EXCLUDE (id)), 0,\n         (acc, x) -&gt; acc + (x IS NULL)::INT) AS null_cnt,\n\n  REDUCE(ARRAY_CONSTRUCT(t.* ILIKE 'col%'), 0,\n         (acc, x) -&gt; acc + (x IS NULL)::INT) AS null_cnt2\nFROM tab AS t;\n</code></pre>\n", "tags": ["snowflake-cloud-data-platform"]}
{"id": "ea767722-5968-4ddb-aed9-07ec4a36b401", "text": "Q: PySpark Autoloader: How to enforce schema and fail on mismatch? A: <p>For schema evolution, you can check the supported AutoLoader's schema evolution here: <a href=\"https://docs.databricks.com/aws/en/data-engineering/schema-evolution#auto-loader\" rel=\"nofollow noreferrer\">Schema Evolution</a>.</p>\n<p>If you want to enforce schema and fail the streaming once new schema or column is detected, set the option <code>cloudFiles.schemaEvolutionMode</code> to <code>failOnNewColumns</code> .</p>\n<pre><code>spark.readStream \\\n.format(&quot;cloudFiles&quot;) \\\n.option(&quot;cloudFiles.format&quot;, &quot;parquet&quot;) \\\n.option(&quot;cloudFiles.schemaEvolutionMode&quot;, &quot;failOnNewColumns&quot;) \\\n.load(&quot;path&quot;) \\\n.writeStream \\\n.format(&quot;delta&quot;) \\\n.outputMode(&quot;append&quot;) \\\n.toTable(&quot;tablename&quot;)\n</code></pre>\n", "tags": ["apache-spark", "pyspark", "databricks", "spark-streaming", "databricks-autoloader"]}
