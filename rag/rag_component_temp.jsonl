{"id": "907b12fb-0022-4de9-92a0-d5d6160a5634", "text": "Q: User properties for non Apps Script add-ons A: <p>The Properties Service is part of Google Apps Script. To use this service, you should create an Apps Script project and develop server-side code to handle the calls to the Properties Service. Then you should deploy your project as a web app or as an API executable.</p>\n<p>References</p>\n<ul>\n<li><a href=\"https://developers.google.com/apps-script/guides/web\" rel=\"nofollow noreferrer\">Web Apps - Google Apps Script</a></li>\n<li><a href=\"https://developers.google.com/apps-script/api/concepts\" rel=\"nofollow noreferrer\">REST API - Google Apps Script</a></li>\n</ul>\n", "tags": ["google-apps-script", "google-cloud-platform", "google-workspace-add-ons"]}
{"id": "2d983082-3aa6-4deb-b725-d3eb9e201e7e", "text": "Q: INT 13h AH=2h throws the error AH=9h, but the offset is 0 A: <p>When using <code>INT 13h</code>, you have to consider <strong>64\u202fKB segment boundaries relative to ES</strong>. That\u2019s why your second code:</p>\n<pre><code>mov ah, 0x02\nmov al, 1\nmov ch, 2\nmov cl, 12\nmov dh, 1\nmov bx, 0x1FF0\nmov es, bx\nmov bx, 0x0000\nint 0x13\n</code></pre>\n<p>returns <code>AH = 09h</code> (DMA Boundary Error, sometimes called Segment Overflow).</p>\n<p>\u2705 Note that this is not a CPU limit, it\u2019s a BIOS limitation, and behavior can vary between BIOS implementations.</p>\n<p>As for reading above 0x20000: yes, it is possible as long as both of these conditions are met:</p>\n<p>1. ES * 16 + BX + sector_size \u2264 0xFFFFF \u2014 stays below 1\u202fMB in real mode.</p>\n<p>2. The buffer never crosses a 64\u202fKB linear memory boundary:</p>\n<pre><code>\n   linear_start = ES\\*16 + BX\n  \n   linear_end   = linear_start + sector_size - 1\n  \n   Both addresses must fall within the same 64\u202fKB block:\n  \n\n  \n   (linear_start &amp; 0xFFFF0) == (linear_end &amp; 0xFFFF0)\n  \n</code></pre>\n<p>For example, this would work:</p>\n<pre><code>mov es, 0x2000\nmov bx, 0x0000\n; read your sector here\n</code></pre>\n<p>The key is to <strong>avoid crossing a 64\u202fKB segment boundary</strong> when reading disk sectors with <code>INT 13h</code>.</p>\n", "tags": ["assembly", "x86", "x86-16", "bios"]}
{"id": "a71f5a3b-d98a-441c-8a83-b68a784cf318", "text": "Q: Map Drive in RunOnce Batch File A: <p>Persistent network drive mappings are always registered by Windows <strong>per user account</strong> and the network drives are connected <strong>only</strong> when the <strong>user signs/logs in</strong> and are automatically disconnected on user signs/logs out.</p>\n<p>There are two <strong>RunOnce</strong> registry keys as described by the Microsoft documentation page <a href=\"https://learn.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys\" rel=\"nofollow noreferrer\">Run and RunOnce Registry Keys</a>:</p>\n<pre><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n</code></pre>\n<p>On 64-bit Windows there are even two more <strong>RunOnce</strong> keys as above are for 64-bit applications and below are for 32-bit applications which does not matter for this task:</p>\n<pre><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKEY_CURRENT_USER\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce\n</code></pre>\n<p>It is no good idea to use <code>HKLM</code> or <code>HKCU</code> of the administrator account on using the administrator account to register the batch file to be executed once for persistent mapping the share to drive letter <code>M</code>.</p>\n<p>Better would be registering the batch file under</p>\n<pre><code>HKEY_USERS\\.DEFAULT\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n</code></pre>\n<p>And the batch file uses <code>reg delete</code> for deleting itself from</p>\n<pre><code>HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n</code></pre>\n<p>But this works only if the user account on which the persistent drive mapping should be done once is not already created when registering the batch file in default user account registry hive.</p>\n<p>I would be also possible not using <strong>RunOnce</strong> at all and create instead a shortcut (*.lnk) file in the directory read from registry with <code>reg query</code> from value <strong>Startup</strong> under registry key</p>\n<pre><code>HKEY_USERS\\.DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\n</code></pre>\n<p>And the batch file on execution deletes the shortcut file in the startup directory of the current user account, i.e. in directory read from registry with <code>reg query</code> from value <strong>Startup</strong> under registry key</p>\n<pre><code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\n</code></pre>\n<p>This approach, also working only with user account on which to execute the batch file does not already exist, is perhaps even better than running the batch file via <strong>RunOnce</strong> as the shortcut file can contain properties like window height and width suitable for this task.</p>\n<p>By the way: The command line</p>\n<pre><code>NET USE M: \\\\%PMHOSTNAME%\\Data /user:%computername%\\[username] [password] /persistent:yes\n</code></pre>\n<p>is enough to create the drive mapping and enable persistent saving of <strong>all</strong> network drive connections in registry for current user account. The line above and the line below this line are counterproductive in worst case.</p>\n<p>For the deletion use:</p>\n<pre><code>%SystemRoot%\\System32\\net.exe USE M: /DELETE /YES 2&gt;nul\n</code></pre>\n<p>It is better to specify in a batch file external <a href=\"https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/windows-commands\" rel=\"nofollow noreferrer\">Windows commands</a> like <strong>NET</strong> with their fully qualified file names for a more fail-safe and faster execution of the batch file because in this case the <em>Windows Command Processor</em> <code>cmd.exe</code> does not need to search for the file with name <code>net</code> in current directory and next in one directory after the other listed in value of environment variable <code>PATH</code> having a file extension listed in value of environment variable <code>PATHEXT</code>.</p>\n<hr />\n<p><strong>Additional information about</strong> <code>/PERSISTENT:YES</code> <strong>and</strong> <code>/PERSISTENT:NO</code></p>\n<p>Most people think that the use of <code>/PERSISTENT:YES</code> on using <strong>NET USE</strong> to create a network drive assignment/association/mapping is for remembering the specified network drive association by Windows for automatic restoring the network drive mapping on user signs in the next time while <code>/PERSISTENT:NO</code> is for explicitly specifying that Windows should not remember the specified network drive association. That is true and false at the same time.</p>\n<p>The behavior of <code>/PERSISTENT:YES</code> is as follows on using the following command lines:</p>\n<pre><code>NET USE /PERSISTENT:YES\nNET USE M: \\\\Server\\DataShareM /persistent:yes\n%SystemRoot%\\System32\\net.exe USE N: \\\\Server\\DataShareN\n</code></pre>\n<p>There is first modified the registry string value <code>SaveConnections</code> of type <code>REG_SZ</code> under the registry key <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections</code> to the string value <code>yes</code>. The registry key <code>Persistent Connections</code> and the registry string value <code>SaveConnections</code> are both created on not already existing as by Windows default.</p>\n<p><strong>All</strong> network associations created next either in same command line (second command line in the example above) or with the next command lines (third command line in the example above) or with <em>Windows File Explorer</em> or other applications are stored now in the registry hive of the current user under the registry key\n<code>HKEY_CURRENT_USER\\Network</code>. The mapping of the network drive <code>N:</code> is also stored under registry key <code>HKEY_CURRENT_USER\\Network\\N</code> in the example above although there is no <code>/persistent:yes</code> used on the command line.</p>\n<p>As long as the registry string value <code>SaveConnections</code> is existing under registry key <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections</code> with the string value <code>yes</code>, all network drive mappings are stored under the registry key <code>HKCU\\Network</code> even on being created with <code>%SystemRoot%\\System32\\net.exe USE</code> without using the <code>persistent</code> option at all.</p>\n<p>The behavior of <code>/PERSISTENT:NO</code> is as follows on using the following command lines:</p>\n<pre><code>NET USE /PERSISTENT:NO\nNET USE X: &quot;\\\\NAS\\Data Share X&quot; /persistent:no\n%SystemRoot%\\System32\\net.exe USE Y: &quot;\\\\NAS\\Data Share Y&quot;\n</code></pre>\n<p>The first two command lines modify the registry string value <code>SaveConnections</code> under registry key <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections</code> to the string value <code>no</code>. The registry key <code>Persistent Connections</code> and the registry string value <code>SaveConnections</code> are both created on not already existing as by Windows default.</p>\n<p>There is <strong>not</strong> deleted any network drive mapping currently stored under registry key <code>HKEY_CURRENT_USER\\Network</code>.</p>\n<p>The second and the third command line create the mappings for the network drives <code>X:</code> and <code>Y:</code> but now with <code>SaveConnections</code> having the string value <code>no</code> <strong>without</strong> changing anything under the registry key <code>HKEY_CURRENT_USER\\Network</code>. The registry keys <code>X</code> and <code>Y</code> under the registry key <code>HKEY_CURRENT_USER\\Network</code> on perhaps already existing on execution of second or third command line are kept without any modification.</p>\n<p>The execution of <code>NET USE M: /DELETE</code> or <code>%SystemRoot%\\System32\\net.exe USE Y: /DELETE /YES 2&gt;nul</code> results <strong>always</strong> in the removal of the registry keys <code>M</code> and <code>Y</code> from the registry key <code>HKEY_CURRENT_USER\\Network</code> independent on existence and current value of the registry string value <code>SaveConnections</code> under the registry key <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections</code>.</p>\n<p>It is important to know in my opinion that the use of <code>/PERSISTENT:YES</code> or <code>/PERSISTENT:NO</code> respectively a checked or unchecked <em>Reconnect at sign-in</em> option in the <strong>Map Network Drive</strong> dialog window changes the string value of <code>SaveConnections</code> to <code>yes</code> or <code>no</code> <strong>permanently</strong> and not for just the network drive mapping created now. That change of the <code>SaveConnections</code> string value affects all other network drive associations/mappings made later with command <strong>NET USE</strong> without the <code>/persistent</code> option too.</p>\n<p>Here is a batch file for demonstration which maps the network drives <code>M:</code> and <code>N:</code> persistent for an automatic reconnect at next user sign in and the network drives <code>X:</code> and <code>Y:</code> just for the current user session. The user's configuration for saving network connections is kept as is and the other network drive mappings created by the user too.</p>\n<pre><code>@echo off\nsetlocal EnableExtensions DisableDelayedExpansion\nset &quot;SaveConnections=&quot;\n\nrem Does the registry key Persistent Connections exist at all?\n%SystemRoot%\\System32\\reg.exe QUERY &quot;HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections&quot; 1&gt;nul 2&gt;nul || (set &quot;PersistentConnections=&quot; &amp; goto MapNetDrives)\nset &quot;PersistentConnections=1&quot;\n\nrem Get the current string value &quot;yes&quot; or &quot;no&quot; of registry string value\nrem SaveConnections on existing in the registry hive of the current user.\nrem Ignore an existing and most likely corrupted registry string value\nrem SaveConnections on having a different value than &quot;yes&quot; or &quot;no&quot;.\nfor /F &quot;skip=2 tokens=1,3&quot; %%G in ('%SystemRoot%\\System32\\reg.exe QUERY &quot;HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections&quot; /v SaveConnections 2^&gt;nul') do if /I &quot;%%G&quot; == &quot;SaveConnections&quot; if /I &quot;%%H&quot; == &quot;yes&quot; (set &quot;SaveConnections=YES&quot;) else if /I &quot;%%H&quot; == &quot;no&quot; set &quot;SaveConnections=NO&quot;\n\n:MapNetDrives\nrem Delete the network drive mappings M: N: X: Y: on already existing.\nfor %%I in (M N X Y) do %SystemRoot%\\System32\\net.exe USE %%I: /DELETE /YES 1&gt;nul 2&gt;nul\n\nrem Map persistent for an automatic reconnect the network drives M: and N:.\n%SystemRoot%\\System32\\net.exe USE M: \\\\Server\\DataShareM /PERSISTENT:YES 1&gt;nul\n%SystemRoot%\\System32\\net.exe USE N: \\\\Server\\DataShareN 1&gt;nul\n\nrem Map the network drives X: and Y: without being automatically reconnected.\n%SystemRoot%\\System32\\net.exe USE /PERSISTENT:NO 1&gt;nul\n%SystemRoot%\\System32\\net.exe USE X: &quot;\\\\NAS\\Data Share X&quot; 1&gt;nul\n%SystemRoot%\\System32\\net.exe USE Y: &quot;\\\\NAS\\Data Share Y&quot; 1&gt;nul\n\nrem Existed the registry string value SaveConnections before with either\nrem the string value &quot;yes&quot; or the string value &quot;no&quot;, then restore its value.\nif defined SaveConnections %SystemRoot%\\System32\\net.exe USE /PERSISTENT:%SaveConnections% 1&gt;nul &amp; goto MapNetDone\n\nrem Delete the registry key Persistent Connections on not initially existing.\nif not defined PersistentConnections %SystemRoot%\\System32\\reg.exe DELETE &quot;HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections&quot; /f 1&gt;nul &amp; goto MapNetDone\n\nrem The registry string value SaveConnections did not exist before. It\nrem is deleted for that reason to restore the initial user configuration.\n%SystemRoot%\\System32\\reg.exe DELETE &quot;HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections&quot; /v SaveConnections /f 1&gt;nul\n\n:MapNetDone\nendlocal\n</code></pre>\n", "tags": ["windows", "batch-file"]}
{"id": "4818e657-16e8-4225-babe-311d4b0a5d8d", "text": "Q: How To Convert a SWF / DisplayObject to SVG data? A: <p>I write a Python script to make SWF2SVG working here, aiming to convert my vector illustrating in Flash to .svg.<br />\n<a href=\"https://i.sstatic.net/yrAFOqS0.png\" rel=\"nofollow noreferrer\">enter image description here</a></p>\n<p>It's a step by step developing:</p>\n<p><a href=\"https://i.sstatic.net/BH1reTdz.png\" rel=\"nofollow noreferrer\">enter image description here</a><br />\n<a href=\"https://i.sstatic.net/o7dQ0CA4.png\" rel=\"nofollow noreferrer\">enter image description here</a></p>\n<p><a href=\"https://i.sstatic.net/oTjIch8A.png\" rel=\"nofollow noreferrer\">enter image description here</a></p>\n<p><a href=\"https://i.sstatic.net/Vkjlhath.png\" rel=\"nofollow noreferrer\">enter image description here</a></p>\n<p>\u6162\u6162\u7684\u5c31\u5b8c\u7f8e\u5b9e\u73b0 swf to svg \u4e86</p>\n<p><a href=\"https://i.sstatic.net/c4TczUgY.png\" rel=\"nofollow noreferrer\">enter image description here</a></p>\n", "tags": ["svg", "flash"]}
{"id": "6771d0d3-31a8-4d9d-9b07-89ea5e43a9b9", "text": "Q: Recursive function to print diamond giving output with many blank lines A: <p>Here Recursive.  Since Java doesn't allow default variables on functions I added an overload for printDiamond()</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.lang.Math;\n\nclass Diamond {\n    public static void printDiamond(int w) { // for use with just the width \n       printDiamond(w, w - 1); \n    }\n    // Recursive Diamond printer \n    public static void printDiamond(int w,int i) { \n       if (i &lt; (-w + 1))  return;\n       int stars = w - Math.abs(i);\n       System.out.println(&quot; &quot;.repeat((w-stars)/2+1) + &quot;*&quot;.repeat(stars)); \n       printDiamond(w, i - 2);\n    }\n    \n    public static void main(String[] args) { \n       int wide = 5; \n       if (args.length &gt; 0) {\n         try {\n            wide = Integer.parseInt(args[0]);\n         } catch (NumberFormatException e) {\n            System.err.println(&quot;Error: The width argument is not a valid integer.&quot;);\n         }\n       } else {\n          System.out.println(&quot;Usage: java Diamond &lt;width&gt; Default: 5&quot;);\n       }\n       System.out.format(&quot;Diamond %d Wide%n&quot;, wide);\n       printDiamond(wide); \n    } \n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ javac Diamond.java \n$ java Diamond 8\nDiamond 8 Wide\n    *\n   ***\n  *****\n *******\n *******\n  *****\n   ***\n    *\n\n$ java Diamond 11\nDiamond 11 Wide\n      *\n     ***\n    *****\n   *******\n  *********\n ***********\n  *********\n   *******\n    *****\n     ***\n      *\n</code></pre>\n", "tags": ["java", "recursion"]}
