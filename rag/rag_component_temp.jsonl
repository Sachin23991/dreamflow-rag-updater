{"id": "5701ef4d-9c2e-4000-b4b5-38121699c918", "text": "Q: C#: How to create a mock Azure.AI.OpenAI.ChatCompletions object to test functions using OpenAI? A: <p>for those who using Azure.AI.OpenAI &gt;= 2.0.0</p>\n<pre><code> private static ChatCompletion CreateFakeChatCompletion(string content)\n {\n     return OpenAIChatModelFactory.ChatCompletion(Guid.NewGuid().ToString(), ChatFinishReason.Stop, new ChatMessageContent(content));\n\n }\n</code></pre>\n", "tags": ["c#", "openai-api", "azure-openai", "azure-ai"]}
{"id": "a5292e92-c161-4409-afc6-8810a9461d5b", "text": "Q: Shape intersection design A: <p>Here is another example that mixes both approaches, i.e. using a <code>specialized</code> tag for knowing when a struct is specialized and some <code>static_assert</code> that forces a compile error when the requirements are not met (the error message is more readable IMHO compared to a SFINAE approach like yours)</p>\n<pre><code>template&lt;typename A, typename B&gt;\nclass Intersect\n{\npublic:\n    static constexpr bool ABspecialized = is_specialized&lt;Intersector&lt;A,B&gt;&gt;::value;\n    static constexpr bool BAspecialized = is_specialized&lt;Intersector&lt;B,A&gt;&gt;::value;\n\n    // make sure at compile time that we have at least (A,B) or (B,A) but not both\n    static_assert (ABspecialized xor BAspecialized);\n\n    static void on(const A&amp;  a, const B&amp; b) {  on_impl(a,b); }\n    static void on(const B&amp;  b, const A&amp; a) {  on_impl(a,b); }\n\nprivate:\n    static void on_impl(const A&amp; a, const B&amp; b) {\n        if constexpr(ABspecialized) {  Intersector&lt;A,B&gt;::intersect(a,b);  }\n        else                        {  Intersector&lt;B,A&gt;::intersect(b,a);  }\n    }\n};\n</code></pre>\n<p>where <code>is_specialized</code> is defined as follows:</p>\n<pre><code>template&lt;typename, typename = void&gt;\nstruct is_specialized : std::true_type {};\n\ntemplate&lt;typename T&gt;\nstruct is_specialized&lt;T, std::void_t&lt;typename T::unspecialized&gt;&gt; : std::false_type {};\n\ntemplate&lt;typename A, typename B&gt;\nstruct Intersector  {\n    using unspecialized = void;\n};\n</code></pre>\n<p>Note that this proposal should cope with reversing order of arguments:</p>\n<pre><code>int main ()\n{\n    Hexagon h;\n    Triangle t;\n\n    Intersect&lt;Hexagon,Triangle&gt;::on(h,t);\n    Intersect&lt;Hexagon,Triangle&gt;::on(t,h);\n    Intersect&lt;Triangle,Hexagon&gt;::on(h,t);\n    Intersect&lt;Triangle,Hexagon&gt;::on(t,h);\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/z/YT7b3j7jz\" rel=\"nofollow noreferrer\">Demo</a></p>\n<p>Note that one might make the whole thing a little more generic like <a href=\"https://godbolt.org/z/h83do16x5\" rel=\"nofollow noreferrer\">this</a>.</p>\n", "tags": ["c++", "templates", "c++17", "intersection"]}
{"id": "136cdefe-fd5e-44fe-8932-ea4d0faaf3dc", "text": "Q: How to handle tasks that depend on the outcome of other tasks A: <p><a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\" rel=\"nofollow noreferrer\">CompletableFuture</a> is a way of running tasks on separate threads too and checking result.\nSo you can control the whole picture with the loop, sending one completable future at a time. <a href=\"https://stackoverflow.com/questions/51493896/execute-runnables-in-a-list\">Runnable</a> is also taking a look at for threading too, but <a href=\"https://stackoverflow.com/questions/35809827/java-8-completablefuture-allof-with-collection-or-list\">CompletableFuture</a> should be sufficient.</p>\n", "tags": ["java", "spring", "java.util.concurrent"]}
{"id": "3ef6426d-f646-4ca7-847f-5e294bdd108f", "text": "Q: Pickling error work-around when passing decorators to multiprocessing module A: <p>The related <code>functools.partial() </code>allows to call a function: <a href=\"https://docs.python.org/3/library/functools.html#functools.partial\" rel=\"nofollow noreferrer\">docs.python.org/3/library/functools.html#functools.partial</a></p>\n", "tags": ["python", "pickle", "python-multiprocessing", "python-decorators"]}
{"id": "3e538e49-457e-44bd-b51e-386ebc3e8f82", "text": "Q: How to update VS Code on Windows? A: <p>I encountered the same issue and :</p>\n<ul>\n<li><p>I didn't run VSCode with admin privileges</p>\n</li>\n<li><p>Update Mode was set to &quot;default&quot;</p>\n</li>\n</ul>\n<p>Issue was that some of my previous VSCode update broke and I was running VSCode from a &quot;_&quot; folder (e.g. <code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\Programs\\Microsoft VS Code\\_\\Code.exe</code> )</p>\n<p>This issue is known : <a href=\"https://github.com/microsoft/vscode/issues/252063\" rel=\"nofollow noreferrer\">https://github.com/microsoft/vscode/issues/252063</a></p>\n<p><strong>Solution in this case :</strong></p>\n<p>Move all files from :</p>\n<p><code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\Programs\\Microsoft VS Code\\_\\</code></p>\n<p>To parent directory :</p>\n<p><code>C:\\Users\\&lt;user&gt;\\AppData\\Local\\Programs\\Microsoft VS Code\\</code></p>\n<p>Run VSCode again and go to <code>Help &gt; Check for updates</code> and it will automatically update without downloading zip file.</p>\n", "tags": ["visual-studio-code", "windows-10", "software-update"]}
{"id": "b78a6ba2-b4df-484b-bcdd-778910951c62", "text": "Q: Slow numpy and pandas imports on Google Cloud Run A: <p>This is a known issue in the Python ecosystem.</p>\n<blockquote>\n<p>all modules are imported at runtime, and some modules are 300-500MB large in size</p>\n</blockquote>\n<p>There are tons of complaints about slow import times. The best thread is this one: <a href=\"https://stackoverflow.com/questions/16373510/improving-speed-of-python-module-import\">improving speed of Python module import</a></p>\n<p>As regarding Cloud Run, I have experimented with various ways, and nothing was able to reduce the slowness drastically.</p>\n<p><strong>UPDATE: After years of experiment we wrote a script at build time, that optimizes the libraries for lazy loading. It is published as <a href=\"https://martonkodok.medium.com/hacking-adks-importer-how-we-slashed-24-second-cold-start-in-half-def058a7c8dc\" rel=\"nofollow noreferrer\">article</a> and there you will find the linked github file as well. I link the article as it has explainations. This reduced a cold start by 70%.</strong></p>\n<p>---</p>\n<p><strong>If you want to use in serverless environment</strong>, or in other cold start ecosystem,<br />\nbe aware <strong>the cold start can be in order of 10 seconds</strong> magnitude because of the &quot;imports&quot;.</p>\n<pre><code> importing pandas took 1.42 seconds\n importing numpy took 1.90 seconds\n importing torch took 2.84 seconds \n importing torchvision took 0.78 seconds\n importing IPython took 1.22 seconds\n importing sklearn took 1.51 seconds\n importing import dask took 0.74 seconds\n</code></pre>\n<p><strong>Try 1:</strong></p>\n<p>No solution with bumping up the CPU to maximum possible</p>\n<p><strong>Try 2:</strong></p>\n<p>No speed improvement with rewrite imports as:</p>\n<pre><code>pd = imp.load_module(&quot;pandas&quot;,None,&quot;/usr/local/lib/python3.10/site-packages/pandas&quot;,('','',5))\n</code></pre>\n<p>this way the interpreter skips the &quot;finding&quot; phase, but still timing of this is the same, so there is no speed improvement over this.</p>\n<p><strong>Try 3:</strong></p>\n<p>No benefits of using install requirements with compile</p>\n<pre><code>RUN python -m pip install --no-cache-dir --compile -r requirements-prod.txt\nRUN python -m compileall .\n</code></pre>\n<p>I even explored the container and the <code>__pycache__</code> was built for all the modules and app code as well, but no improvement over the cold start time.</p>\n<p><strong>Summary:</strong></p>\n<p>A good read about a <a href=\"https://scientific-python.org/specs/spec-0001/\" rel=\"nofollow noreferrer\">lazy load proposal is here</a></p>\n", "tags": ["python", "pandas", "docker", "google-cloud-platform", "alpine-linux"]}
{"id": "3bcfdbfa-74fc-4590-8702-2a35846d54db", "text": "Q: Coding a website in C? A: <blockquote>\n<hr />\n<pre><code>#include \u00a9stdio.h\u00ae\nint extern_var = 10;\nVoid demo ();\n{\n  auto int a = 1;\n  register int r = 2;\n  static int s = 3;\n  extern int extern_var;\n  Printf (&quot;Auto:  %d\\nRegister:  %d\\nStatic:  %d\\nExtern:  %d\\n&quot;, a, r, s, extern_var);\ns++;\n}\n int main ()\n{\n demo ();\n demo ();\n return 0;\n</code></pre>\n<div class=\"s-table-container\"><table class=\"s-table\">\n<thead>\n<tr>\n<th>header 1</th>\n<th>header 2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table></div>\n<pre><code>\n\n</code></pre>\n</blockquote>\n", "tags": ["c"]}
{"id": "1af84dd1-c95c-4b69-8fa8-d3cada08bf81", "text": "Q: How do select ref OID without table object join when type is ref with OID? A: <p>Thank you for your response but I don\u2019t have any problem with dangling concept which is not related to ref with rowid and even if ref is not with rowid , dangling can be used in where clause also.</p>\n<blockquote>\n<p>object-relational-developers-guide / Performance Improvement for Object Access Using the WITH ROWID Option/The WITH ROWID option is only a hint because, when you use this option, Oracle checks the OID of the row object with the OID in the REF. If the two OIDs do not match, Oracle uses the OID index instead. The rowid hint is not supported for scoped REFs, for REFs with referential integrity constraints.</p>\n</blockquote>\n<p>I wanted to know that is it possible to have ref rowid same as other fields in mentioned select without adding table object join which is t_tab_object here because ref is with rowid.</p>\n", "tags": ["sql", "oracle-database", "object", "types", "oracle23ai"]}
{"id": "9978e635-76e4-4db2-a295-5d08e10875d1", "text": "Q: Why does setting shadowCopyBinAssemblies=&quot;false&quot; have no effect? A: <p>I assume you might want to disable shadow copying to reduce startup time and disk I/O, where you have controlled deployment processes and don't need hot-swapping of DLLs.</p>\n<p>What <code>shadowCopyBinAssemblies=&quot;false&quot;</code> actually does is that it only controls whether assemblies in the <code>bin</code> folder are shadow copied. It doesn't affect other assemblies referenced by your application. Even with this set to <code>false</code>, ASP.NET still creates the Temporary ASP.NET Files directory and performs various compilation and caching operations there. You'll still see files in that location.</p>\n<p>If your goal is to improve first-load performance, then use ASP.NET precompilation to eliminate runtime compilation entirely, or keep the application pool alive longer.</p>\n", "tags": ["c#", "asp.net", "iis"]}
