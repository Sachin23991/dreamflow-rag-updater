{"id": "f4d03d1d-5480-4061-a154-11a836b81148", "text": "Q: Ideas for converting straight quotes to curly quotes A: <p>You can't parse English quotation marks with regex because English quotations <a href=\"https://stackoverflow.com/a/1732454/59087\">can't be parsed</a> by regex. Regular expressions aren't sufficiently expressive to parse English quotations. You can get by in a few situations, but a general solution can't be created using regex.</p>\n<p>Given:</p>\n<ul>\n<li>A lexer to create lexemes from a character stream.</li>\n<li>An emitter that publishes various types of quotation marks.</li>\n<li>An ambiguity resolver that creates nested trees.</li>\n<li>A set of known ambiguous and unambiguous contractions.</li>\n<li>A circular buffer of lexemes, length 4.</li>\n</ul>\n<p>Then, super-broadly, one possible algorithm follows:</p>\n<ol>\n<li>Iterate over the document using the lexer.</li>\n<li>Pass <strong>lexemes</strong> from the lexer to the emitter.</li>\n<li>Push the <strong>lexeme</strong> into the emitter's circular buffer.</li>\n<li>Parse 4 <strong>lexemes</strong> at a time in the emitter to categorize the curl:\n<ul>\n<li>opening/closing double/single quote</li>\n<li>apostrophe</li>\n<li>straight quote</li>\n<li>ambiguous opening single quote</li>\n<li>ambiguous closing single quote</li>\n<li>ambiguous single quote</li>\n<li>ambiguous double quote</li>\n</ul>\n</li>\n<li>Emit the categorized quotation mark as a <strong>token</strong> to the ambiguity resolver.</li>\n<li>Have the resolver create trees (for tracking nested quotes):\n<ol>\n<li>open a tree for opening quote <strong>tokens</strong> (single/double)</li>\n<li>close the tree for closing quote <strong>tokens</strong> (single/double)</li>\n<li>otherwise, track any ambiguous <strong>tokens</strong> in the current tree</li>\n</ol>\n</li>\n<li>After all tokens are in nested trees:\n<ol>\n<li>start at the root</li>\n<li>disambiguate the tokens</li>\n<li>sort the list of tokens</li>\n<li>resolve the remaining tokens</li>\n<li>disambiguate the tokens (yes, again)</li>\n<li>relay the tokens to the document parser</li>\n</ol>\n</li>\n</ol>\n<p>Disambiguating entails replacing ambiguous quotation marks with resolvable equivalents. Basically, you need to count the number of ambiguous leading, lagging, and indeterminate single quotes. Based on whether the current level of the tree already contains some combination of leading/lagging quotes, you can ascertain whether the ambiguous quote is a: closing single quote, opening quote, or apostrophe.</p>\n<p>It's not a trivial algorithm, as it can require:</p>\n<ul>\n<li>A circular buffer</li>\n<li>A lexer (tokenizer)</li>\n<li>A parser (emitter)</li>\n<li>A resolver (ambiguities)</li>\n<li>A tree</li>\n<li>A set of contractions (ambiguous and unambiguous)</li>\n</ul>\n<p>Here are some screenshots of <a href=\"https://whitemagicsoftware.com/keenquotes/\" rel=\"nofollow noreferrer\">KeenQuotes</a>, which is integrated into my text editor, <a href=\"https://keenwrite.com\" rel=\"nofollow noreferrer\">KeenWrite</a>:</p>\n<p><a href=\"https://i.sstatic.net/Q6c3O.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/Q6c3O.png\" alt=\"keenquotes 01\" /></a></p>\n<p>Nit: It's <code>'70s</code>, not <code>'70's</code> because decades cannot possess anything.</p>\n<p><a href=\"https://i.sstatic.net/cWORG.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/cWORG.png\" alt=\"keenquotes 02\" /></a></p>\n", "tags": ["algorithm", "language-agnostic", "typography"]}
{"id": "8362acdd-5827-41c8-972d-60c7e0ab2ff9", "text": "Q: PascalScript Unable to Break in try...except block A: <p>I cannot say if that is the expected output or not in pascalscript, as it depends on that language specification. I have only Delphi available, and it produces the output 0,1,2,3,4,5,6,7,8,9,10 (because the division by 0 does not cause an error, but instead J gets the value <code>INF</code>), but if I modify the code so that an exception really is raised, then the code produces the output 0,error in Delphi, i.e. <code>break</code> in the <code>except</code> clause does work like you expect, in Delphi.</p>\n<p>How should you handle this situation? I'd say:</p>\n<ol>\n<li><p>Get in contact with the makers of your pascalscript interpreter and ask them, possibly file a bug report.</p>\n</li>\n<li><p>In the meantime, modify your code to this, introducing a Boolean variable:</p>\n</li>\n</ol>\n<pre><code>ErrorEncountered := False;\n\nfor I := 0 to 10 do\nbegin\n  try\n    Writeln(IntToStr(I));\n    K := 2;\n    J := K / I;\n  except\n    Writeln('error');\n    ErrorEncountered := True;\n  end;\n  if ErrorEncountered then\n    Break;\nend;\n</code></pre>\n", "tags": ["delphi", "freepascal", "pascalscript"]}
{"id": "a930eae2-432d-4cb7-9b2f-beb538cfc3e4", "text": "Q: How to install &quot;make&quot; in ubuntu? A: <p>I have no idea what linux distribution \"ubuntu centOS\" is. Ubuntu and CentOS are two different distributions.</p>\n\n<p>To answer the question in the header:\nTo install make in ubuntu you have to install build-essentials</p>\n\n<pre><code>sudo apt-get install build-essential\n</code></pre>\n", "tags": ["ubuntu", "makefile", "centos", "yum", "apt"]}
