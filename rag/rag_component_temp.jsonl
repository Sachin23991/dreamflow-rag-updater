{"id": "fb2f6726-8416-41a3-918d-4187d1ecd077", "text": "Q: How to properly wait for second player before starting simulation? A: <p>Afaik what you would have to do is explicitly &quot;refresh&quot; the <code>RealtimeClient</code></p>\n<p>Not a <code>Quantum</code> expert here but afaik you would have to regularly call <code>Service</code> on the <code>RealtimeClient</code> (<a href=\"https://doc.photonengine.com/quantum/current/getting-started/migration-guide?utm_source=chatgpt.com\" rel=\"nofollow noreferrer\">formerly called <code>LoadBalancingClient</code></a>) it in order to do perform a poll-based synchronization.</p>\n<p>On the phone right now and can't confirm but a quick fix should be something like e.g.</p>\n<pre><code>while (Client.CurrentRoom.PlayerCount &lt; 2) \n{\n    // Refresh the Client so it syncs all properties (and also doesn't get disconnected)\n    Client.Service();\n\n    await Task.Delay(200);\n}\n</code></pre>\n", "tags": ["c#", "unity-game-engine", "photon", "photon-quantum"]}
{"id": "7bf1a1c4-d46e-44f9-98d2-2ca6bf81db11", "text": "Q: How to initialize and manage DB connections in a Livekit agent? A: <p>It is very important to understand that where to initialize connections so they are created once per worker process  and not once per room/session. Based on the <a href=\"https://docs.livekit.io/agents/logic/external-data/\" rel=\"nofollow noreferrer\">Livekit Documentation</a>, you can try something like loading the static resources in a function first.</p>\n<p><em>app/worker.py</em></p>\n<pre><code>import os\nimport asyncio\nfrom beanie import init_beanie, Document\nfrom pymongo import AsyncMongoClient\nfrom livekit import agents\nfrom livekit.agents import AgentSession, Agent\n\n\nclass Sample(Document):\n    name: str\n\n\n_mongo_client: AsyncMongoClient | None = None\n_beanie_ready: bool = False\n\nasync def prewarm():\n    &quot;&quot;&quot;Runs once when the worker process starts.&quot;&quot;&quot;\n    global _mongo_client, _beanie_ready\n    if _beanie_ready:\n        return\n    _mongo_client = AsyncMongoClient(os.environ[&quot;MONGODB_URI&quot;])\n\n    await init_beanie(\n        database=_mongo_client[os.environ[&quot;MONGODB_DB&quot;]],\n        document_models=[Sample],\n    )\n    _beanie_ready = True\n\nasync def entrypoint(ctx: agents.JobContext):\n    &quot;&quot;&quot;Runs for each job (room). No DB re-init here.&quot;&quot;&quot;\n    await ctx.connect()\n    session = AgentSession(\n\n    )\n    await session.start(\n        room=ctx.room,\n        agent=Agent(instructions=&quot;You are a helpful voice AI assistant.&quot;),\n    )\n    # Use Beanie directly in handlers/tools. its already initialized.\nif __name__ == &quot;__main__&quot;:\n    agents.cli.run_app(\n        agents.WorkerOptions(\n            entrypoint_fnc=entrypoint,\n            prewarm_fnc=prewarm,       # &lt;- the key\n        )\n    )\n</code></pre>\n<p>You dont need to reinitialize per room basis. LiveKit\u2019s <strong>worker/job lifecycle</strong> guarantees your <code>entrypoint</code> is executed in a new process per job, but <code>prewarm_fnc</code> executes once per worker process when it starts. So your DB init is bound to the worker\u2019s event loop, not repeatedly per room. The <a href=\"https://docs.livekit.io/agents/logic/external-data/\" rel=\"nofollow noreferrer\">Livekit_DOCS</a> explicitly suggest prewarming static/external data to reduce startup latency. Using it for DB init is a natural extension and avoids repeated Beanie init</p>\n<p><em><strong>#### OR ####</strong></em></p>\n<p>If your agent logic is modular, you can attach initialized handles (like a repo object) to session user data and read them inside tool functions or agent methods. This is consistent with LiveKit\u2019s guidance on injecting external data/context at session start.</p>\n<p><em>app/userdata.py</em></p>\n<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass UserData:\n    # put your repositories/DAO handles here like product_repo, chat_store, etc.\n    pass\n</code></pre>\n<p><em>app/worker.py</em></p>\n<pre><code>from livekit.agents import AgentSession, Agent\nfrom app.db import ensure_beanie_ready\nfrom app.userdata import UserData\n\nasync def entrypoint(ctx):\n    await ensure_beanie_ready()\n    await ctx.connect()\n\n    ud = UserData()\n    session = AgentSession(userdata=ud)\n    await session.start(room=ctx.room, agent=Agent(instructions=&quot;assistant&quot;))\n</code></pre>\n<p>LiveKit terminates jobs when the room ends. You can clean up resources. At agent exit: use <code>await agent.on_exit()</code> or after <code>await session.drain()</code> followed by <code>await session.aclose()</code> to close any resources you created that are <strong>session\u2011scoped</strong>.</p>\n<p>For process\u2011scoped clients (Mongo, Redis), you can register an <code>atexit</code> handler, or expose a <code>shutdown_fnc</code> in worker options if/when the framework supports it. (The main lifecycle doc focuses on entrypoint, run, and cleanup per session. Resource lifetimes beyond session can be released when the worker process exits.) Beanie itself does not require an explicit \u201cclose\u201d after init. You can close the underlying Async PyMongo client if you want to be strict.</p>\n<p>Simple guidance:</p>\n<ul>\n<li><p>Don\u2019t init in <code>entrypoint</code></p>\n</li>\n<li><p>Stick to the worker\u2019s event loop</p>\n</li>\n<li><p>Watch library versions: Beanie supports <strong>PyMongo Async</strong>, but recent <strong>PyMongo</strong> releases introduced breaking changes. Make sure Beanie and PyMongo versions are compatible</p>\n</li>\n</ul>\n<p>Hope it helps you in getting some clarity.</p>\n", "tags": ["python", "asynchronous", "livekit", "beanie"]}
{"id": "76164c60-4202-4bca-8992-7f24fa84b371", "text": "Q: UndoManager&#39;s canUndo property not updating in SwiftUI A: <p>My answer:</p>\n<pre class=\"lang-swift prettyprint-override\"><code>import SwiftUI\n\nstruct UndoToolbarItem: ToolbarContent {\n    \n    let undoManager: UndoManager?\n    @State private var undoChangeObserver: (any NSObjectProtocol)? = nil\n    @State private var canUndo: Bool\n    @State private var canRedo: Bool\n    @TaskLocal static var isQueryingUndoManager: Bool = false\n    \n    var body: some ToolbarContent {\n        ToolbarItem {\n            Button {\n                undoManager?.undo()\n            } label: {\n                Label(&quot;Undo&quot;, systemImage: &quot;arrow.uturn.backward&quot;)\n            }\n            .keyboardShortcut(&quot;z&quot;)\n            .disabled(!canUndo)\n            .onAppear {\n                if let undoChangeObserver {\n                    NotificationCenter.default.removeObserver(undoChangeObserver)\n                }\n                \n                guard let undoManager else { return }\n                self.undoChangeObserver = NotificationCenter.default.addObserver(\n                    forName: .NSUndoManagerCheckpoint,\n                    object: undoManager,\n                    queue: nil) { notification in\n                        guard !UndoToolbarItem.isQueryingUndoManager else { return } // invoked during query, ignore.\n                        guard let undoManager = notification.object as? UndoManager else { return }\n                        \n                        UndoToolbarItem.$isQueryingUndoManager.withValue(true) {\n                            let canUndo = undoManager.canUndo\n                            let canRedo = undoManager.canRedo\n                            \n                            Task { @MainActor in\n                                self.canUndo = canUndo\n                                self.canRedo = canRedo\n                            }\n                        }\n                    }\n            }\n            .onDisappear {\n                if let undoChangeObserver {\n                    NotificationCenter.default.removeObserver(undoChangeObserver)\n                }\n            }\n        }\n        \n        ToolbarItem {\n            Button {\n                undoManager?.redo()\n            } label: {\n                Label(&quot;Redo&quot;, systemImage: &quot;arrow.uturn.forward&quot;)\n            }\n            .keyboardShortcut(&quot;z&quot;, modifiers: [.command, .shift])\n            .disabled(!canRedo)\n        }\n    }\n    \n    init(undoManager: UndoManager?) {\n        self.undoManager = undoManager\n        self._canUndo = State(initialValue: undoManager?.canUndo ?? false)\n        self._canRedo = State(initialValue: undoManager?.canRedo ?? false)\n    }\n}\n</code></pre>\n<p>It uses a task local value to determine if it is invoked by querying the current state, this is possible as:</p>\n<blockquote>\n<p>When <code>queue</code> is <code>nil</code>, the block runs synchronously on the posting thread.</p>\n</blockquote>\n<blockquote>\n<p>The system posts this notification (<code>NSUndoManagerCheckpoint</code>) on the actor, thread, or dispatch queue that calls <code>beginUndoGrouping()</code>, <code>endUndoGrouping()</code>, or <code>canRedo</code>.</p>\n</blockquote>\n", "tags": ["swiftui", "nsundomanager"]}
{"id": "072d0c99-7049-4a7f-9411-cd8016f65987", "text": "Q: Why do I get those empty strings when using re.split() in python? A: <p>re.split() results in blank strings ALL THE TIME... it's very touchy. I've experimented with your test string a lot, and can't solve the puzzle using re.split()</p>\n<p>BUT there's a simpler way:</p>\n<pre><code>pattern = r&quot;[\\w\\s-]+&quot;\nre.findall(pattern, x)\n</code></pre>\n<p>That will give you exactly what you want.</p>\n", "tags": ["python", "python-3.x"]}
{"id": "80fa7fc1-6c4c-406f-9faa-265c35c69410", "text": "Q: Ionic Angular ion-content inner-scroll has zero height on iOS preventing scrolling - all standard fixes attempted A: <p>As you wrote, Ionic is using shadow DOM, which has height calculation issues: <a href=\"https://stackoverflow.com/questions/77506694/make-element-in-shadow-dom-100-of-custom-element-height-with-min-height-and-bor\">Make element in shadow dom 100% of custom element height with min-height and border while also scaling parent if overflowing</a><br />\nYou can set <code>height</code> and <code>min-height</code> to your CSS, or set them dynamically in JS.<br />\nAvoid viewport unit issues: <a href=\"https://stackoverflow.com/questions/60118601/official-docs-of-viewport-width-height-being-bad-practice-in-css\">Official Docs of Viewport Width/Height being bad practice in CSS?</a></p>\n", "tags": ["ios", "angular", "ionic-framework"]}
