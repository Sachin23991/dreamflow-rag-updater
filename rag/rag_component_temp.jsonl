{"id": "cae974a4-ed8a-4c43-985d-4e1c2949c4fd", "text": "Q: Why am I unable to override textLineFragments in textkit2? A: <p><code>NSTextLineFragment</code> is not something you\u2019re supposed to recreate manually. These objects are produced as a result of the layout process inside <code>NSTextLayoutManager</code> and contain internal state that is not exposed through public initializers. So when you copy a line fragment using <code>init(attributedString:range:)</code>, what you actually get is an empty shell that has no correct glyph positions, no baseline, etc.</p>\n<p>If you need to influence how lines are drawn, don\u2019t touch <code>textLineFragments</code> at all and work with the ones that have already been created. Try overriding <code>draw(at:in:)</code> in your <code>NSTextLayoutFragment</code> subclass and iterate over <code>super.textLineFragments</code> there. At that point you can draw any decorative elements you want, and then call <code>line.draw(...)</code>.</p>\n<pre class=\"lang-swift prettyprint-override\"><code>override func draw(at point: CGPoint, in context: CGContext) {\n    for line in super.textLineFragments {\n        let rect = line.typographicBounds\n            .offsetBy(dx: point.x, dy: point.y)\n\n        context.setFillColor(UIColor.yellow.withAlphaComponent(0.2).cgColor)\n        context.fill(rect)\n\n        line.draw(\n            at: CGPoint(\n                x: line.typographicBounds.origin.x + point.x,\n                y: line.typographicBounds.origin.y + point.y\n            ),\n            in: context\n        )\n    }\n}\n</code></pre>\n<p><code>point</code> is the origin of the entire layout fragment, and <code>typographicBounds</code> of a line are its local coordinates within that fragment. If you don\u2019t actually need to work with line geometry and just want to change the appearance of the text, you don\u2019t need to subclass at all, you can work just with <code>NSAttributedString</code>.</p>\n<pre class=\"lang-swift prettyprint-override\"><code>let attr = NSMutableAttributedString(string: &quot;Hello TextKit 2&quot;)\nattr.addAttributes(\n    [\n        .backgroundColor: UIColor.yellow,\n        .underlineStyle: NSUnderlineStyle.single.rawValue\n    ],\n    range: NSRange(location: 0, length: 5)\n)\n</code></pre>\n", "tags": ["ios", "swiftui", "textkit", "textkit2"]}
{"id": "6288d50c-da73-4cf0-bcea-324a007b33c3", "text": "Q: How do I get System.Windows.ShowDialog() to return &#39;true&#39;? A: <p>SaveFileDialog sfd= new SaveFileDialog</p>\n<p>if (sfd.ShowDialog(this) == DialogResult.OK)</p>\n<p>{</p>\n<p>//Then the result of showdialog is true</p>\n<p>}</p>\n", "tags": [".net", "wpf", "dialog"]}
{"id": "381a86d2-19e3-48ab-9d87-136000b8ef4c", "text": "Q: How to design profile view email notifications using Node.js, Bull queue and Redis? A: <p>this approach makes sense, but one thing to think about early is retries and duplicates. Once emails are involved, failures get awkward (like if the worker crashes after sending but before marking the job complete, or SMTP times out and Bull retries) It\u2019s easy to accidentally send the same notification twice. What\u2019s helped me is treating the DB as the source of truth with a notified_at column and making the worker idempotent, instead of relying purely on queue state. That way restarts and retries are boring and safe.</p>\n", "tags": ["node.js", "postgresql", "express", "redis", "message-queue"]}
{"id": "c3b157c2-d606-4a49-888b-ba05574e54e4", "text": "Q: .NET Minimal APIs built-in validation stops working when endpoint mapping is in different assembly than validatable DTO A: <p>This behavior is caused by two separate source-generation constraints, not one.</p>\n<p>The linked question only covers the first.</p>\n<p><strong>How built-in Minimal API validation actually works</strong></p>\n<p>Minimal API validation relies on source generators that:</p>\n<ol>\n<li><p>Discover validatable types (from handler signatures or explicit markers)</p>\n</li>\n<li><p>Generate validation metadata per assembly (<code>IValidatableInfoResolver</code> implementations)</p>\n</li>\n<li><p>Hook into <code>AddValidation()</code> to auto-register generated resolvers for that assembly</p>\n</li>\n</ol>\n<p>Each step can fail independently.</p>\n<p><strong>Failure mode #1</strong> \u2014 resolver registration across assemblies<br />\n<em>(covered by the linked question)</em></p>\n<p>When endpoints / DTOs live in a different assembly than the host:</p>\n<ul>\n<li><p>Each assembly generates its own validation resolver</p>\n</li>\n<li><p>The host's <code>AddValidation()</code> only auto-registers its <strong>own</strong> resolver</p>\n</li>\n<li><p>You must manually aggregate resolvers from feature assemblies</p>\n</li>\n</ul>\n<p>That's why scenario #1 works with resolver scanning.</p>\n<p><strong>Failure mode #2</strong> \u2014 DTO discovery fails when mapping is hidden behind generics <em>(this question)</em></p>\n<p>In scenario #2, the feature assembly never contains a handler like:</p>\n<pre><code>(TypedRequest request) =&gt; ...\n</code></pre>\n<p>Instead, it calls:</p>\n<pre><code>app.MapCommand&lt;TRequest&gt;()\n</code></pre>\n<p>The actual handler lives in another assembly and only references <code>TRequest</code>.</p>\n<p>From the generator's point of view:</p>\n<ul>\n<li>The feature assembly has no handler signature mentioning <code>CreateItemRequest</code></li>\n<li>The shared assembly only sees a generic parameter</li>\n<li>Therefore no validation metadata is generated for the DTO at all</li>\n</ul>\n<p>Resolver scanning cannot help here, there is nothing to resolve.</p>\n<p>This is why this question is not a duplicate: the failure happens before resolver registration.</p>\n<p><strong>Required workaround #1</strong>: force DTO discovery</p>\n<p>You must explicitly mark DTOs as validatable:</p>\n<pre><code>using Microsoft.Extensions.Validation;\n\n[ValidatableType]\npublic sealed class CreateItemRequest\n{\n    [Required]\n    public string? Name { get; set; }\n}\n</code></pre>\n<p>This tells the generator to include the type even if it is not referenced in a handler signature.</p>\n<p><strong>Required workaround #2</strong>: ensure the feature assembly participates in validation codegen</p>\n<p>Even with <code>[ValidatableType]</code>, the feature assembly must still participate in validation generation.</p>\n<p>In current versions, this is tied to the generator seeing an <code>AddValidation()</code> call inside that assembly.</p>\n<p>A pragmatic way to ensure this is a &quot;trigger&quot; method that is never called:</p>\n<pre><code>// App.FeatureA\ninternal static class ValidationSourceGenTrigger\n{\n    // Intentionally unused.\n    // Exists so the validation source generator runs for this assembly.\n    public static IServiceCollection Trigger(IServiceCollection services)\n        =&gt; services.AddValidation();\n}\n</code></pre>\n<p>This ensures:</p>\n<ul>\n<li>the feature assembly emits its generated <code>IValidatableInfoResolver</code></li>\n<li>validation metadata actually exists for the DTOs</li>\n</ul>\n<p><strong>Required workaround #3</strong>: aggregate resolvers in the host</p>\n<p>Finally, the host must still register resolvers from feature assemblies:</p>\n<pre><code>builder.Services.AddValidation(options =&gt;\n{\n    foreach (var resolver in DiscoverResolvers(typeof(FeatureAEndpoints).Assembly))\n        options.Resolvers.Add(resolver);\n});\n</code></pre>\n<ul>\n<li>Resolver scanning solves registration</li>\n<li><code>[ValidatableType]</code> solves discovery</li>\n<li>A no-op <code>AddValidation()</code> forces per-assembly generation</li>\n<li>All three may be required when:\n<ul>\n<li>endpoints are mapped in a shared library</li>\n<li>DTOs live in feature assemblies</li>\n<li>the host is the only runtime entry point</li>\n</ul>\n</li>\n</ul>\n<p>This second failure mode is not documented in the linked question and is why this is a distinct issue.</p>\n", "tags": ["c#", ".net-10.0", "asp.net-minimal-apis"]}
