{"id": "b4af5f66-8b2e-4213-b859-1b74a82fe195", "text": "Q: Why is my projects runtime library MD when I configured it to use MT? A: <p>Okay after hours I noticed one of the projects have a header file which was forcing it to be MD</p>\n<pre><code>#pragma comment(linker, &quot;/NODEFAULTLIB:LIBC.LIB&quot;)\n#pragma comment(linker, &quot;/DEFAULTLIB:MSVCRT.LIB&quot;)\n#pragma comment(linker, &quot;/NODEFAULTLIB:LIBCMT.LIB&quot;)\n#pragma comment(linker, &quot;/NODEFAULTLIB:LIBCPMT.LIB&quot;)\n#pragma comment(linker, &quot;/NODEFAULTLIB:LIBCP.LIB&quot;)\n#pragma comment(linker, &quot;/DEFAULTLIB:MSVCPRT.LIB&quot;)\n</code></pre>\n", "tags": ["c++", "msbuild", "vcpkg", "vcxproj"]}
{"id": "c51ff411-3544-48cc-b412-34da4c7d57a5", "text": "Q: Detecting integral overflow with scanf A: <p>One (inefficient) way is to use <code>sscanf</code> on the string that needs to be parsed and then <code>sprintf</code> it to a buffer. Finally, use <code>strncmp</code> to compare the source string with one just generated. I wrote my own json_deserializer in c and I used this technique. Have a look if interested. <a href=\"https://github.com/antonioastorino/json-deserializer-c\" rel=\"nofollow noreferrer\">https://github.com/antonioastorino/json-deserializer-c</a></p>\n", "tags": ["c", "language-lawyer", "iso"]}
{"id": "22c168eb-ac27-490c-9677-a6d0b10a7cbe", "text": "Q: Silent Bug on React JS Anime list A: <p>As already mentioned, you used wrong event on a button.\nYou can achieve what you want by replacing wrapping <code>div</code> with <code>form</code> and subscribing to <code>onSubmit</code> event. This event will carry value from wrapped <code>input</code> elements, which would simplify your code, because you don't need to perform DOM search for element and get form values directly on event object that is passed as parameter:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\" data-babel-preset-react=\"true\" data-babel-preset-ts=\"false\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function AnimeList(){\n    const [anime, setAnime] = React.useState([\"Attack on Titan\", \"Kimi No Wa\", \"Sakamoto Days\"])\n\n    function handleAddAnime(e){\n        e.preventDefault();\n        setAnime([...anime, e.target.elements.animeInput.value]);\n    }\n\n    return(\n        &lt;form onSubmit={handleAddAnime}&gt;\n            &lt;h2&gt;Anime list&lt;/h2&gt;\n            &lt;ul&gt;\n                {anime.map((anime, index) =&gt; &lt;li key={index}&gt;{anime}&lt;/li&gt;)}\n            &lt;/ul&gt;\n            &lt;input type=\"text\" placeholder='input anime name' id='animeInput' /&gt;\n            &lt;button&gt;Add Anime&lt;/button&gt;\n        &lt;/form&gt;\n    )\n}\n\nfunction App() {\n  return (\n      &lt;AnimeList /&gt;\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(&lt;App /&gt;);</code></pre>\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.production.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n\n&lt;div id=\"root\"&gt;&lt;/div&gt;</code></pre>\n</div>\n</div>\n</p>\n<p>Moreover, usual way of working with <code>input</code> elements is to make them <a href=\"https://medium.com/@codeyourthoughts48/what-are-controlled-elements-in-react-beginners-guide-c1c8d4a9582b\" rel=\"nofollow noreferrer\">controlled elements</a>, i.e. you control their value via state:</p>\n<pre><code>// first define state\nconst [newAnime, setNewAnime] = useState(&quot;&quot;);\n\n// then in returned JSX\nreturn (\n    &lt;&gt;\n        ...\n        &lt;input\n            type=&quot;text&quot;\n            placeholder=&quot;input anime name&quot;\n            value={newAnime}\n            onChange={(e) =&gt; setNewAnime(e.target.value)}\n        /&gt;\n        ...\n    &lt;/&gt;\n)\n</code></pre>\n<p>With controlled component approach you can use state <code>newAnime</code> directly, instead od getting it from DOM element.</p>\n", "tags": ["javascript", "reactjs"]}
{"id": "88d53860-4c11-4ef9-b29d-c523bda5162b", "text": "Q: Swift Async awaiting all tasks in task group A: <p>If you use <code>semaphore.wait()</code> from within an asynchronous context, it will produce this warning:</p>\n<blockquote>\n<p>Instance method 'wait' is unavailable from asynchronous contexts; Await a Task handle instead; this is an error in Swift 6</p>\n</blockquote>\n<p>I assume that you must be waiting for this semaphore outside of a asynchronous context, otherwise it would have produced the above warning.</p>\n<hr />\n<p>You cannot use semaphores for dependencies in conjunction between <code>async</code>-<code>await</code> tasks. See <a href=\"https://developer.apple.com/videos/play/wwdc2021/10254/?time=1558\" rel=\"nofollow noreferrer\">Swift concurrency: Behind the scenes</a>:</p>\n<blockquote>\n<p>[Primitives] like semaphores ... are unsafe to use with Swift concurrency. This is because they hide dependency information from the Swift runtime, but introduce a dependency in execution in your code. Since the runtime is unaware of this dependency, it cannot make the right scheduling decisions and resolve them. In particular, do not use primitives that create unstructured tasks and then retroactively introduce a dependency across task boundaries by using a semaphore or an unsafe primitive. Such a code pattern means that a thread can block indefinitely against the semaphore until another thread is able to unblock it. This violates the runtime contract of forward progress for threads.</p>\n</blockquote>\n<hr />\n<p>The pattern in <code>async</code> methods would be to <code>await</code> the <code>result</code> of the task group.</p>\n<pre class=\"lang-swift prettyprint-override\"><code>let task = Task {\n    try await withThrowingTaskGroup(of: ASRJob.self) { group in\n        for path in filePathsToWorkOn {\n            group.addTask {\n                try await doHardWork(atPath: path)\n            }\n        }\n\n        try await group.waitForAll()\n    }\n}\n\n_ = await task.result\n</code></pre>\n<p>For throwing tasks groups, we would also often <code>waitForAll</code>.</p>\n<hr />\n<p>Yes, you can technically <code>wait</code> in an <code>Operation</code>, but even that is an anti-pattern. We would generally write a \u201cconcurrent\u201d operation. See discussion of \u201cconcurrent operations\u201d in the <code>Operation</code> <a href=\"https://developer.apple.com/documentation/foundation/operation/\" rel=\"nofollow noreferrer\">documentation</a>. Or see <a href=\"https://stackoverflow.com/q/43561169/1271826\">Trying to Understand Asynchronous Operation Subclass</a>.</p>\n", "tags": ["ios", "swift", "async-await"]}
