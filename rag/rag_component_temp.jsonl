{"id": "71c67c0a-d753-4073-918a-43798eeb8872", "text": "Q: Why we need a master branch in Git-flow? A: <p>&quot;If you don't keep in mind the difference with the <code>master</code> branch, <code>force-push</code> can go wrong.&quot; - exactly what do you mean by that? Force-pushing a tag (if I only use &quot;latest&quot; tag) can hardly go wrong, or can it? Force-pushing a &quot;latest&quot; branch each time - can, but it can only go wrong for that &quot;latest&quot; branch (which I only suggested to use as a pointer, so it's OK). Finally, I also proposed an approach when I don't force push anything at all, but it requires either knowing latest release number at any moment or looking at all the release tags.</p>\n", "tags": ["git", "git-flow"]}
{"id": "83779b81-137d-41c9-a98f-b62f623d5b89", "text": "Q: R sscanf equivalent A: <p>Yes, I have already <code>docopt</code> in the code. But the situation is more complex. The code has a large parameter set and I use a combination of a CLI  which is applied to sections of a INI based config file to make things more handy in the process context. The &quot;CLI patched INI&quot; unfortunately addresses strings due to variable interpolation capabilities.</p>\n<p>I have to check the type when I try to  transfer the content from the INI/CLI to the runtime parameter. Having format strings describing the expected type and layout would be handy.</p>\n", "tags": ["r", "parsing", "type-conversion", "scanf"]}
{"id": "d30a05d3-9c1b-46d8-97b1-af7a32f7ba6e", "text": "Q: Flutter ImageFilter.blur is gone when scrolling to beginning or end of list A: <p>To ensure that the glass effect remains consistent, you can wrap the <code>BackdropFilter</code> in a <code>Container</code> that has a background color or image that can be blurred. This will provide a consistent backdrop for the blur effect, regardless of the card's position in the carousel.</p>\n<p>Here is the modified code snippet:</p>\n<pre class=\"lang-dart prettyprint-override\"><code>Padding(\n  padding: const EdgeInsets.only(bottom: 12.0, left: 0.0),\n  child: SizedBox(\n    height: 120,\n    child: PageView.builder(\n      physics: const AlwaysScrollableScrollPhysics(),\n      itemCount: cardData.isEmpty ? 1 : cardData.length + 1,\n      controller: _pageController,\n      padEnds: true,\n      clipBehavior: Clip.none,\n      onPageChanged: (index) {\n        setState(() {\n          _currentPage = index;\n        });\n      },\n      itemBuilder: (context, index) {\n        // Add Card Container\n        if (index == cardData.length &amp;&amp; cardData.isNotEmpty) {\n          return Padding(\n            padding: const EdgeInsets.only(right: 12.0),\n            child: GestureDetector(\n              onTap: () async {\n                // Add your onTap functionality here\n              },\n              child: Padding(\n                padding: const EdgeInsets.all(1),\n                child: RepaintBoundary(\n                  child: DottedBorder(\n                    color: const Color(0xBEB4E1fA),\n                    strokeWidth: 1.5,\n                    dashPattern: const [8, 12],\n                    borderType: BorderType.RRect,\n                    radius: const Radius.circular(8),\n                    strokeCap: StrokeCap.round,\n                    padding: EdgeInsets.zero,\n                    child: ClipRRect(\n                      borderRadius: BorderRadius.circular(8),\n                      child: Container(\n                        decoration: BoxDecoration(\n                          color: Colors.transparent, // Make the container transparent\n                        ),\n                        child: BackdropFilter(\n                          filter: ImageFilter.blur(sigmaX: 12, sigmaY: 12),\n                          child: Container(\n                            height: 120,\n                            width: double.infinity,\n                            decoration: BoxDecoration(\n                              color: Colors.white.withOpacity(0.25),\n                              borderRadius: BorderRadius.circular(8),\n                              border: Border.all(\n                                color: Colors.white.withOpacity(0.4),\n                                width: 1,\n                              ),\n                              boxShadow: [\n                                BoxShadow(\n                                  color: Colors.black.withOpacity(0.1),\n                                  blurRadius: 20,\n                                  offset: const Offset(0, 8),\n                                ),\n                              ],\n                            ),\n                            child: Center(\n                              child: Column(\n                                mainAxisAlignment: MainAxisAlignment.center,\n                                children: [\n                                  SvgPicture.asset(\n                                    'assets/images/svg/plus_icon.svg',\n                                    colorFilter: const ColorFilter.mode(Color(0xFF585C5C), BlendMode.srcIn),\n                                  ),\n                                  const SizedBox(height: 0),\n                                  const Text(\n                                    'Add Card',\n                                    style: TextStyle(\n                                      fontFamily: 'Inter',\n                                      color: Color(0xFF585C5C),\n                                      fontSize: 16,\n                                      fontWeight: FontWeight.w700,\n                                      letterSpacing: 0,\n                                    ),\n                                  ),\n                                ],\n                              ),\n                            ),\n                          ),\n                        ),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          );\n        }\n      },\n    ),\n  ),\n),\n</code></pre>\n", "tags": ["flutter", "dart", "mobile-development"]}
{"id": "a1fe6a7a-33f3-426e-9bac-157735d4e76a", "text": "Q: Team scale - define architectural principles for project A: <p>There is few ideas which can be incorporated</p>\n<ul>\n<li>Git-Lab going to contain CI rules which can have things like Naming convention, Static code analysis, which will verify 'coding standards'.</li>\n<li>In parallel a Wiki, Read-Me or a Technical document can be maintained to keep all the rules you want to enforce, for the team to be read and followed.</li>\n<li>Taking a look at the code base at regular intervals to spot any issues from the commits and meeting with team discussing about the necessity for adhering to rules.</li>\n</ul>\n", "tags": ["design-patterns", "architecture", "principles"]}
{"id": "cfa828b5-8ccb-411f-a1f3-ac35251e5b7d", "text": "Q: tkinter TclError After Update to Fedora 43 A: <p>Change <code>stream(...)</code> to <code>WIN.after(0, stream, ...)</code> to jump from the MQTT thread back to the UI thread.</p>\n<p>Then make sure <code>ImageTk.PhotoImage</code> is <strong>only</strong> ever called within a function triggered by <code>mainloop</code> or <code>after</code>.</p>\n<p>You already have <code>LABEL.image = render</code>, which is correct and without that, the image gets garbage collected immediately!</p>\n", "tags": ["python", "python-3.x", "tkinter", "fedora"]}
{"id": "bc200582-8d83-439c-9f59-d7187894f2f6", "text": "Q: Which shortest path algorithm should I use for a weighted city road network in Python? A: <blockquote>\n<p>Q1) Which algorithm should be selected for this problem?</p>\n</blockquote>\n<p>They're all feasible, but two are especially good fits.\nAnd both are available in popular\n<a href=\"https://pypi.org\" rel=\"nofollow noreferrer\">pypi</a>\ngraph libraries.</p>\n<blockquote>\n<p>Q2) Why [are these] algorithms suitable for finding the shortest path ... in a weighted road network?</p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\" rel=\"nofollow noreferrer\">Dijkstra</a>\nis sort of the no-brainer, as it is simple, quite general, and has attractive running time.\nThe original is quadratic in number of cities, and you could readily implement it.\nWhen relying on a library's implementation it would be reasonable to expect the 1984\n<a href=\"https://ieeexplore.ieee.org/document/715934\" rel=\"nofollow noreferrer\">Fredman &amp; Tarjan</a>\nvariant. If we have C cities and R road segments, its complexity\nof O(C + R log R) is about the best one could hope for.\nEven an adversarially constructed map couldn't really bring\nan implementation to its knees with some pathological case.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/A*_search_algorithm\" rel=\"nofollow noreferrer\">A*</a>\nis especially well suited to <em>this</em> graph, since it is a planar\ngraph and from (lat, long)'s we can readily compute the crow flies\ndistance from each city to Gulshan Iqbal.\nWe call this an &quot;admissable heuristic&quot;, and finding one is\nusually the sticking point in deciding whether A* is suitable\nfor traversing a given graph. Sometimes a metric like\n&quot;number of manufacturing steps still needed&quot; to make a complete part\nwill serve nicely as an admissable heuristic.</p>\n<p>The original problem suggests we have a static graph,\nand asks that we print out a planned itinerary.\nIn a variant problem we start in a Current location,\nwe always have the same destination of Gulshan Iqbal,\nand we're told of zero or more road closures\n(no edge, or equivalently it's an infinite cost edge).\nWe're asked for an adjacent node to journey to,\nand then we iterate with <em>that</em> as our Current location.\nIn this setting A* is a big win over Dijkstra,\nsince as the journey progresses it gets to mostly\nignore locations in its rear-view mirror.\nEven in the static setting, A* wins if our road atlas\nis a giant graph of every city in the country,\nwith most of them being irrelevant since visiting them\nwould take us quite far from a crow flies path.\nA* simply never considers them.</p>\n<blockquote>\n<p>Q3) How can the chosen algorithm be cleanly integrated into this existing class-based structure?</p>\n</blockquote>\n<p>Your CityGraph class frankly hasn't implemented much of interest, yet.\nI wouldn't worry too much about sticking to what's in the OP.</p>\n<p>Definitely import <a href=\"https://pypi.org/project/networkx\" rel=\"nofollow noreferrer\">networkx</a>\nand play with that. Define the graph, ask for a Dijkstra\nsolution, then for an A* solution.\nThe package is mature, it works well, you can't go wrong with it.\nIt <em>is</em> pure python, so you may find it's not the fastest solution.</p>\n<p>Once you have a little experience with that,\nif you want to produce your own Dijkstra implementation\nyou'll be in a good position to see what the issues are\nand what the API should look like.</p>\n<p>You might also import <a href=\"https://pypi.org/project/graphlib2\" rel=\"nofollow noreferrer\">graphlib2</a>.\nIt's Rust on the inside, which could make a difference for large graphs.\nFor small ones like we see in the OP, it likely won't matter.</p>\n", "tags": ["python", "algorithm", "data-structures", "shortest-path"]}
