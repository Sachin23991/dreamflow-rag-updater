{"id": "21209aff-fd61-4829-a39c-13c075f2f944", "text": "Q: Run a .cmd file through PowerShell A: <p>That's the only way officially using the most efficient means available in Powershell</p>\n", "tags": ["windows", "powershell", "cmd"]}
{"id": "2d8d0687-77ff-49e2-aee7-3b17f1e23aab", "text": "Q: How to use SET XACT_ABORT ON the right way A: <p>I have outlined a set of queries and scenarios that show the workings of XACT_ABORT, TRANSACTIONS and TRY/CATCH.</p>\n<p>The following has been tested on Compatibility Level = 140</p>\n<p>Each scenario will perform the same basic tasks and throw the same error so it will make it much easier to see what is happening and why.</p>\n<p>Run all statements in each scenario in a single batch.</p>\n<p>This is what you need to know, boundary, behavior, control.</p>\n<ol>\n<li><p>BEGIN/COMMIT/ROLLBACK TRANSACTION - Define a transaction <strong>Boundary</strong></p>\n</li>\n<li><p>XACT_ABORT - Impacts the <strong>Behavior</strong> when an error occurs. The impact on any txns and batches.</p>\n</li>\n<li><p>TRY/CATCH - Give you the means to <strong>Control</strong> what happens when an error is encountered.</p>\n</li>\n</ol>\n<h2>Setup</h2>\n<p>Before going into the scenarios let run through some set up. Create a very simple table which is going to hold three values for every test. This allows us to easily isolate and validate results as we progress.</p>\n<pre><code>CREATE TABLE dbo.test_scenarios (\n    test_id   INT NOT NULL\n   ,delete_id INT NOT NULL\n);\n\nINSERT INTO dbo.test_scenarios (test_id, delete_id)\nSELECT  t.n AS test_id \n       ,d.n AS delete_id\nFROM    (VALUES (1),(2),(3),(4),(5),(6),(7),(8),(9),(10)) AS t(n) -- The Test IDs\n        CROSS JOIN \n        (VALUES (0),(1),(2)) AS d(n);                        -- The Delete IDs\n\n-- Verify\nSELECT * FROM dbo.test_scenarios ORDER BY test_id, delete_id;\nGO\n</code></pre>\n<h2><strong>Scenario 1</strong></h2>\n<p>XACT_ABORT OFF<br />\nNO EXPLICIT TRANSACTION<br />\nNO TRY CATCH</p>\n<p>Therefore...</p>\n<p>Each delete statement runs in an autocommit transaction.<br />\nAny errors or failures have no impact on previous or following statements.</p>\n<pre><code>DECLARE @test_id INT = 1;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT OFF;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\n/*\n\nBefore\ntest_id delete_id\n1       0\n1       1\n1       2\n\nAfter\ntest_id delete_id\n1       1\n\n*/\n</code></pre>\n<p>When the 1/0 error is hit, it is the only statement running in the autocommit transaction therefore only that statement is rolled back and everything else continues.</p>\n<p>The final select statement executes when the batch is executed.</p>\n<p>This may lead to inconsistent results and data quality issues.</p>\n<h2>Scenario 2</h2>\n<p>XACT_ABORT OFF<br />\nEXPLICIT TRANSACTION<br />\nNO TRY CATCH</p>\n<p>Each delete statement runs within an explicit transaction.<br />\nAny errors or failures have no impact on previous or following statements.<br />\nThe transaction here will simply define what will be committed but there is no logic to check what should happen if any of the statements fail.</p>\n<p>The salient difference here between this and scenario 1 is the timing of the commits.</p>\n<pre><code>DECLARE @test_id INT = 2;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT OFF;\nBEGIN TRANSACTION;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nCOMMIT TRANSACTION;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\n/*\n\nBefore\ntest_id delete_id\n2       0\n2       1\n2       2\n\nAfter\ntest_id delete_id\n2       1\n\n*/\n</code></pre>\n<p>When the 1/0 error is hit that particular statement is rolled back but as there is no logic to handle errors the rest of the statements proceed and the commit then commits the successful statements (0 and 2).</p>\n<p>This is one of the riskiest applications of explicit transactions where failure/errors are not handled somehow and the end user expects the transaction to be rolled back in its entirety.</p>\n<p>This can lead to inconsistent results and data quality issues.</p>\n<h2>Scenario 3</h2>\n<p>XACT_ABORT ON<br />\nEXPLICIT TRANSACTION<br />\nNO TRY CATCH</p>\n<p>Each delete statement runs within an explicit transaction.<br />\nAny errors or failures within the transaction are now handled by the xact_abort.</p>\n<pre><code>DECLARE @test_id INT = 3;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nBEGIN TRANSACTION;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nCOMMIT TRANSACTION;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\n/*\n\nBefore\ntest_id delete_id\n3       0\n3       1\n3       2\n\nAfter - The final select statement is not issued as part of the batch. Validation of the end state must be run separately after the first execution of the batch \n\n*/\n</code></pre>\n<p>When the 1/0 error is hit the explicit transaction is rolled back and the batch terminates immediately. BATCH_ABORT signal is intercepted. Therefore no statements after the one that resulted in an error are executed.</p>\n<p>In order to see the effect of the batch this must be re-run...</p>\n<pre><code>DECLARE @test_id INT = 3;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\n/*\n\nAfter - The final select statement is not issued as part of the batch. Validation of the end state must be run separately after the first execution of the batch \ntest_id delete_id\n3       0\n3       1\n3       2\n\n*/\n</code></pre>\n<p>Depending on your use case this may be safe enough. The downside is that while the data remains consistent there any subsequent error handling/logging/tidy up are deferred to the client.</p>\n<p>This is also risky code if there is a possibility that it is being run within the context of an explicit transaction that has been defined previous to the code being called.</p>\n<p>I would trust this for an adhoc script but not in production code being called from other applications or clients. But even though I trust it, I would still never use it in this form. (opinion!)</p>\n<h2>Scenario 4</h2>\n<p>XACT_ABORT ON<br />\nNO EXPLICIT TRANSACTION<br />\nNO TRY CATCH</p>\n<p>Each delete statement runs in an autocommit transaction.<br />\nAny errors or failures have no impact on previous statements but do impact following statements.<br />\nThis can lead to inconsistent results and data quality issues.</p>\n<pre><code>DECLARE @test_id INT = 4;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n4       0\n4       1\n4       2\n\nAfter - The final select statement is not issued as part of the batch. Validation of the end state must be run separately after the first execution of the batch\n\n*/\n</code></pre>\n<p>When the 1/0 error is hit<br />\n1. It is the only statement running in the autocommit transaction therefore only that statement is rolled back.<br />\n2. However, it is not the only statement within the batch.<br />\n3. The batch itself is terminated so that and any following statements are never executed.</p>\n<pre><code>DECLARE @test_id INT = 4;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nAfter\n4       1\n4       2\n\n*/\n</code></pre>\n<p>This is another very dangerous usage of XACT_ABORT if the true behaviour of how it operates is unknown. There is no immediate feedback available from the batch as to what has occurred.</p>\n<h2>Scenario 5</h2>\n<p>XACT_ABORT OFF<br />\nNO EXPLICIT TRANSACTION<br />\nTRY CATCH</p>\n<p>Here we finally start introducing TRY/CATCH. Lets see what this brings to the table.</p>\n<p>Each delete statement runs in an autocommit transaction within a try block.<br />\nAny errors or failures have no impact on previous statements but do impact following statements.<br />\nThis can lead to inconsistent results and data quality issues.</p>\n<pre><code>DECLARE @test_id INT = 5;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT OFF;\nBEGIN TRY\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nEND TRY\nBEGIN CATCH\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\nEND CATCH\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n5       0\n5       1\n5       2\n\nAfter\n5       1\n5       2\n\nPrints...\nCATCH\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=0\n\n*/\n</code></pre>\n<p>When the 1/0 error is hit<br />\n1. It is the only statement running in the autocommit transaction therefore only that statement is rolled back.<br />\n2. However, it is not the only statement within the try block.<br />\n3. Controls jumps to the catch block so any remaining statements within the try block, following the problematic code, are not executed.</p>\n<p>This is another dangerous usage of TRY/CATCH if one assumes that the TRY begins an explicit transaction.</p>\n<h2>Scenario 6</h2>\n<p>XACT_ABORT ON<br />\nNO EXPLICIT TRANSACTION<br />\nTRY CATCH</p>\n<p>The difference here is that we now have xact_abort on and one may expect a different result to scenario 5.</p>\n<p>Each delete statement runs in an autocommit transaction within a try block.<br />\nAny errors or failures have no impact on previous statements but do impact following statements.<br />\nThis can lead to inconsistent results and data quality issues.</p>\n<pre><code>DECLARE @test_id INT = 6;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nBEGIN TRY\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nEND TRY\nBEGIN CATCH\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\nEND CATCH\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n6       0\n6       1\n6       2\n\nAfter\n6       1\n6       2\n\nPrints...\nCATCH\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=0\n\n*/\n</code></pre>\n<p>When the 1/0 error is hit<br />\n1. It is the only statement running in the autocommit transaction therefore only that statement is rolled back.<br />\n2. However, it is not the only statement within the try block.<br />\n3. Controls jumps to the catch block so any remaining statements within the try block, following the problematic code, are not executed.</p>\n<p>The CATCH block now intercepts the BATCH_ABORT signal so that any statements following the CATCH block will be executed. This explains how the final select statement is executed despite being part of the same batch.</p>\n<p>This is another dangerous usage of TRY/CATCH if one assumes that the TRY begins an explicit transaction OR xact_abort will somehow provide some safety.</p>\n<h2>Scenario 7</h2>\n<p>XACT_ABORT OFF<br />\nEXPLICIT TRANSACTION<br />\nTRY CATCH</p>\n<p>Each delete statement runs in an explicit transaction within a TRY/CATCH.<br />\nAny errors or failures impact any statements covered by the transaction.<br />\nThis safely covers the error thrown from within the logic of the statements.</p>\n<pre><code>DECLARE @test_id INT = 7;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT OFF;\nBEGIN TRY\nBEGIN TRANSACTION\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nCOMMIT TRANSACTION;\nEND TRY\nBEGIN CATCH\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n    ROLLBACK TRANSACTION;\nEND CATCH\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n7       0\n7       1\n7       2\n\nAfter \ntest_id delete_id\n7       0\n7       1\n7       2\n\nPrints...\nCATCH\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=1\n*/\n</code></pre>\n<p>When the 1/0 error is hit:<br />\n1. Control jumps to the CATCH block.<br />\n2. The transaction is explicitly rolled back. (Note that the XACT_STATE = 1 so the transaction is in a state where a COMMIT could be issued.)<br />\n3. Execution CONTINUES after the END CATCH (The batch survives as BATCH_ABORT is intercepted).</p>\n<p>This is safe and good use of TRY/CATCH and transactions, however it does not catch all errors that may impact the transaction behaviour. I.e. Client Timeouts.<br />\nIt is also not ideal if the code is called where an explicit user transaction has already been started.</p>\n<h2>Scenario 8</h2>\n<p>XACT_ABORT ON<br />\nEXPLICIT TRANSACTION<br />\nTRY CATCH</p>\n<p>Each statement runs in an explicit transaction within a try/catch.<br />\nXACT_ABORT ON ensures that severe errors (that bypass CATCH) still force a rollback.<br />\nTRY/CATCH allows us to gracefully handle logic errors and log them.</p>\n<pre><code>DECLARE @test_id INT = 8;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nBEGIN TRY\nBEGIN TRANSACTION\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nCOMMIT TRANSACTION;\nEND TRY\nBEGIN CATCH\n    PRINT 'CATCH'\n    PRINT 'The &quot;Batch Abort&quot; signal is now cleared.';\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n    ROLLBACK TRANSACTION;\nEND CATCH\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\nBefore\ntest_id delete_id\n8       0\n8       1\n8       2\n\nAfter\ntest_id delete_id\n8       0\n8       1\n8       2\n\nPrints...\nCATCH\nThe &quot;Batch Abort&quot; signal is now cleared.\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=-1\n*/\n</code></pre>\n<p>When the 1/0 error is hit:<br />\n1. The transaction is marked &quot;Uncommittable&quot; (XACT_STATE = -1).<br />\n2. Control jumps to the CATCH block.<br />\n3. The transaction is explicitly rolled back.<br />\n4. Execution CONTINUES after the END CATCH (The batch survives as BATCH_ABORT has been intercepted by CATCH).</p>\n<p>NOTE ON TIMEOUTS:<br />\nIf a Client Timeout occurs, the CATCH block is SKIPPED.<br />\nHowever, XACT_ABORT ON guarantees the transaction is still rolled back by the server.</p>\n<p>This is the format that I would suggest using for adhoc scripts. I still think this is not safe code to be used within stored procedures or application code anywhere (opinion!)</p>\n<h2>Scenario 9</h2>\n<p>XACT_ABORT ON<br />\nEXPLICIT TRANSACTION<br />\nNESTED EXPLICIT TRANSACTION<br />\nNESTED TRY CATCH<br />\nTRY CATCH</p>\n<p>Some serious caveats with the terminology being used here. There is no such thing as a nested transaction but there are nested BEGIN TRANSACTION statements. Different topic and not the focus here where we are mainly looking at xact_abort.</p>\n<p>Each statement runs in an explicit transaction within a try/catch.</p>\n<p>XACT_ABORT ON ensures that severe errors (that bypass CATCH) still force a rollback.</p>\n<p>TRY/CATCH allows us to gracefully handle logic errors and log them.</p>\n<pre><code>DECLARE @test_id INT = 9;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nBEGIN TRY\nBEGIN TRANSACTION --@@TRANCOUNT = 1\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\n\n    BEGIN TRY\n    BEGIN TRANSACTION --@@TRANCOUNT = 2\n\n    DELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\n\n    COMMIT TRANSACTION;\n    END TRY\n    BEGIN CATCH\n        PRINT 'INNER';\n        PRINT 'The &quot;Batch Abort&quot; signal is now cleared.';\n        PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n        PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n        ROLLBACK TRANSACTION; --@@TRANCOUNT = 0\n    END CATCH\n\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2; --Batch Abort cleared so this can proceed in autocommit.\nCOMMIT TRANSACTION; --Fail! @@TRANCOUNT already at 0\nEND TRY\nBEGIN CATCH\n    PRINT 'OUTER';\n    PRINT 'The &quot;Batch Abort&quot; signal is now cleared.';\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n    ROLLBACK TRANSACTION;\nEND CATCH\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n9       0\n9       1\n9       2\n\nAfter - The final select statement is not issued as part of the batch. Validation of the end state must be run separately after the first execution of the batch\n\nPrints...\nINNER\nThe &quot;Batch Abort&quot; signal is now cleared.\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=-1\n\nOUTER\nThe &quot;Batch Abort&quot; signal is now cleared.\nERROR_MESSAGE()=The COMMIT TRANSACTION request has no corresponding BEGIN TRANSACTION.\nXACT_STATE()=0\nMsg 3903, Level 16, State 1, Line 487\nThe ROLLBACK TRANSACTION request has no corresponding BEGIN TRANSACTION.\n*/\n</code></pre>\n<p>When the 1/0 error is hit:<br />\n1. The transaction is marked &quot;Uncommittable&quot; (XACT_STATE = -1).<br />\n2. Control jumps to the INNER CATCH block.<br />\n3. BATCH_ABORT is intercepted<br />\n4. The transaction is explicitly rolled back.<br />\na. TRANCOUNT goes from 2 -&gt; 0<br />\n5. Execution CONTINUES after the END CATCH.<br />\n6. The next statement in the batch is DELETE for delete_id = 2<br />\n7. The delete succeeds as this is performed within an autocommit transaction and the previous BATCH_ABORT had been intercepted and reset.<br />\n8. The (OUTER) COMMIT statement fails as the explicit transaction has already been rolled back.<br />\n9. Controls jumps to the OUTER CATCH block where the message indicates no begin transaction found.<br />\n10. There is no explicit transaction in operation, the XACT_STATE is 0<br />\n11. The ROLLBACK now throws an ERROR<br />\n12. BATCH_ABORT signal re-issued by XACT_ABORT<br />\n13. The batch is terminated and the final select statement is not executed</p>\n<pre><code>DECLARE @test_id INT = 9;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nAfter\n9       0\n9       1\n</code></pre>\n<p>Now that we start delving into nested BEGIN TRANSACTION statements and even with TRY/CATCH and XACT_ABORT we start to see that results can be unexpected.</p>\n<h2>Scenario 10</h2>\n<p>XACT_ABORT ON<br />\nEXPLICIT TRANSACTION<br />\nNESTED EXPLICIT TRANSACTION (Conditional)<br />\nNESTED TRY CATCH<br />\nTRY CATCH</p>\n<p>The main difference between this and the previous test is that we are checking to see if an explicit transaction has already been defined. If yes we will always leave the transaction operations to be handled where the transaction has been started.</p>\n<p>This is why you should always join existing transactions in SQL server.</p>\n<p>This is the safest way to construct stored procedures that handle transactions in SQL Server</p>\n<p>Each statement runs in an explicit transaction within a try/catch.</p>\n<p>XACT_ABORT ON ensures that severe errors (that bypass CATCH) still force a rollback.</p>\n<p>TRY/CATCH allows us to gracefully handle logic errors and log them.</p>\n<pre><code>DECLARE @test_id INT = 10;\n\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n\nSET XACT_ABORT ON;\nBEGIN TRY\nDECLARE @tc INT = @@TRANCOUNT;\nIF @tc = 0 BEGIN TRANSACTION;\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 0;\n\n    BEGIN TRY\n    DECLARE @tc1 INT = @@TRANCOUNT;\n    IF @tc1 = 0 BEGIN TRANSACTION;\n\n    DELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 1/0;\n\n    IF @tc1 = 0 COMMIT TRANSACTION;\n    END TRY\n    BEGIN CATCH\n        PRINT 'INNER';\n        PRINT 'The &quot;Batch Abort&quot; signal is now cleared.';\n        PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n        PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n        IF @tc1 = 0 \n        BEGIN \n            PRINT 'INNER - ROLLING BACK';\n            ROLLBACK TRANSACTION;\n        END\n        ELSE\n        BEGIN\n            PRINT 'INNER - THROW';\n            THROW;\n        END\n    END CATCH\n\nDELETE FROM dbo.test_scenarios WHERE test_id = @test_id AND delete_id = 2;\nIF @tc = 0 COMMIT TRANSACTION;\nEND TRY\nBEGIN CATCH\n    PRINT 'OUTER';\n    PRINT 'The &quot;Batch Abort&quot; signal is now cleared.';\n    PRINT 'ERROR_MESSAGE()='+ERROR_MESSAGE();\n    PRINT 'XACT_STATE()='+CAST(XACT_STATE() AS VARCHAR);\n    IF @tc = 0 \n    BEGIN \n        PRINT 'OUTER - ROLLING BACK';\n        ROLLBACK TRANSACTION;\n    END\n    ELSE\n    BEGIN\n        PRINT 'OUTER - THROW';\n        THROW;\n    END\nEND CATCH\nSELECT test_id, delete_id  FROM dbo.test_scenarios WHERE test_id = @test_id;\n/*\n\nBefore\ntest_id delete_id\n10      0\n10      1\n10      2\n\nAfter \ntest_id delete_id\n10      0\n10      1\n10      2\n\nPrints...\nINNER\nThe &quot;Batch Abort&quot; signal is now cleared.\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=-1\nINNER - THROW\nOUTER\nThe &quot;Batch Abort&quot; signal is now cleared.\nERROR_MESSAGE()=Divide by zero error encountered.\nXACT_STATE()=-1\nOUTER - ROLLING BACK\n*/\n</code></pre>\n<p>When the 1/0 error is hit:<br />\n1. The transaction is marked &quot;Uncommittable&quot; (XACT_STATE = -1).<br />\n2. Control jumps to the INNER CATCH block.<br />\n3. The transaction is not rolled back.<br />\na. The nested try/catch transaction 'joined' the exiting one and so does not roll the tranasction back<br />\n4. Execution CONTINUES after the END CATCH.<br />\n5. BATCH_ABORT is intercepted (The batch survives).<br />\n6. Controls immediately jumps to the OUTER CATCH block<br />\n7. The transaction is already marked as uncommittable<br />\n8. As the OUTER created the initial transaction, it rolls it back.<br />\nIf the OUTER here were called from another statement or procedure that had initiated an explicit transaction then it would operate the same way as the INNER</p>\n<p>9. BATCH_ABORT has been intercepted by the outer CATCH block so the select statement proceeds.</p>\n<p>This would be why I would recommend setting XACT_ABORT ON, checking to see if explicit transactions have already been started, and using TRY/CATCH to log any errors or perform tidy up.</p>\n<h2>Conclusion</h2>\n<p>If you're not sure then write a test and see if your code performs as you would expect. I have no doubt I have some typos somewhere in this post so please make sure you verify everything yourself before implementing anything in a production environment.</p>\n<p>For the majority of use cases I would...</p>\n<ul>\n<li><p>Set XACT_ABORT ON</p>\n</li>\n<li><p>&quot;JOIN&quot; existing transactions</p>\n</li>\n<li><p>Use TRY/CATCH with THROW</p>\n</li>\n</ul>\n", "tags": ["sql-server", "t-sql", "try-catch", "rollback", "xact-abort"]}
{"id": "d4e40d13-f357-4d13-a431-2b4d938a8bb6", "text": "Q: Using Valgrind with LD_PRELOAD A: <p>You need to set LD_PRELOAD before both Valgrind and the guest executable.</p>\n<p>See the man page for <code>ld.so</code> for more details about how LD_PRELOAD works. In particular</p>\n<pre class=\"lang-none prettyprint-override\"><code>The objects are searched for using the rules given under DESCRIPTION.\n</code></pre>\n<p>and</p>\n<pre class=\"lang-none prettyprint-override\"><code>If a shared object dependency does not contain a slash, then it is searched for in the following order:\n</code></pre>\n<p>Short version of the list of possibilities: DT_RPATH, LD_LIBRARY_PATH, DT_RUNPATH, ld.so.cache and the defaults like /lib and /usr/lib.</p>\n<p>If 'run_program' uses DT_RPATH or DT_RUNPATH then you will have a problem. In that case you need to either include a path containing a '/' with LD_PRELOAD or else use LD_LIBRARY_PATH in conjunction with LD_PRELOAD. This <a href=\"https://bugs.kde.org/show_bug.cgi?id=411203\" rel=\"nofollow noreferrer\">feature request</a>, if implemented, would mean that you could run something like</p>\n<p><code>valgrind -e LD_PRELOAD=foo.so ./run_program</code>.</p>\n<p>Valgrind expects the first non-valgrind argument to be the application to be run (either a script or an executable binary [ELF for Linux FreeBSD and Solaris, macho for macOS).</p>\n<p>For example, running the following script</p>\n<pre><code>#!/usr/bin/env ksh\n\nprint $LD_PRELOAD\n</code></pre>\n<p>$ LD_PRELOAD=/lib64/libc.so.6 valgrind -q ./sh<br />\n/lib64/libc.so.6</p>\n<p>There is no way to &quot;attach&quot; Valgrind to a running executable. It does not use ptrace like debuggers (gdb, lldb and udb for instance).</p>\n<p>More details on what is going on are <a href=\"https://sourceforge.net/p/valgrind/mailman/message/31845078/\" rel=\"nofollow noreferrer\">here</a> and the <a href=\"https://sourceforge.net/p/valgrind/mailman/valgrind-users/thread/1389716849.2363.44.camel%40soleil/#msg31845078\" rel=\"nofollow noreferrer\">full thread</a></p>\n<p>Finally, if you run valgrind with -v you should see something like this (there is a lot of output so I've trimmed a lot). The example below was run with</p>\n<p>valgrind -d pwd<br />\nexport LD_PRELOAD=./myprint.so</p>\n<pre><code>--18766:1: aspacem (0,4,5) /usr/lib64/valgrind/memcheck-amd64-linux\n--18766:1: aspacem (1,49,3) /usr/bin/pwd\n--18766:1: aspacem (2,66,3) /usr/lib64/ld-2.17.so\n[memory map]\n</code></pre>\n<p>memcheck was exec'd by valgrind, and memcheck then mmap'd the guest (pwd) and ld.so, then it started executing the guest, which will start loading dependencies.</p>\n<pre><code>--18766:1: aspacem (0,4,5) /usr/lib64/valgrind/memcheck-amd64-linux\n--18766:1: aspacem (1,49,4) /usr/bin/pwd\n--18766:1: aspacem (2,66,4) /usr/lib64/ld-2.17.so\n--18766:1: aspacem (4,162,5) /usr/lib64/valgrind/vgpreload_core-amd64-linux.so\n--18766:1: aspacem (5,216,5) /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so\n--18766:1: aspacem (6,274,8) /home/paulf/scratch/valgrind/cachegrind/tests/myprint.so\n--18766:1: aspacem (7,337,0) [free slot: size=17  next=0]\n--18766:1: aspacem (8,358,5) /usr/lib64/libc-2.17.so\n[more detailed memory map]\n</code></pre>\n<p>Here the guest has loaded the libs listed in LD_PRELOAD (myprint.so and also core and memcheck, which valgrind added to LD_PRELOAD before execing memcheck). It has also loaded libc.so because pwd has a link dependency on it.</p>\n", "tags": ["c", "valgrind"]}
{"id": "375d39e2-e73b-4ec3-b332-d5a3560ef966", "text": "Q: Auto generate-sources in IntelliJ A: <p>This answer describes an algorithm to run arbitrary selected plugins on save (more correctly, during the IntelliJ's build time).</p>\n<p>First, identify what your plugin and the needed phase are.</p>\n<p>Second, mark it as <code>Execute Before Build</code> and <code>Execute Before Rebuild</code>.</p>\n<p>An example: I have <code>org.apache.cxf:cxf-codegen-plugin</code>. To mark it to run during the IntelliJ's build a.k.a. on save, open &quot;Maven&quot; =&gt; &quot;Plugins&quot; =&gt; select this plugin =&gt; right-click on the phase and mark it accordingly.</p>\n<hr />\n<p>Steps in pictures:</p>\n<p><a href=\"https://i.sstatic.net/51GyvYPHt.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/51GyvYPHt.png\" alt=\"enter image description here\" /></a></p>\n<p><a href=\"https://i.sstatic.net/v8y5n60om.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/v8y5n60om.png\" alt=\"enter image description here\" /></a></p>\n<p><a href=\"https://i.sstatic.net/mdPLA5tDm.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/mdPLA5tDm.png\" alt=\"enter image description here\" /></a></p>\n", "tags": ["java", "maven", "intellij-idea"]}
{"id": "afaccc8f-2d95-4f8d-93b0-7526a43f340f", "text": "Q: How do you tell if caps lock is on using JavaScript? A: <p>The CapsLock observing code can be wrapped in a react hook to be easily integrated with react component code.</p>\n<pre class=\"lang-ts prettyprint-override\"><code>import { useState, useEffect } from 'react'\n\nexport const useCapsLock = () =&gt; {\n  const [capsLockIsActive, setCapsLockIsActive] = useState&lt;boolean&gt;()\n\n  useEffect(() =&gt; {\n    const listener = (e: KeyboardEvent | MouseEvent) =&gt; {\n      // there is a known chromium bug\n      // https://issues.chromium.org/issues/469455172\n      // causing 'keydown' and 'keyup' events\n      // when the browser's autofill feature is used\n      // that are missing the e.getModifierState() function.\n      // Therefore we need this seemingly unnecessary check\n      // if e.getModifierState exists.\n      if (e.getModifierState) setCapsLockIsActive(e.getModifierState('CapsLock'))\n    }\n    document.addEventListener('keydown', listener)\n    document.addEventListener('keyup', listener)\n    document.addEventListener('mousedown', listener)\n    document.addEventListener('mouseup', listener)\n\n    return () =&gt; {\n      document.removeEventListener('keydown', listener)\n      document.removeEventListener('keyup', listener)\n      document.removeEventListener('mousedown', listener)\n      document.removeEventListener('mouseup', listener)\n    }\n  }, [])\n\n  return capsLockIsActive\n}\n</code></pre>\n<p>usage</p>\n<pre class=\"lang-jsx prettyprint-override\"><code>const capsLockIsActive = useCapsLock()\n\n// ...\n\n&lt;&gt;\n  {capsLockIsActive &amp;&amp; (\n    &lt;div className={style.capslockMessage}&gt;Beware: CAPSLOCK is active&lt;/div&gt;\n  )}\n&lt;/&gt;\n</code></pre>\n", "tags": ["javascript", "keyboard", "capslock"]}
{"id": "f6cc6abc-02aa-4948-aeef-a24958f9ac7b", "text": "Q: Add Nullable Data In Dynamic Form Laravel 11 A: <p>Your issue is how you check if the data is sent or not.</p>\n<p>Checking with <code>$request-&gt;barcode[$i] !== &quot;&quot;</code> requires that <code>$request-&gt;barcode[$i]</code> exists so it can be compared to the value <code>&quot;&quot;</code> (empty string)</p>\n<p>You need to check if the array key exists before checking its value like</p>\n<pre class=\"lang-php prettyprint-override\"><code> if (\n    (isset($request-&gt;barcode[$i])  &amp;&amp; $request-&gt;barcode[$i] !== &quot;&quot;) &amp;&amp; \n    (isset($request-&gt;image[$i]) &amp;&amp; $request-&gt;image[$i] !== &quot;&quot;)\n) {\n\n}\n</code></pre>\n<p>When the first statement <code>isset($request-&gt;barcode[$i])</code> returns false, the second one <code>$request-&gt;barcode[$i] !== &quot;&quot;</code> will not be run because it's an AND condition, so you are safe doing it like this.</p>\n<p><strong>Remark:</strong> if we did it in the opposite order like this <code>$request-&gt;barcode[$i] !== &quot;&quot; &amp;&amp; isset($request-&gt;barcode[$i])</code> it will trigger the error. The order is important.</p>\n<p>Here is a simplified example of your code:</p>\n<pre><code>$count = count($request-&gt;size);\n\n//This bit of code is run multiple times while doing the same thing every time\n$fileNames = [];\nforeach ($request-&gt;file('image') as $pack_image) {\n    $fileName = $pack_image-&gt;hashName();\n    $pack_image-&gt;storeAs('products', $fileName);\n    $fileNames[] = $fileName;\n}\n\nfor ($i = 0; $i &lt; $count; $i++) {\n    //You can prepare the data before calling ProductSize::create()\n    $product = [\n        'product_id' =&gt; $products-&gt;id,\n        'size' =&gt; $request-&gt;size[$i],\n        'created_by' =&gt; Auth::user()-&gt;id,\n    ];\n\n    //now check for image and barcode separately and add them to the array if present\n    if (isset($request-&gt;barcode[$i]) &amp;&amp; $request-&gt;barcode[$i] != '') {\n        $product['barcode'] = $request-&gt;barcode[$i];\n    }\n\n    if (isset($request-&gt;image[$i]) &amp;&amp; $request-&gt;image[$i] != '' &amp;&amp; isset($fileNames[$i])) {\n        $product['image'] = $fileNames[$i];\n    }\n\n    $sizes = ProductSize::create($product);\n\n}\n</code></pre>\n<p>PS: I highly suggest to check the links @aynber shared, even if it does not specifically relate to your issue and since you are a beginner, you will learn a lot from it (the answer on that is perfect)</p>\n", "tags": ["laravel", "laravel-11", "dynamic-forms"]}
{"id": "0ce43316-05b9-414f-8d87-c3ab227e5fb4", "text": "Q: Github Actions &#39;**&#39; pattern matches an unexpected branch A: <p>As far as I can tell, github is matching <code>**</code> as anything (as per docs), but discarding the slash completely.</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>    # matches:\n    # - testing/this-should-not-be-ci-run\n    # - testing/ci-test\n    # - this-is-not-a-ci-run\n    # - superci-lious\n    # - ci-cmon-github-wtf\n    # - testing/multiple/levels/wut-ci-wut\n    # - abci-wut\n    # - ci--wut\n    # - ci-\n    #\n    # does not match:\n    # - testing/this-is-ridicilous\n    # - supercilious\n    # - testing/citest\n    # - CI-upper\n    # - testing/ci-/wut\n    branches: [&quot;**/ci-*&quot;]\n</code></pre>\n<p>I would probably give up on getting github to work properly, and fix it by just adding a limited number of levels of leading */. In quick testing, this works to do what you want:</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>    # matches:\n    # - testing/ci-this-should-match\n    # - testing/two/levels/ci-please\n    #\n    # does not match:\n    # - testing/does-ci-still-match\n    # - this-is-stil-not-a-ci-run\n    branches: [&quot;*/ci-*&quot;, &quot;*/*/ci-*&quot;, &quot;*/*/*/ci-*&quot;]\n</code></pre>\n<p>Definitely seems like a bug to me</p>\n<p>edit:</p>\n<p>I've verified that <code>minimatch</code> and <code>bash</code> (with <code>globstar</code> enabled) will not match a pattern <code>**/test-*</code>  to <code>something/inner-test-case</code></p>\n<p>Both of them do (surprisingly to me) match <code>**/test-*</code> to <code>test-something</code></p>\n", "tags": ["github", "github-actions", "pattern-matching"]}
{"id": "22210353-5c07-45c1-b959-d8c2ecd50f5b", "text": "Q: How to install Valgrind on macOS Catalina (10.15) with Homebrew? A: <p>It remains impossible with Homebrew, but you can now build it from source.</p>\n<p>Valgrind now supports macOS 10.15 (from 2025-12-17), using code from Louis Brunner's git repo.</p>\n<p>According to the homebrew <a href=\"https://docs.brew.sh/Support-Tiers\" rel=\"nofollow noreferrer\">documentation</a>, macOS 10.15 has tier 3 support but their formula does not list macOS as supported, only Linux. MacPorts does work on macOS 10.15. Their most recent port is 3.22, 2 years old at the time of writing. It may take quite some time before these packaging systems update to use Valgrind on supported platforms.</p>\n<p>In the meantime, you can build Valgrind from source by following these <a href=\"https://valgrind.org/downloads/repository.html\" rel=\"nofollow noreferrer\">instructions</a>.</p>\n<p>To build from source you will need to install XCode and XCode command line tools. Additionally you will need automake, autoconf and aclocal (MacPorts seems to have the best support for older macOS versions, see <a href=\"https://www.macports.org/install.php\" rel=\"nofollow noreferrer\">https://www.macports.org/install.php</a>).</p>\n<p>Clone the git repo</p>\n<p><code>git clone https://sourceware.org/git/valgrind.git</code></p>\n<p>then change directory to the cloned <code>valgrind</code> directory and look at the README file, in the section &quot;Building and installing it&quot;</p>\n", "tags": ["macos", "homebrew", "valgrind", "macos-catalina", "memory-leak-detector"]}
