{"id": "c5bdf254-509e-4f22-b735-5d2c4a17cd9b", "text": "Q: Entity Framework Code First - Advantages and disadvantages of Fluent Api vs Data Annotations A: <p>Everything what you can configure with DataAnnotations is also possible with the Fluent API. The reverse is not true. So, from the viewpoint of configuration options and flexibility the Fluent API is &quot;better&quot;.</p>\n<p>Configuration examples (for sure not a full list) which are possible in the Fluent API but not with DataAnnotations (as far as I can see):</p>\n<ul>\n<li>Switch off cascading deletes:</li>\n</ul>\n<p><code>.WillCascadeOnDelete(false)</code></p>\n<ul>\n<li>Specify foreign key column name in the database when the key isn't exposed in your object model:</li>\n</ul>\n<p><code>.Map(conf =&gt; conf.MapKey(&quot;MyForeignKeyID&quot;))</code></p>\n<ul>\n<li>Fine granular tuning of relationships, especially in all cases where only one side of an association is exposed in the object model:</li>\n</ul>\n<p><code>.WithMany(...)</code>, <code>WithOptional(...)</code>, <code>WithRequiredDependent(...)</code>, <code>WithRequiredPrincipal(...)</code></p>\n<ul>\n<li>Specification of inheritance mapping between object model and database tables (Table-Per-Hierarchy, Table-Per-Type, Table-Per-Concrete-Class):</li>\n</ul>\n<p><code>.Map&lt;TDerived&gt;(Action&lt;EntityMappingConfiguration&lt;TDerived&gt;&gt; ...)</code></p>\n<p>Edit: Microsoft considers the Fluent API as an &quot;advanced feature&quot; (Quote from <a href=\"https://learn.microsoft.com/en-us/archive/blogs/adonet/ef-4-1-code-first-walkthrough#9-fluent-api\" rel=\"nofollow noreferrer\">here</a>):</p>\n<blockquote>\n<p>The fluent API is considered a more\nadvanced feature and we would\nrecommend using Data Annotations\nunless your requirements require you\nto use the fluent API.</p>\n</blockquote>\n<p>But in my opinion you reach the limitations of DataAnnotations very quickly (except perhaps for extremely simple object models). If you cannot fine tune your model with DataAnnotations anymore your last resort is to follow the default mapping conventions (by naming your properties according to those rules). Currently you cannot overwrite the conventions (only disable them; MS announced to give configuration options for the conventions in future EF releases). But if you don't want to be forced by the mapping conventions when you define your object model, your only option then is the Fluent API.</p>\n<p>Learning the Fluent API is almost a Must imho, the DataAnnotations are a nice-to-have for simple applications.</p>\n", "tags": ["entity-framework", "ef-fluent-api"]}
{"id": "cb1b5032-839d-4940-986f-73c786b4d483", "text": "Q: How to convert a COBOL statement to JSON A: <p>It seems your regex is handling the case where <code>FIELD</code> follows <code>FOR</code>. The negative lookahead is not necessary here.</p>\n<pre><code>pattern = r&quot;MODIFY MAP (?:TEMP|PERM)?\\s*(?:CURSOR)?\\s*(?:AT)?\\s*(?:FIELD)?\\s*(?:DFLD)?\\s+([\\w-]+)&quot;\n</code></pre>\n", "tags": ["python", "regex"]}
{"id": "96bcb2d0-ed79-4666-b9c7-4c85c417ea68", "text": "Q: How to pass database session through Flask context manager A: <p>The lifetime of the <code>g</code> object is limited to that of the <a href=\"https://flask.palletsprojects.com/en/stable/appcontext/\" rel=\"nofollow noreferrer\">application context</a>. Therefore, the memory expires after the <code>with</code> block of the context manager, after the HTTP request, and after the CLI command.</p>\n<p>The solution is to call a function for each new application context that assigns the value to the <code>g</code> object if it hasn't already been assigned.</p>\n<pre class=\"lang-py prettyprint-override\"><code>from flask import Flask, g\n\n# Factory for the application object\ndef create_app():\n    app = Flask(__name__)\n\n    # Factory for the content of the g-object, \n    # reassigns the value if it is not present.\n    def get_foo():\n        if 'foo' not in g:\n            g.foo = 'bar'\n        return g.foo \n\n    with app.app_context():\n        # Application context created\n        foo = get_foo()\n        print(f'create_app: {foo}')\n    # Application context destroyed\n\n    @app.teardown_appcontext\n    def shutdown_session(exc):\n        foo = g.pop('foo', None)\n        print(f'shutdown_session: {foo}')\n\n    @app.route('/')\n    def index():\n        foo = get_foo()\n        return foo \n\n    @app.cli.command()\n    def seed():\n        foo = get_foo()\n        print(f'seed: {foo}')\n\n    return app\n</code></pre>\n", "tags": ["flask"]}
{"id": "1db4688f-5141-4d92-93a0-870619a28c58", "text": "Q: &quot;Forbidden&quot; error when connecting to Jupyter notebook with Google Colab A: <ol>\n<li><p>Go to your jupyter notebook Settings and click Settings Editor <a href=\"https://i.sstatic.net/MBuDzGHp.png\" rel=\"nofollow noreferrer\">See SS</a></p>\n</li>\n<li><p>Search for <em>trust</em> and click the first option <em>Trust HTML by default</em>, and click and select the check box <a href=\"https://i.sstatic.net/43UCtfLj.png\" rel=\"nofollow noreferrer\">See SS</a></p>\n</li>\n<li><p>Re-run the command <code>jupyter notebook --NotebookApp.allow_origin='https://colab.research.google.com' --port=8888 --NotebookApp.port_retries=0 --NotebookApp.allow_credentials=True</code></p>\n</li>\n</ol>\n", "tags": ["linux", "jupyter-notebook", "google-colaboratory"]}
{"id": "c87956d3-99a9-4370-8d9b-dcffc7a9532f", "text": "Q: Material UI: How can I disable scroll bar in datagrid? A: <p>I got the scrollbar removed by adding &quot;'&amp; .MuiDataGrid-virtualScroller::-webkit-scrollbar': {display: 'none' }&quot; in the table style.</p>\n<pre class=\"lang-tsx prettyprint-override\"><code>&lt;DataGrid\n        rows={navigate.rows}\n        columns={columns}\n        getRowHeight={() =&gt; 'auto'}\n        sx={{ '&amp; .MuiDataGrid-row': { marginTop: 1, marginBottom: 1 }, '&amp; .coloured': { textAlign: 'center', color: '#7181AD' },'&amp; .MuiDataGrid-virtualScroller::-webkit-scrollbar': {display: 'none' } }}/&gt;\n</code></pre>\n\n", "tags": ["javascript", "reactjs", "material-ui", "datagrid", "mui-x-data-grid"]}
{"id": "35573036-d430-415b-9b8b-57345162bbc5", "text": "Q: ERROR Backend subproccess exited when trying to invoke get_requires_for_build_sdist A: <p>The error <code>ERROR Backend subproccess exited when trying to invoke get_requires_for_build_sdist</code> is a general message indicating that the build backend (setuptools in this case) failed for some reason. The true root cause of your problem is revealed in the line just before it:</p>\n<pre><code>error: package directory 'src/classevivaAPI' does not exist\n</code></pre>\n<p>This error means that your packaging configuration is telling <code>setuptools</code> to look for your package's source code inside a directory named <code>src</code>, but your project's file structure doesn't match this expectation. The <code>classevivaAPI</code> package directory is likely in the root of your repository, not inside a <code>src</code> directory.<br />\n<br />\nMaybe you could create a <code>src</code> directory in the root of your repository and move your package directory <code>classevivaAPI</code> inside the src directory.</p>\n", "tags": ["python", "pip", "package", "github-actions", "pypi"]}
