{"id": "a731eb17-8e6c-4748-87dc-f494d8db6026", "text": "Q: Get reason that LoadLibrary cannot load DLL A: <p>You can call <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode\" rel=\"nofollow noreferrer\"><code>SetErrorMode(0)</code></a> before <code>LoadLibrary()</code>. This enables a system popup to be displayed when LoadLibrary fails, showing more details.</p>\n<p><a href=\"https://i.sstatic.net/pB12tzPf.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/pB12tzPf.png\" alt=\"example popup\" /></a></p>\n<p>To hide this popup again, call <code>SetErrorMode(SEM_FAILCRITICALERRORS)</code>, or restore its old value:</p>\n<pre><code>UINT old_error_mode = SetErrorMode(0);\nLoadLibrary(); // The popup will contains DLL or symbol which is not found\nSetErrorMode(old_error_mode);\n</code></pre>\n", "tags": ["c++", "winapi", "loadlibrary"]}
{"id": "d662e5f3-2ad4-4ceb-8025-ced152bda787", "text": "Q: Real-time ranking and percentile calculation on streaming data in DolphinDB A: <p>The above requirements can be efficiently implemented using DolphinDB's CrossSectionalEngine. This engine is specifically designed to maintain the latest indicator values for each symbol and calculate real-time cross-sectional rankings when data is updated.</p>\n<p>This engine can achieve:</p>\n<ul>\n<li><p>Key-value table maintenance: The cross-sectional engine automatically maintains a dictionary keyed by 'sym', storing the latest f1 value for each symbol.</p>\n</li>\n<li><p>Row-by-row triggering: Configure triggeringPattern=&quot;perRow&quot; so that ranking calculations are triggered immediately each time a row of data is written.</p>\n</li>\n<li><p>Real-time calculation: Calculate ranking and percentile based on the latest f1 values of all symbols in the current cross-section.</p>\n</li>\n</ul>\n<p>The reference script is as follows:</p>\n<pre><code>dropStreamEngine(&quot;rankdemo&quot;)\n// Each insert will output a group\nshare streamTable(10:0,`sym`f1`datetime,[SYMBOL,DOUBLE,TIMESTAMP]) as t1\n\n// If you only want to maintain the latest ranking of the sym group, you can define opt as a keyedTable\nshare table(1:0, `datetime`sym`f1`f1rank`f1rankpercentile, [TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE]) as opt\n\ncsEngine1=createCrossSectionalEngine(name=&quot;rankdemo&quot;, metrics=&lt;[sym, f1, rank(f1, tiesMethod=&quot;first&quot;)+1, each(percentileRank{f1}, f1)]&gt;, dummyTable=t1, outputTable=opt, keyColumn=`sym, triggeringPattern=&quot;perRow&quot;, useSystemTime=false, timeColumn=`datetime)\n\ninsert into csEngine1 values(`A, 10, 2022.01.04 09:00:00.000)\ninsert into csEngine1 values(`A, 12, 2022.01.04 09:00:00.020)\ninsert into csEngine1 values(`B, 9, 2022.01.04 09:00:00.120)\ninsert into csEngine1 values(`C, 12, 2022.01.04 09:00:00.220)\ninsert into csEngine1 values(`B, 10, 2022.01.04 09:00:00.320)\n\nprint opt\n\n// output\ndatetime                sym f1 f1rank f1rankpercentile\n----------------------- --- -- ------ ----------------\n2022.01.04T09:00:00.000 A   10 1      0               \n2022.01.04T09:00:00.020 A   12 1      0               \n2022.01.04T09:00:00.020 A   12 2      100             \n2022.01.04T09:00:00.120 B   9  1      0               \n2022.01.04T09:00:00.020 A   12 2      100             \n2022.01.04T09:00:00.120 B   9  1      0               \n2022.01.04T09:00:00.220 C   12 3      100             \n2022.01.04T09:00:00.020 A   12 2      100             \n2022.01.04T09:00:00.320 B   10 1      0               \n2022.01.04T09:00:00.220 C   12 3      100  \n</code></pre>\n", "tags": ["streaming", "real-time", "dolphindb"]}
{"id": "d7a02f03-12f0-48c4-870e-7b73b785199d", "text": "Q: How do you use mongodb native, express and body-parser to post request and save data? A: <p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\" data-babel-preset-react=\"false\" data-babel-preset-ts=\"false\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nvar urlencodedParser = bodyParser.urlencoded({ extended: false });\n\nconst MongoClient = require('mongodb').MongoClient;\n\n// Connection URL\nconst url = \"mongodb://localhost:27017\";\n\napp.listen(7000);\n\n\napp.get('/', function(req, res){\n    res.sendFile(__dirname + '/index.html');\n})\n\napp.post('/todo',urlencodedParser,function(req, res){\n\n    MongoClient.connect(url, { useNewUrlParser: true }, function(err,db){\n        if(err) throw err;\n        console.log('Databese created!');\n        db.collection.insertOne(req.body);\n        db.close();\n    });\n    console.log(req.body);\n});</code></pre>\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\" dir=\"ltr\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;title&gt;&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        I am an index page.\n\n        &lt;form class=\"\" action=\"/todo\" method=\"post\"&gt;\n            &lt;input type=\"text\" name=\"name\" placeholder=\"todo\"&gt;\n            &lt;input type=\"text\" name=\"priority\" placeholder=\"priority\"&gt;\n            &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</div>\n</div>\n</p>\n", "tags": ["javascript", "mongodb", "express", "post", "body-parser"]}
{"id": "d2cbb934-75bb-4e51-ab22-329b330d3707", "text": "Q: What is the new way of extending AbstractMappingJacksonResponseBodyAdvice with Jackson3? A: <p>I was facing the same issue so this is a working way around this by getting the current <code>HttpServletRequest</code> with the help of <code>RequestContextHolder </code>and then get the relevant query param to decide which view to use and set it as a write hint.</p>\n<p>Be aware that this is not going to work with spring-webflux and there might be problems with using @Async on the controller level but i did not test it.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@ControllerAdvice(assignableTypes = {\n        YourRestController.class\n})\nclass JsonViewResolverAdvice implements ResponseBodyAdvice&lt;Object&gt; {\n\n    @Override\n    public boolean supports(\n            MethodParameter returnType,\n            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType\n    ) {\n        return converterType == JacksonJsonHttpMessageConverter.class;\n    }\n\n    @Override\n    public @Nullable Map&lt;String, Object&gt; determineWriteHints(\n            @Nullable Object body,\n            MethodParameter returnType,\n            MediaType selectedContentType,\n            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType\n    ) {\n        var request = getCurrentHttpRequest();\n\n        if (request == null) return null;\n\n        var requestedView = \n            requireNonNullElse(request.getParameter(&quot;include&quot;), &quot;&quot;);\n        \n        var view = switch (requestedView) {\n            case CustomJsonView.IncludeDetails.VALUE\n                    -&gt; CustomJsonView.IncludeDetails.class;\n            default -&gt; CustomJsonView.BasicView.class;\n        };\n\n        return Map.of(JsonView.class.getName(), view);\n    }\n\n    @Override\n    public @Nullable Object beforeBodyWrite(\n            @Nullable Object body, MethodParameter returnType,\n            MediaType selectedContentType,\n            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,\n            ServerHttpRequest request, ServerHttpResponse response) {\n        // do nothing\n        return body;\n    }\n\n    private @Nullable HttpServletRequest getCurrentHttpRequest() {\n        return Optional.ofNullable(RequestContextHolder.getRequestAttributes())\n                .filter(ServletRequestAttributes.class::isInstance)\n                .map(ServletRequestAttributes.class::cast)\n                .map(ServletRequestAttributes::getRequest)\n                .orElse(null);\n    }\n}\n</code></pre>\n", "tags": ["spring", "spring-boot", "spring-mvc"]}
{"id": "424d22f3-fb84-4f5b-bfa4-211c9bf6c0e0", "text": "Q: ZSH Keybindings A: <p>Your approach looks sound. But maybe your terminal emulation sends different key codes? You should use <code>cat</code>or <code>^v</code> to verify your codes. See: <a href=\"https://zsh.sourceforge.io/Guide/zshguide04.html#l96\" rel=\"nofollow noreferrer\">the zsh guide</a>.</p>\n<p>To make the prompt change instantly, include <code>zle reset-prompt</code> in the function.</p>\n<p>The <code>bindkey -s</code> version is avoiding a function.</p>\n", "tags": ["zsh", "zsh-zle"]}
{"id": "58766e24-ae10-472e-832e-96abae4632bc", "text": "Q: List&lt;IFormFile&gt; is null for large files A: <p>ASP.NET Core can handle huge <code>multipart/form-data</code> requests just fine, <a href=\"https://learn.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-10.0#small-and-large-files\" rel=\"nofollow noreferrer\">but you cannot use <code>[FromForm]</code> binding to <code>IFormFile</code> (or <code>FormFile</code>) for requests larger than 128MB</a>:</p>\n<p>You <em>can</em> adjust <a href=\"https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.features.formoptions.multipartbodylengthlimit?view=aspnetcore-10.0#microsoft-aspnetcore-http-features-formoptions-multipartbodylengthlimit\" rel=\"nofollow noreferrer\">the <code>FormOptions.MultipartBodyLengthLimit</code> value</a> to a larger value, but I don't recommend it here because it sounds like you're dead-set on allowing multi-gigabyte sized uploads, which aren't going to buffer well.</p>\n<p>Note that <code>FormFile</code> does buffer to-disk once the amount of data received exceeds the in-memory maximum (a paltry 64KB), but I suspect you probably don't want these centigigabyte-sized blobs filling up your system's local disks either.</p>\n<p>Instead, I recommend you follow <a href=\"https://learn.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-10.0#upload-large-files-with-streaming\" rel=\"nofollow noreferrer\">the instructions under <em><strong>Upload large files with streaming</strong></em> instead</a>:</p>\n<pre><code>private const Int64 HUNDRED_GIGABYTES = 100 * 1024 * 1024 * 1024; // 107,374,182,400 bytes\n\n[HttpPost]\n[RequestSizeLimit( HUNDRED_GIGABYTES )]\npublic async Task&lt;IActionResult&gt; PostFormData( CancellationToken cancellationToken )\n{\n    MediaTypeHeaderValue requestContentType = MediaTypeHeaderValue.Parse( this.Request.ContentType );\n    String requestMultipartBoundary = HeaderUtilities.RemoveQuotes( requestContentType.Boundary ).Value;\n\n    //\n\n    MultipartReader reader = new MultipartReader( requestMultipartBoundary, this.Request.Body );\n    \n    while( true )\n    {\n        MultipartSection? section = await reader.ReadNextSectionAsync( cancellationToken );\n        if( section is null ) break;\n\n        ContentDispositionHeaderValue? cd = section.GetContentDispositionHeader();\n        if( cd is null ) continue;\n        if( !cd.IsFileDisposition() ) continue;\n\n        //\n\n        using( Stream outputStream = /* FileStream? SAN stream? Some stream-consumer adapted into a Sink-Stream? etc? */ )\n        {\n            await section.Body.CopyToAsync( outputStream, cancellationToken );\n        }\n    }\n}\n</code></pre>\n<p>Further improvements are possible still: for example, use <code>HttpRequest.BodyReader</code> (an <code>PipeReader</code>) for lower-level access - though you'll need to parse/process <code>multipart/form-data</code> separators yourself.</p>\n", "tags": ["javascript", "c#", "file-upload", "multipart"]}
{"id": "4f5766a0-6359-47a2-b36a-b320c5896585", "text": "Q: API response is in stream. How should I convert that in dart so I can show it in the UI? A: <p>Actually you're correctly decoding the streamed response, but the issue is that the openapi-style streaming API does <strong>not</strong> return clean linebyline text. The <code>http</code> package stream often emits <strong>partial chunks</strong>, not full lines, so your <code>await for (final line in stream)</code> never receives a complete <code>&quot;agent-stream-start:&quot;</code> prefix to match.</p>\n<p>This is why your <code>cleaned</code> value never prints.<br />\nThe chunk boundary may split like this:</p>\n<pre><code>agent-strea\nm-start:Hello, Faseeh...\n</code></pre>\n<p>Your replace logic never matches the whole pattern.</p>\n<hr />\n<h2><strong>Fix: Use a buffer and extract the prefix safely</strong></h2>\n<pre><code>final stream = streamedResponse.stream.transform(utf8.decoder);\n\nString buffer = '';\n\nawait for (final chunk in stream) {\n  buffer += chunk;\n\n  // Check if the prefix exists in the current aggregated buffer\n  const prefix = &quot;agent-stream-start:&quot;;\n\n  if (buffer.contains(prefix)) {\n    final startIndex = buffer.indexOf(prefix) + prefix.length;\n    final cleaned = buffer.substring(startIndex).trim();\n\n    // Now cleaned contains your actual AI response text\n    yield cleaned;\n\n  }\n}\n</code></pre>\n<h3>Why this works</h3>\n<ol>\n<li><p><strong>Stream chunks are unpredictable</strong>, so you accumulate them into a buffer.</p>\n</li>\n<li><p>Once the buffer contains the prefix, you safely extract everything after it.</p>\n</li>\n<li><p>This works even if the prefix spans multiple TCP chunks.</p>\n</li>\n</ol>\n<hr />\n<h2><strong>If you want token-by-token UI streaming (typing effect)</strong></h2>\n<pre><code>if (cleaned.isNotEmpty) {\n  for (int i = 0; i &lt; cleaned.length; i++) {\n    yield cleaned.substring(0, i + 1);\n    await Future.delayed(const Duration(milliseconds: 12));\n  }\n}\n</code></pre>\n<p>The real issue was that your <code>line</code> variable never contained the full prefix</p>\n", "tags": ["flutter", "stream", "fastapi"]}
